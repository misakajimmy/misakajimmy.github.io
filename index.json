[{"body":"前端学习笔记\n","link":"https://misakaJimmy.github.io/docs/frontend/","section":"docs","title":"Frontend"},{"body":" 什么是终身学习？ 终身学习是一种以个人发展为重点的自发教育形式。虽然终身学习没有标准化的定义，但它通常是指发生在正规教育机构之外的学习，例如学校、大学或企业培训。 然而，终身学习并不一定限于非正式学习。最好将其描述为以实现个人成就为目的的自愿。实现这一目标的手段可能会导致非正式或正式的教育。\n终身学习的重要性 无论是追求个人兴趣和激情，还是追求职业抱负，终身学习都可以帮助我们实现个人成就感和满足感。\n它承认人类有探索、学习和成长的自然动力，并鼓励我们通过关注激发我们灵感的想法和目标来提高我们自己的生活质量和自我价值感。\n我们都是终身学习者 但是个人成就感是什么意思呢？\n现实情况是，我们大多数人在正规学校教育和工作之外都有目标或兴趣。这就是作为人类的一部分含义：我们有天生的好奇心，我们是天生的学习者。我们的发展和成长得益于我们的学习能力。\n终身学习认识到并非我们所有的学习都来自课堂。\n例如，在童年时期，我们学习说话或骑自行车。 作为成年人，我们学习如何使用智能手机或学习如何烹饪新菜。 这些是我们每天通过社交、反复试验或自发学习进行的日常终身学习的例子。\n个人成就和发展是指引导我们学习新事物的自然兴趣、好奇心和动机。我们为自己学习，而不是为别人学习。\n终身学习的关键清单 自主性 自我激励或自我发起 并不总是需要成本 通常是非正式的 自学或寻求指导 动机是出于个人兴趣或个人发展 终身学习的例子 以下是您可以参与的一些终身学习计划类型：\n培养新技能（例如缝纫、烹饪、编程、公开演讲等） 自学学习（例如学习一门新语言、研究感兴趣的话题、订阅播客等） 学习一项新的运动或活动（例如参加武术、学习滑雪、学习锻炼等） 学习使用新技术（智能设备、新软件应用程序等） 获取新知识（通过在线教育或课堂课程学习自学课程） 终身学习的好处 将终身学习融入您的生活可以带来许多长期利益，包括：\n1. 新的自我激励 有时，我们在做某事时会陷入常规，仅仅是因为我们必须这样做，例如去上班或打扫房子。\n弄清楚是什么激发了你的灵感，让你重新回到驾驶座上，并提醒你在生活中你真的可以做你想做的事情。\n2. 认同个人兴趣和目标 重新点燃让你成为一个人的东西，减少无聊，让生活更有趣，甚至可以打开未来的机会。\n如果你专注于它们，你永远不知道你的兴趣会把你带到哪里。\n3. 其他个人和专业技能的提高 在我们忙于学习新技能或获取新知识的同时，我们也在培养其他有价值的技能，这些技能可以在我们的个人和职业生活中为我们提供帮助。\n这是因为我们利用其他技能来学习新事物。例如，学习缝纫需要解决问题。学习绘画涉及培养创造力。\n技能发展可以包括人际交往能力、创造力、解决问题的能力、批判性思维、领导力、反思、适应能力等等。\n4. 增强自信心 在某些方面变得更有知识或技能可以增加我们在个人和职业生活中的自信心。\n在我们的个人生活中，这种自信可以源于投入时间和精力学习和提高的满足感，给我们一种成就感。 在我们的职业生涯中，这种自信可以是我们对自己的知识和应用所学知识的能力的信任感。 我需要积极主动地进行终身学习吗？ 大多数人会在日常生活中的某个时刻通过与他人交谈、根据个人兴趣浏览互联网、阅读报纸或参与个人兴趣来学习新东西。\n但是，如果出于个人、家庭或职业原因，更加努力地学习新事物很重要，或者需要一个更有条理的结构，那么这里有一些开始的步骤。\n如何在生活中采用终身学习？ 1. 认清自己的个人兴趣和目标 终身学习是关于你自己，而不是其他人以及他们想要什么。反思你对什么充满热情以及你对自己未来的展望。\n如果职业发展是您的个人兴趣，那么有多种方法可以参与自主学习来实现这一目标。如果学习历史是您的热情，那么同样有其他方法可以进一步探索这种兴趣。\n2. 列出你想学习或能够做的事情 一旦你确定了是什么激励了你，探索你想要实现的特定兴趣或目标是什么。\n回到我们对历史充满热情的例子，也许只是希望扩大对欧洲历史的了解。或者也许兴趣如此强烈以至于攻读博士学位。是梦想的目标。\n这两者都是不同的兴趣水平，需要不同的学习方式。\n3. 确定您想如何参与以及可用的资源 实现我们的个人目标首先要弄清楚如何开始。\n研究和阅读兴趣和目标可以帮助制定如何去学习它。\n以我们的历史为例：只想了解更多特定历史时期的人可以在图书馆目录、博客、杂志和播客中找到专门针对该主题的书籍，甚至博物馆和讲座。\n想要获得博士学位的个人。在历史上，个人目标可以研究可以兼职或在线完成的大学课程，以及达到博士学位所需的步骤。\n4. 将学习目标融入你的生活 在忙碌的生活中制定新的学习目标需要考虑和努力。如果你不为它腾出时间和空间，它就不会发生。\n它很容易导致气馁或完全放弃学习计划。\n计划新学习计划的要求如何融入您的生活，或者您需要做些什么来使其适应。例如，如果学习一门新语言是学习目标，你能每天抽出一小时的时间吗？还是每天 15 分钟听起来更现实？\n了解您可以为学习目标投入的时间和空间可以帮助您长期坚持目标。\n5. 做出承诺 做出参与新学习计划的决定是最后也是最重要的一步。如果您设定了切合实际的期望并有自我激励来实现它，那么请致力于它并避免找借口。\n","link":"https://misakaJimmy.github.io/docs/","section":"docs","title":"Lifelong Learning"},{"body":" 这篇更像是我自己啃 Lumino 源码和周边资料的一些读书笔记，方便之后写 Theia 架构时有个“底层 UI 框架”的背景板。\nLumino 是什么？ 简单一句话：Lumino 是一套给 Web 应用带来「桌面应用感」窗口/布局系统的 UI 基础框架。\n它主打几个特性：\n可停靠（docking）和分屏布局：窗口可以左右、上下拖拽拆分，支持多层嵌套。 标签页（tabbed）管理：一个区域里可以放多个 tab，支持拖拽排序、拖出合并。 Widget 抽象：把 UI 组件都抽象成 Widget，对生命周期、布局和消息分发进行统一管理。 命令与快捷键系统：内建 Command \u0026amp; Keybinding 概念，方便 IDE 类应用统一处理交互。 如果你用过 JupyterLab 或 Theia，其实已经在间接使用 Lumino 了：那种可以随意拖拽 panel、拆分编辑区的体验，背后就是 Lumino 这套桌面感窗口系统在撑腰。\nLumino 的前世：从 PhosphorJS 到 JupyterLab 内核 Lumino 不是凭空冒出来的，它的前身叫 PhosphorJS：\n最早的动机：Jupyter 团队在做 JupyterLab 的时候，就不满足于“在页面里堆几个 iframe 或 div”，他们想要的是更像桌面 IDE 的体验——可以像 VS Code 一样随意拆分编辑器、停靠面板，于是就有了 PhosphorJS 这个专门做 dock layout 的 UI 库。 功能慢慢长胖：随着 JupyterLab 不断演进，PhosphorJS 也不再是单纯的 dock panel；它开始承担 widget 管理、命令系统、菜单/面板布局等一整套 UI 基础设施。 与应用高度耦合：PhosphorJS 一开始更多是“为 JupyterLab 服务”的内部项目，很多设计和 API 都是围绕 JupyterLab 的需求长出来的。 后来社区的诉求越来越明显：这套 UI 能不能抽出来，给别的 Web IDE / 工具类应用用？ 于是就出现了 Lumino 这个名字。\nLumino 的今生：从 Jupyter 内核到通用布局框架 可以粗暴地理解为：Lumino = “抽离重构之后的 PhosphorJS / JupyterLab UI 内核”。\n重新命名与打包：为了更清晰地区分历史包袱和全新定位，Jupyter 团队把原来的 PhosphorJS 抽出来，整理成一组以 @lumino/* 命名的 npm 包，做成一个相对独立、通用的 UI 框架。 更通用的定位：官方不再以“Jupyter 专用 UI 框架”自居，而是把 Lumino 当成“构建复杂、多窗口 Web 工具型应用”的基础设施——JupyterLab 是一个重度使用者，但不是唯一。 API 和模块划分更清晰：例如： @lumino/widgets：Widget 抽象、Panel、DockPanel、TabBar 等。 @lumino/signaling：轻量级事件/信号系统。 @lumino/commands：命令系统。 @lumino/messaging：Widget 间消息派发。 这些模块化拆分，让框架更适合作为通用依赖被其他项目引用。 在这个阶段，Theia 这类 IDE 平台就有机会直接复用 Lumino 的成果，而不用自己从头再造一套 dock layout 系统。\n为什么 IDE 类项目会盯上 Lumino？ 从 Theia 的视角看，选择 Lumino 有几层现实原因：\n不想自己再造一套复杂布局系统：多窗口、多分屏、拖拽合并这些需求看起来只是“UI 小细节”，但真正实现一遍是个大坑；Lumino 已经在 JupyterLab 里被狠狠验证过一轮。 桌面感交互体验成熟：Lumino 更像是在 Web 上实现了“迷你版桌面窗口管理器”，它处理的不是简单的 flex 布局，而是一整套 dock / tab / split 逻辑，这和 IDE 这种应用的交互模型高度吻合。 Widget + Command 的模式对 IDE 很友好：IDE 里充满了“视图 + 命令 + 快捷键”的组合，Lumino 内建的 widget + command 机制，可以和 Theia 自己的 command/菜单/快捷键系统自然对接。 对我个人来说，一开始看 Theia 源码的时候，看到那一堆 shell、panel、area 的布局逻辑时是有点懵的，直到顺藤摸瓜翻到 Lumino 的文档和代码，才慢慢意识到：\nTheia 自己只是在“描述要有哪些区域”，真正负责“怎么在页面上摆好这些区域”的，是 Lumino。\nLumino 的几个核心设计点（以一个学习者的视角） 从源码和示例里，我大致会把 Lumino 的核心设计分成几块来理解：\nWidget 是一等公民\n所有可视组件基本都被抽象成 Widget，Widget 负责： 管自己的 DOM 节点。 响应 attach/detach、resize 等生命周期。 这和 React/组件化思路有点像，但 Lumino 更偏底层，更关心“这个组件在页面哪个矩形区域里呈现”。 布局 = 容器 Widget 的组合\nDockPanel、SplitPanel、TabBar 这些都是特殊的“布局 Widget”，它们并不关心业务，只负责怎么把子 Widget 摆放到正确的位置。 这点对阅读 Theia 的外壳（shell）代码很关键：很多时候你看到的是 Theia 在操作 Lumino 的 DockPanel，而不是直接改 DOM。 信号和消息机制\n@lumino/signaling 提供了一种比裸 EventEmitter 更规整的信号系统，用来在 Widget 之间传递事件。 @lumino/messaging 则负责在 Widget 内部调度诸如 resize、update 这类消息，让布局和渲染有序进行。 这套机制是整个桌面感窗口系统稳定运行的“血液循环”。 命令系统\n@lumino/commands 定义命令、快捷键和菜单项之间的映射。 在 IDE 这个场景里，命令系统其实是 UI 的“第二条主线”：很多行为不是直接绑在按钮上，而是先声明成命令，再由不同的触发源（菜单、快捷键、按钮）去调用。 这些东西，如果只从 Theia 的扩展代码往下看，很容易糊成一片；反过来先在 Lumino 里把这些概念吃透，再回头看 Theia，会清爽很多。\n个人感受：为什么值得单独写一篇 Lumino 笔记？ 对我自己来说，Theia 架构里最“像黑盒”的一层就是桌面感窗口系统：\n我们一直在用 IDE 的分屏和停靠功能，但很少认真想过“浏览器里到底是怎么实现一个像桌面应用一样的窗口管理”的。\nLumino 刚好把这一块剥离成了一个可学习、可复用的库：\n作为 Theia 的使用者或扩展开发者，理解 Lumino 可以帮我们： 更自信地调整布局区域（main / bottom / left / right）。 在合适的地方插入自己的 Widget，而不是“瞎试位置”。 作为 对前端基础设施感兴趣的工程师，Lumino 又是一个很好的“源码读物”： 它不是花哨的 UI 组件库，而是偏底层的布局和交互内核。 既能看到经典的命令/消息/信号模式，又能看到它们如何落地到复杂产品（JupyterLab、Theia）里。 所以这篇就当是给后面几篇 Theia 架构解析打地基：\n先把 Lumino 这块“桌面感窗口系统”的底层认清楚，再去看 Theia 怎么在它之上堆出一个完整 IDE。\n这里面几个分析笔记毕竟不是详细的教程，只是我自己啃源码的读书笔记，可能会有些碎片化，但希望能给想要深入理解 Theia UI 架构的朋友一些启发。详细的示例代码我感觉 Lumino 官方文档已经写得不错了，想要上手的朋友可以直接看官方的文档，里面的示例就能挺好的说明问题了。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/","section":"docs","title":"Lumino：桌面感窗口系统的前世今生"},{"body":"1docker pull bitnami/postgresql:12 docker-compose 1version: \u0026#39;3.5\u0026#39; 2 3services: 4 postgres: 5 container_name: postgres_container 6 image: postgres 7 environment: 8 POSTGRES_USER: postgres 9 POSTGRES_PASSWORD: password 10 PGDATA: /data/postgres 11 volumes: 12 - postgres:/data/postgres 13 ports: 14 - \u0026#34;5432:5432\u0026#34; 15 networks: 16 - postgres 17 restart: unless-stopped 18 19 pgadmin: 20 container_name: pgadmin_container 21 image: dpage/pgadmin4 22 environment: 23 PGADMIN_DEFAULT_EMAIL: misakajimmy@gmail.com 24 PGADMIN_DEFAULT_PASSWORD: admin 25 PGADMIN_CONFIG_SERVER_MODE: \u0026#39;False\u0026#39; 26 volumes: 27 - pgadmin:/root/.pgadmin 28 29 ports: 30 - \u0026#34;3080:80\u0026#34; 31 networks: 32 - postgres 33 restart: unless-stopped 34 35networks: 36 postgres: 37 driver: bridge 38 39volumes: 40 postgres: 41 pgadmin: ","link":"https://misakaJimmy.github.io/docs/database/postgresql/postgresql-docker/","section":"docs","title":"PostgreSQL Docker 启动"},{"body":" 为什么要对 Theia 解析 从前端开发的视角来看，Theia 并不仅仅是一个“长得像 VS Code 的 IDE 壳”，而是一套可高度定制的开发平台。\n要想在自己的产品里稳定地集成 Theia（例如做云 IDE、企业内部开发平台、在线教学环境等），就必须理解它的整体架构：\nTheia 的客户端/服务端分层：前端运行在浏览器或桌面容器内，核心能力很多是通过后端扩展来完成的，需要清楚哪些逻辑应该放在前端、哪些要放在后端。 扩展机制与依赖注入（InversifyJS）：Theia 几乎所有功能都是扩展包拼装出来的，通过依赖注入进行解耦；只有理解这一套机制，才能正确地裁剪、替换或新增功能。 与 VS Code 插件生态的关系：Theia 支持 VS Code 插件协议，如果不了解其适配层与限制，很容易在选型插件时踩坑。 通过对 Theia 的架构进行系统性解析，可以帮助我们在二次开发时做出更合理的技术决策，例如：如何设计自己的扩展包结构、如何部署后端服务、以及在性能与可维护性之间做怎样的取舍。\n本人在 Theia 项目 1.0 的时期就开始研究 Theia 项目了，也仿照 Theia 项目做过一个静态的离线版本的 IDE 并做了些插件，也给这个项目提交过 commit (虽然很微小就是了)。后面虽然因为工作原因没有继续深入研究这个项目了，但一直对这个项目很感兴趣，最近又重新捡起来了，所以就想写一些关于 Theia 的架构解析的文章来记录一下自己的学习过程，也希望能对一些想要了解 Theia 的朋友有所帮助。\nTheia 1.0 和 2.0 的不同 总的来说，Theia 2.0 并不是“推倒重来”的全新产品，更像是在 1.x 基础上的一次体系化升级：核心理念（云 + 桌面双形态、前后端分离、通过扩展包拼装 IDE 功能）保持不变，但在依赖版本、扩展 API、VS Code 兼容性和项目结构等方面做了比较集中、成体系的调整。整体可以理解为：2.0 系列把 1.x 时代逐步累积的“技术债”和“历史包袱”做了一次清理，并顺带把底层技术栈和生态支持拉到了一个更现代的基线。\n架构与项目结构层面的差异 依旧是前后端分离 + 扩展驱动架构：1.0 和 2.0 在大架构上没有本质变化，仍然是 Browser/Electron 前端 + Node.js 后端扩展的模式，功能通过一系列 @theia/* 扩展包组合出来。 对历史包的清理：2.0 中，很多在 1.x 里长期被标记为 deprecated 的包和 API 被正式移除或合并，项目结构更扁平、命名也更统一，这对“跟着源码学架构”的人来说反而更清晰。 底层依赖的升级：随着 Node.js、Electron/Chromium、Monaco 等依赖版本的提升，2.0 在性能、安全性和新特性支持上更好，但也意味着一些依赖旧版本行为的代码在升级时需要仔细验证。 扩展 API 与 VS Code 生态的演进 清理旧的扩展点和内部 API：1.x 时代很多为兼容历史场景而留下的 service / contribution / command 等扩展点，在 2.0 中被统一和收敛，内部使用方式也更加一致，减少了“同一件事有多种写法”的情况。 更紧密地对齐 VS Code 插件 API：Theia 一直把“兼容 VS Code 插件”作为卖点，2.0 进一步对齐到了更高版本的 VS Code API，支持更多调试、语言服务、终端等新特性；一些早期特有的 Theia Plugin API 能力则被弱化或建议迁移到标准 VS Code 扩展模型上。 扩展开发体验的改进：官方脚手架、示例仓库和文档也围绕 2.0 做了更新，更强调以“应用 + 扩展包 + VS Code 插件”三层来思考项目结构，而不是简单堆 extension。 对使用者和二次开发者意味着什么？ 如果你有 1.0 时代的自研扩展：升级到 2.0 时，重点是排查：是否使用了已被标记为 deprecated 的 API、是否依赖了被重构的 service / contribution、是否直接 import 了内部模块。这部分改动通常集中在少数基础设施扩展上，迁移一次之后收益是长期的。 如果你更多是作为 Theia 应用的“集成者”（主要关心如何挑选和组合扩展、VS Code 插件）：2.0 带来的更多是“兼容性和可预期性”的提升，你可以更放心地复用社区的 VS Code 插件，同时获得更长的维护周期。 从学习角度看：选择在 2.0 版本重新梳理 Theia 架构是很划算的——一方面，很多历史遗留设计已经在 2.0 中被“官方示范”成更合理的形态；另一方面，你在阅读源码和设计自己扩展时，可以直接对标最新的一套最佳实践，而不必在 1.x 的历史折衷里兜圈子。 ","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/","section":"docs","title":"Theia 架构解析"},{"body":" 为什么要写这个系列的笔记 这个系列文章作为我 Web IDE 的开发心得笔记，至于为什么要做一款纯在线的 IDE 要从以下这么几点讲起。\nIDE 对于程序开发的作用 写程序无非就是以人类能理解的文本形式来有规律有目的控制计算机进行计算。而当在开发规模非常小时，比如当写一个简单功能的 bash 脚本时，直接对文本文件进行编辑，直接使用 echo 或者 Vim 都可以非常简单的解决问题，当然如果 Vim 经过一些改造，某种程度上其实也是一个 IDE。但是如果程序规模一旦大了之后，就会遇到以下的一些需求。\n代码缩进 语法检查 代码分包 代码高亮 语法提示 这些需求的满足对于写代码的人来说非常有帮助，开发者可以更多的将自己的注意力集中于实现当前的功能，而不是繁杂的语法或者其他的编程细节。在今天写代码更多的是为了实现功能，而不是为了去炫技，抱着一本魔法辞典去放魔法的时代已经过去了，更多的降低写代码的门槛以使得更多的更快的将学习者变成开发者是一个不可避免的大趋势，为了达成以上的愿景 IDE 就此诞生。\n如今市面上的 IDE 在我观测的范围内如今做的比较好的桌面级 IDE 为 VS Code 以及 JetBrain 家的一些列针对各种语言特化的 IDE。 VS Code 作为免费的 IDE，其极佳的扩展性以及丰富的扩展生态被广泛的在各个领域使用。JetBrain 作为一款付费 IDE 却仍然有强大的竞争力，其核心在于专注于对各种语言的特化，使得一种开发语言就有一款专门的 IDE 来对其中的开发痛点进行补足，相比起 VS Code 来更强的代码补全，代码高亮，以及更友好的开发环境配置，唯一的可能的不足就是收费？\n以上的 VS Code 和 JetBrain 作为桌面级别的IDE，用于专业开发者的开发自是极佳的，但是如果给一些刚入门的新手可能还是不够适合的，VS Code 在需要一些比较麻烦的环境配置，而且这个环节还是挺劝退的，而 JetBrain 作为一个付费 IDE 对于学习者也天然的会有畏惧心理。\n而如今市面上又出现了很多在线版本的 IDE，比如老牌 IDE 厂家 eclipse 的开源在线IDE theia，还有 code-server 等等。不同于传统的桌面级 IDE，这些网页版的 IDE 做出了一些与众不同的改变，它们将 IDE 脱离桌面环境运算可以放到服务器或者容器内，基于浏览器的 V8 引擎来对 IDE画面进行渲染，当然值得一提的是现在市面上出现了这么多的网页版 IDE 很大程度上归功于微软的 VS Code 项目，因为它本质上也是一个基于 chromium 浏览器的项目，你只要打开 Help\u0026gt;Toggle Devloper Tools 就能发现 chrome 的 develpoer tools。微软在 github 上有大量的 IDE 相关的开源项目，比如 monaco-editor,这是 VS Code 以及一众在线 IDE 的编辑器组件，其作为一个网页端的文本编辑器其功能已经非常完善了，所以很多 IDE 项目其实可以很大程度上避免重复的工作，尤其是文本编辑器这种需要针对 AST 来做一些彩色渲染高亮等的重复工作。\n我为什么要写一些 IDE 相关的内容 对于大多数人来说，更喜欢一些拿来即用的工具，对于工具好用就行无关其本质以及原理。但对于我个人来说，我会更好奇于事物本身的原理以及机制，拆解一些已经整合好的东西能给我带来一些满足感，或许我有一些结构主义的倾向\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/","section":"docs","title":"Web IDE 开发笔记"},{"body":"","link":"https://misakaJimmy.github.io/docs/frontend/tools/","section":"docs","title":"前端常用工具链"},{"body":"数据库笔记\n","link":"https://misakaJimmy.github.io/docs/database/","section":"docs","title":"DataBase"},{"body":" 延续前一篇“前世今生”的笔记，这篇就专门盯着 Lumino 里最核心的那块：Widget 系统。\n目标不是翻译 API 文档，而是给自己理一套「看源码时脑子里应该有的模型」，顺手放点小 demo，方便之后查阅。\nWidget 在 Lumino 里的角色 在 Lumino 里，Widget 基本可以当成“一切可见 UI 的最小单位”：\n每个 Widget 都对应一个 DOM 元素（默认是 div，也可以自定义）。 Widget 负责自己的一些生命周期：什么时候挂到 DOM 上、什么时候从 DOM 上卸载、什么时候需要重绘。 更高级的组件（面板、停靠布局、TabBar 等）本质上也是 Widget，只是它们更偏“容器”。 所以，从 Theia 的角度看：\nTheia 在做布局时，其实是在安排一堆 Lumino Widget 怎么排队站好；而不是直接操作 DOM。\n一个最小可跑的 Lumino Widget Demo 先看个最小可运行的 Widget 示例，大致感受一下写法：\n1import { Widget } from \u0026#39;@lumino/widgets\u0026#39;; 2 3// 1. 定义一个最简单的 Widget 4class HelloWidget extends Widget { 5 constructor() { 6 super(); 7 this.addClass(\u0026#39;my-HelloWidget\u0026#39;); 8 this.node.textContent = \u0026#39;Hello from Lumino Widget 👋\u0026#39;; 9 } 10} 11 12// 2. 创建实例并挂载到页面 13const widget = new HelloWidget(); 14 15// shell / DockPanel 之类的容器里，通常会有类似的 attach 逻辑 16Widget.attach(widget, document.body); 几个点：\nWidget 自带一个 node 属性，代表它管理的 DOM 元素（默认 div）。 一般不会直接 appendChild 到 document.body，而是交给更高级的 Panel/应用壳来管理；这里为了示例直接挂载。 Widget 的生命周期：attach/detach/resize/update Lumino 给 Widget 设计了一套相对明确的生命周期钩子，这在复杂布局里非常重要。\n典型的几个方法：\nonAfterAttach(msg)：Widget 被插入到 DOM 后触发，适合做首次渲染、事件绑定。 onBeforeDetach(msg)：从 DOM 中移除前触发，可以在这里清理事件、定时器等。 onResize(msg)：容器大小变化时触发，用来响应布局变化。 onUpdateRequest(msg)：需要重新渲染时触发（手动 this.update() 会发起这个请求）。 一个稍微完整一点的例子：\n1import { Widget } from \u0026#39;@lumino/widgets\u0026#39;; 2 3class CounterWidget extends Widget { 4 private _count = 0; 5 6 constructor() { 7 super(); 8 this.addClass(\u0026#39;my-CounterWidget\u0026#39;); 9 } 10 11 // 第一次挂载时渲染 DOM 12 protected onAfterAttach(msg: any): void { 13 this._render(); 14 this.node.addEventListener(\u0026#39;click\u0026#39;, this); 15 } 16 17 // 卸载前清理事件 18 protected onBeforeDetach(msg: any): void { 19 this.node.removeEventListener(\u0026#39;click\u0026#39;, this); 20 } 21 22 // 简单的事件代理 23 handleEvent(event: Event): void { 24 switch (event.type) { 25 case \u0026#39;click\u0026#39;: 26 this._count++; 27 this.update(); // 触发 onUpdateRequest 28 break; 29 } 30 } 31 32 protected onUpdateRequest(msg: any): void { 33 this._render(); 34 } 35 36 private _render() { 37 this.node.textContent = `Clicked: ${this._count}`; 38 } 39} 这段代码有点“手工组件化”的味道：没有引入 React/Vue，而是直接围绕 Widget 生命周期和 update() 来组织逻辑。\n在 Theia 里，很多比较底层的 UI 扩展也是这种风格，只不过被包了一层框架自己的抽象。\nWidget 与容器：Panel / DockPanel / TabBar 的关系 Widget 自己只是一个“砖块”，真正决定布局的是各种“砖墙”——Panel 系列组件：\nPanel：最基础的容器 Widget，可以放一串子 Widget，按一个 layout（例如垂直/水平）来排布。 DockPanel：支持 dock / split / tab 的高级容器，是 IDE 风格布局的核心。 TabBar：显示 tab 页签的组件，通常和 DockPanel 或 TabPanel 一起使用。 粗暴一点的伪代码示意：\n1import { DockPanel, Widget } from \u0026#39;@lumino/widgets\u0026#39;; 2 3const dock = new DockPanel(); 4 5const w1 = new Widget(); 6const w2 = new Widget(); 7const w3 = new Widget(); 8 9w1.node.textContent = \u0026#39;左边的视图\u0026#39;; 10w2.node.textContent = \u0026#39;右上视图\u0026#39;; 11w3.node.textContent = \u0026#39;右下视图\u0026#39;; 12 13dock.addWidget(w1, { mode: \u0026#39;split-left\u0026#39; }); 14dock.addWidget(w2, { mode: \u0026#39;split-right\u0026#39; }); 15dock.addWidget(w3, { ref: w2, mode: \u0026#39;split-bottom\u0026#39; }); 16 17Widget.attach(dock, document.body); Theia 的 shell 其实就是在做类似的事情：\n先有一个包着 DockPanel 的根 Widget，然后把各个视图（文件树、编辑器、终端等）当作 Widget 塞进不同的区域。\nWidget 与信号/命令：更大一层的协作 单个 Widget 只是“会自己长大的一块砖”，真正构成应用的是：\n使用 @lumino/signaling 在 Widget 之间传递状态变化（类似轻量版事件总线）。 使用 @lumino/commands 注册命令，然后在 Widget 里触发或响应这些命令。 一个很常见的模式是：\n1import { CommandRegistry } from \u0026#39;@lumino/commands\u0026#39;; 2 3const commands = new CommandRegistry(); 4 5commands.addCommand(\u0026#39;app:hello\u0026#39;, { 6 label: \u0026#39;Say Hello\u0026#39;, 7 execute: () =\u0026gt; { 8 console.log(\u0026#39;Hello from command!\u0026#39;); 9 }, 10}); 11 12// Widget 里可以通过 commands.execute(\u0026#39;app:hello\u0026#39;) 来触发 在 Theia 里，会有自己一套 command/菜单/快捷键系统，但和 Lumino 的思路高度一致：\n先把行为抽象成命令，再决定从哪儿被触发（菜单、按钮、快捷键、命令面板……）。\n写在最后：为什么先啃 Widget 再看 Theia？ 对我个人的阅读路线来说，先啃 Lumino 的 Widget 系统有几个好处：\n再回头看 Theia 的 shell 和 layout 相关代码时，不会把“应用层逻辑”和“布局框架逻辑”混在一起。 当需要在 Theia 里塞一个自定义视图时，可以更有把握地选： 是做成 React 组件包在一个 Widget 里， 还是直接写一个 Lumino Widget，更贴近底层。 理解 Widget 的生命周期之后，碰到“为什么这个视图 resize 不对劲 / 渲染时机不对”的问题，也有地方可以下手 debug。 后面如果有精力，我可能会专门搞一篇“从一个简单的 Theia 扩展开始，顺藤摸瓜走到 Lumino Widget”的实战笔记，把两边的调用链串起来；这一篇就先当 Widget 层的查阅手册了。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/lumino%E7%9A%84widget%E7%B3%BB%E7%BB%9F/","section":"docs","title":"Lumino 的 Widget 系统：从概念到源码入口"},{"body":"直接官网下载安装，安装时记得记下安装路径。\n根目录如下图所示，bin下是 PostgreSQL 的命令行控制程序，pgAdmin4 下是 PostpreSQL 的可视化管理程序。\n添加 bin 到环境变量之中 记下到 bin 文件夹的绝对路径， 我这里是 D:\\Program Files\\PostgreSQL\\12\\bin ，添加到系统变量和用户变量的 Path 之中。\n然后打开 Terminal ，输入\n1pg_ctl.exe start -D \u0026#34;D:\\Program Files\\PostgreSQL\\12\\data\u0026#34; 然后打开 pgAdmin ， 输入 host 和 Password 。\n角色 \u0026quot;postgres\u0026quot; 不存在 Terminal 中出现角色不存在，导致无法正常连接到postgre服务。\n使用管理员权限打开 Powershell ， 输入\n1 pg_ctl.exe register -N \u0026#34;pgsql\u0026#34; -D \u0026#34;D:\\Program Files\\PostgreSQL\\12\\data\u0026#34; 将 postgresql 注册为服务\n","link":"https://misakaJimmy.github.io/docs/database/postgresql/windows-postgresql-usage/","section":"docs","title":"Windows PostgreSQL 使用"},{"body":"","link":"https://misakaJimmy.github.io/docs/frontend/basic/","section":"docs","title":"前端基础"},{"body":"一个强大又轻量的控制反转容器，提供给JavaScript 和 Node.js 应用使用，使用TypeScript编写。\n简介 nversifyJS 是一个轻量的 (4KB) 控制反转容器 (IoC)，可用于编写 TypeScript 和 JavaScript 应用。 它使用类构造函数去定义和注入它的依赖。InversifyJS API 很友好易懂, 鼓励对 OOP 和 IoC 最佳实践的应用.\n为什么要有 InversifyJS? JavaScript 现在支持面向对象编程，基于类的继承。 这些特性不错但事实上它们也是 危险的。 我们需要一个优秀的面向对象设计（比如 SOLID，Composite Reuse等）来保护我们避免这些威胁。然而，面向对象的设计是复杂的，所以我们创建了 InversifyJS。\nInversifyJS 是一个工具，它能帮助 JavaScript 开发者，写出出色的面向对象设计的代码。\n目标 InversifyJS有4个主要目标:\n允许JavaScript开发人员编写遵循 SOLID 原则的代码。\n促进并鼓励遵守最佳的面向对象编程和依赖注入实践。\n尽可能少的运行时开销。\n提供艺术编程体验和生态。\n为什么要写这篇笔记 最近的项目中大量的运用到了 InversifyJS 所以有一些学习感悟心得想记录一下，本篇笔记大体上是基于 https://doc.inversify.cloud/zh_cn/ 这份中文文档来写的，比起原文档 API 字典式的记录 InversifyJS 的使用方法，本篇笔记更多的是主观的的记录自己的学习心得，以供自己以后回顾以及大家共同学习讨论。\n","link":"https://misakaJimmy.github.io/docs/frontend/inversifyjs/","section":"docs","title":"InversifyJS"},{"body":" 这篇就把 Widget 背后的两条“暗线”单拎出来：signaling 和 messaging。\n一个负责「谁对谁说话」，一个负责「什么时候该说话」，很多看起来“魔法般自动”的行为，其实都是这两套机制在背后运转。\n先分清楚：signaling vs messaging 到底谁管啥？ 我自己的粗暴理解：\nsignaling：更像是“业务层事件/信号系统”，解决的是——\n「A 的状态变了，B 想知道」。 典型场景：模型变化通知视图、多个 Widget 之间同步选中状态等。 messaging：更偏“框架内部的消息循环”，解决的是——\n「这个 Widget 现在应该执行哪个生命周期钩子」。 典型场景：onResize / onUpdateRequest / onAfterAttach 等这些钩子，其实都是通过 messaging 派发进来的。 一句话：\nsignaling 是「业务信号」；messaging 是「UI 框架自己的消息泵和生命周期调度」。\nsignaling：在 Widget / 模型之间传递“我变了”的信号 先看一个 @lumino/signaling 的最小例子，感受一下 API 风格：\n1import { ISignal, Signal } from \u0026#39;@lumino/signaling\u0026#39;; 2 3// 一个简单的模型对象 4class CounterModel { 5 private _value = 0; 6 private _changed = new Signal\u0026lt;CounterModel, number\u0026gt;(this); 7 8 // 对外暴露只读的 signal 9 get changed(): ISignal\u0026lt;CounterModel, number\u0026gt; { 10 return this._changed; 11 } 12 13 get value(): number { 14 return this._value; 15 } 16 17 increment(): void { 18 this._value++; 19 // 发出“我变了”的信号 20 this._changed.emit(this._value); 21 } 22} 23 24// 某个监听它的视图/Widget 25const model = new CounterModel(); 26 27model.changed.connect((sender, value) =\u0026gt; { 28 console.log(\u0026#39;Counter changed:\u0026#39;, sender, value); 29}); 30 31model.increment(); // 控制台会输出 Counter changed: ... 几个细节：\nSignal\u0026lt;Sender, Args\u0026gt; 里的第一个泛型是“信号的发送者类型”，第二个是“携带的数据类型”。 connect 接受一个回调 (sender, args) =\u0026gt; {}，这点跟 Qt 的 signal/slot 有点神似。 Widget 通常不会自己 new 一个 Signal，而是： 要么监听别的对象的信号。 要么在某个“模型对象”里管理 signal，然后 Widget 订阅它。 在 Theia 这种架构里，signaling 非常适合放在「状态/模型」那一层，让 UI 只是订阅并响应，而不是自己维护一堆 EventEmitter。\nsignaling + Widget 的一个组合小例子 再来一个「模型 + Widget」的小组合，接上上一篇的 Widget 思路：\n1import { ISignal, Signal } from \u0026#39;@lumino/signaling\u0026#39;; 2import { Widget } from \u0026#39;@lumino/widgets\u0026#39;; 3 4class CounterModel { 5 private _value = 0; 6 private _changed = new Signal\u0026lt;CounterModel, number\u0026gt;(this); 7 8 get changed(): ISignal\u0026lt;CounterModel, number\u0026gt; { 9 return this._changed; 10 } 11 12 get value(): number { 13 return this._value; 14 } 15 16 increment(): void { 17 this._value++; 18 this._changed.emit(this._value); 19 } 20} 21 22class CounterView extends Widget { 23 constructor(private model: CounterModel) { 24 super(); 25 this.addClass(\u0026#39;my-CounterView\u0026#39;); 26 27 // 订阅模型变化 28 this.model.changed.connect(this.onModelChanged, this); 29 } 30 31 protected onAfterAttach(msg: any): void { 32 this._render(); 33 this.node.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { 34 this.model.increment(); 35 }); 36 } 37 38 private onModelChanged(sender: CounterModel, value: number): void { 39 this._render(); 40 } 41 42 private _render(): void { 43 this.node.textContent = `Clicked: ${this.model.value}`; 44 } 45} 这里可以看到几个小模式：\nWidget 不直接修改自己的“业务状态”，而是通过 model 来改。 Widget 通过 signal.connect 订阅变化，然后在回调里调用 _render()。 从架构味道上讲，这和常见的 MVVM / 状态管理思路是一脉相承的，只是工具换成了 Lumino 的 Signal。 messaging：Widget 生命周期背后那条消息泵 再来看 messaging。大多数时候我们只会在 Widget 里重写这些方法：\nonAfterAttach onBeforeDetach onResize onUpdateRequest …… 但在 Lumino 内部，这些并不是直接「某处手动调用」，而是通过一个消息系统来派发：\n1import { Message, MessageLoop } from \u0026#39;@lumino/messaging\u0026#39;; 2import { Widget } from \u0026#39;@lumino/widgets\u0026#39;; 3 4class MyWidget extends Widget { 5 protected onUpdateRequest(msg: Message): void { 6 console.log(\u0026#39;update request:\u0026#39;, msg); 7 } 8} 9 10const w = new MyWidget(); 11 12// 手动触发一次 update 消息 13MessageLoop.sendMessage(w, Widget.Msg.UpdateRequest); MessageLoop.sendMessage 会把一条消息送进 Widget 的处理流程里，最终调用到 onUpdateRequest。\n在正常使用 DockPanel / Layout 的时候，这一切都是框架帮你调度好的，你只要实现对应的钩子函数就行。\n还有几个配套概念：\nWidget.Msg.UpdateRequest / ResizeRequest / AfterAttach 等是一些内置消息常量。 MessageLoop.postMessage 则是异步排队发送，在下一轮消息循环里处理，避免同步调用导致递归问题。 可以理解为：messaging 是让 Widget 的生命周期更像“消息驱动”的，而不是直接函数调用。\nsignaling + messaging 在实际阅读代码时的用法区别 我自己在看 Theia / Lumino 源码时，通常会这样区分两条线：\n看到 Signal / .connect() / .emit()： 把它当成“业务事件”，去想「谁在产生这个状态变化」「谁在消费它」。 这部分逻辑通常跟 UI 框架解耦，迁移到别的 UI 技术栈也可以重用。 看到 onXXXRequest / MessageLoop / Widget.Msg.*： 把它当成“UI 框架调度”，去想「这个 Widget 在什么时机会收到这些消息」。 这部分逻辑高度绑定 Lumino 的布局和渲染机制。 在调试问题时也很有用：\n如果是「状态没同步过去」→ 大概率看 signaling 的连接和 emit。 如果是「界面渲染/尺寸不对」→ 大概率看 messaging 对 onResize / onUpdateRequest 是否按预期触发。 小结：为什么我愿意为这俩单独写一篇？ 对我个人来说，signaling 和 messaging 有点像 Lumino 这套体系里的“底噪”：\n不刻意关注的时候，你只会看到 Widget、Panel、DockPanel 这些“可视”的部分。 但真想在 Theia 里写点更贴近底层的扩展，或者想搞明白一些诡异的刷新/状态问题时，最后都会顺藤摸瓜摸到这两块。 写这一篇，更像是给自己立一个“心智坐标系”：\n以后看到 Signal / MessageLoop 相关的调用时，脑子里能立刻知道——\n这是在搭“谁对谁说话”的桥，还是在调度“什么时候说话”的节奏。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/lumino%E7%9A%84signaling%E5%92%8Cmessaging%E7%B3%BB%E7%BB%9F/","section":"docs","title":"Lumino 的 signaling 和 messaging：状态与生命周期的底噪"},{"body":"","link":"https://misakaJimmy.github.io/docs/database/postgresql/","section":"docs","title":"PostgreSQL"},{"body":" 前面两篇分别把 Widget 本身和 signaling/messaging 这两条“底噪”线理了一遍，这篇就顺着往上走一层：\nDockPanel / SplitPanel / TabBar 这一整套布局 Widget，怎么在页面上拼出一个 IDE 风格的桌面感布局。\n布局的基本思路：一堆容器 Widget 叠罗汉 用一句话先概括 Lumino 的布局观：\n普通 Widget：负责“内容”。 各种 Panel / Bar：负责“怎么把这些内容排布在一个二维平面上”。 典型的几类：\nPanel：最基础的容器，内部可以挂多个子 Widget。 BoxPanel / SplitPanel：负责水平/垂直方向的分割和拉伸。 TabBar + TabPanel：提供多标签切换的 UI。 DockPanel：把分屏 + 停靠 + Tab 组合在一起，是 IDE 布局的核心。 在 Theia 这类 IDE 里面，最外层的 Shell 一般会持有一个根 DockPanel，然后根据区域（left/right/bottom/main）往里面塞不同 Widget。\nSplitPanel：最基础的“可拖动分隔条” 先从相对简单的 SplitPanel 说起，它提供了一条可以拖动的分隔线，把空间按比例切给多个子 Widget。\n1import { SplitPanel, Widget } from \u0026#39;@lumino/widgets\u0026#39;; 2 3// 创建几个简单的内容 Widget 4function createContent(label: string, color: string): Widget { 5 const w = new Widget(); 6 w.addClass(\u0026#39;my-SplitPanel-Item\u0026#39;); 7 w.node.textContent = label; 8 w.node.style.background = color; 9 return w; 10} 11 12const left = createContent(\u0026#39;Left Pane\u0026#39;, \u0026#39;#f5d0c5\u0026#39;); 13const right = createContent(\u0026#39;Right Pane\u0026#39;, \u0026#39;#c5d0f5\u0026#39;); 14 15// 创建一个水平 SplitPanel 16const split = new SplitPanel({ orientation: \u0026#39;horizontal\u0026#39; }); 17split.addWidget(left); 18split.addWidget(right); 19 20SplitPanel.setStretch(left, 1); // 左右各 1 份 21SplitPanel.setStretch(right, 1); 22 23Widget.attach(split, document.body); 几个要点：\norientation 决定分割方向：'horizontal' 或 'vertical'。 setStretch 可以简单控制每个子 Widget 占多大比例。 用户拖动中间的分隔条时，内部会通过 messaging 触发子 Widget 的 onResize，从而驱动重绘。 在 IDE 里，SplitPanel 更像是很底层的一块积木，DockPanel 其实就是在更复杂的场景下组合和管理这些分裂出来的区域。\nTabBar / TabPanel：一组 Widget 共用一个“框”，靠 Tab 切换 第二块积木是 Tab，一组 Widget 共享一个可见区域，通过标签切换：\n1import { TabPanel, Widget } from \u0026#39;@lumino/widgets\u0026#39;; 2 3function createTab(label: string): Widget { 4 const w = new Widget(); 5 w.addClass(\u0026#39;my-TabPanel-Item\u0026#39;); 6 w.node.textContent = label; 7 return w; 8} 9 10const panel = new TabPanel(); 11panel.addWidget(createTab(\u0026#39;Tab A\u0026#39;)); 12panel.addWidget(createTab(\u0026#39;Tab B\u0026#39;)); 13panel.addWidget(createTab(\u0026#39;Tab C\u0026#39;)); 14 15Widget.attach(panel, document.body); 16panel.currentIndex = 0; // 默认选中第一个 这里 TabPanel 内部会管理一个 TabBar，以及与之对应的内容区域：\nTabBar 负责上面那一排可点击的标签。 内容区域负责展示当前激活的那个 Widget。 在 IDE 布局里，这个模式最典型的应用就是“一个编辑区里打开多个文件”的场景：每个编辑器是一个 Widget，中间那排文件名就是 TabBar。\nDockPanel：把 Split + Tab 全打包了 真正让布局变得“桌面感爆表”的是 DockPanel：它把分屏（split）、停靠（dock）和 Tab 三种能力揉到了一起。\n一个最小可感受效果的例子：\n1import { DockPanel, Widget } from \u0026#39;@lumino/widgets\u0026#39;; 2 3function createDockWidget(label: string, color: string): Widget { 4 const w = new Widget(); 5 w.addClass(\u0026#39;my-DockPanel-Item\u0026#39;); 6 w.node.textContent = label; 7 w.node.style.background = color; 8 return w; 9} 10 11const dock = new DockPanel(); 12 13const w1 = createDockWidget(\u0026#39;Main\u0026#39;, \u0026#39;#fef3c7\u0026#39;); 14const w2 = createDockWidget(\u0026#39;Right-Top\u0026#39;, \u0026#39;#e0f2fe\u0026#39;); 15const w3 = createDockWidget(\u0026#39;Right-Bottom\u0026#39;, \u0026#39;#dcfce7\u0026#39;); 16 17// 第一个 Widget 作为初始内容 18dock.addWidget(w1); 19 20// 在右侧拆出一个区域 21dock.addWidget(w2, { mode: \u0026#39;split-right\u0026#39;, ref: w1 }); 22 23// 在右侧区域再次向下拆分 24dock.addWidget(w3, { mode: \u0026#39;split-bottom\u0026#39;, ref: w2 }); 25 26Widget.attach(dock, document.body); 这里的关键是第二个参数 options：\nmode 决定“怎么插入”： 'split-right' / 'split-left' / 'split-top' / 'split-bottom'：在对应方向拆出一个新区域。 'tab-after' / 'tab-before'：在同一区域新建一个 Tab。 ref 指定一个“参考 Widget”，表示你要相对谁进行拆分/停靠。 在 Theia 里，当你从视图菜单里打开某个面板（比如 Outline / Problems），或者把终端拖到底部区域时，背后基本都是对 DockPanel.addWidget 的各种组合调用。\n布局数据的持久化和恢复（IDE 必备套路） IDE 类应用一个很常见的需求是：记住用户怎么折腾布局的，下次打开时还原。\nLumino 为此提供了布局序列化的能力——可以把当前 DockPanel 的结构 dump 成一个 JSON，然后再 restore 回来。\n概念上大概是这样（简化伪代码）：\n1import { DockPanel } from \u0026#39;@lumino/widgets\u0026#39;; 2 3const dock = new DockPanel(); 4 5// ... 中间用户各种拖拽、拆分、合并 ... 6 7// 1. 导出布局（可以存到 localStorage 或服务器） 8const layout = dock.saveLayout(); 9localStorage.setItem(\u0026#39;layout\u0026#39;, JSON.stringify(layout)); 10 11// 2. 重新创建 DockPanel 时恢复布局 12const saved = localStorage.getItem(\u0026#39;layout\u0026#39;); 13if (saved) { 14 const layoutObj = JSON.parse(saved); 15 dock.restoreLayout(layoutObj); 16} Theia 自己在应用层还会加一层封装：\n不只是还原「长得怎样」，还要确保对应的 Widget 能重新创建出来并填充到正确位置，这里就会涉及到 ViewRegistry / WidgetFactory 之类的机制——这一块更偏 Theia 自身架构，可以等讲到 Theia Shell 时再展开。\n这些布局 Widget 在 Theia 里的大致落位 结合前两篇，再把这几个 Widget 放回 Theia 的语境里看一下（简化心智模型）：\nLumino 的 Widget / DockPanel / TabBar / SplitPanel： 负责“物理布局”和“窗口行为”——桌面感的来源。 Theia 更多是作为“使用者”和“组织者”，去告诉 Lumino 怎么摆这些砖。 Theia 自己的 Shell / View / Contribution 层： 决定“有哪些区域”“每个区域里塞什么 Widget”“这些视图怎么注册/销毁/还原”。 在合适的时机调用 dock.addWidget / restoreLayout 等接口。 所以在读 Theia 代码的时候，我的习惯是：\n一旦看到涉及“main/left/right/bottom area 布局”的地方，就自动联想到背后一定有 Lumino 的 DockPanel 在运作。 遇到拖拽 / 合并 / 分屏相关逻辑时，会先在 Lumino 这几个布局 Widget 里找“底层行为”，再看 Theia 是怎么在上层包一层自己的抽象的。 小结：把这几块积木认清楚，再看 IDE 布局就不那么迷幻了 从 Widget -\u0026gt; signaling/messaging -\u0026gt; 布局 Widget（DockPanel / SplitPanel / TabBar）这一串看下来，大概可以得到一个还算清晰的图景：\nWidget：长什么样、放什么内容。 signaling / messaging：内部怎么“说话”和“按节奏动起来”。 DockPanel / SplitPanel / TabBar：这些砖最后怎么拼成一个能分屏、能拖拽、能记住布局的桌面感 UI。 对我来说，把这几块单独拎出来写一篇，是为了以后再遇到奇怪的布局问题（比如：某个视图拖不对地方 / 重启之后布局错乱），脑子里能快速定位：\n到底是 Theia 应用层的“视图注册/还原”出了问题，还是 Lumino 那边的布局行为需要再去翻一遍源码。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/lumino%E7%9A%84%E5%B8%83%E5%B1%80%E7%B3%BB%E7%BB%9F_dockpanel_splitpanel_tabbar/","section":"docs","title":"Lumino 的布局系统：DockPanel / SplitPanel / TabBar 一条龙"},{"body":" 前面几篇更多在讲“长什么样”（Widget / 布局）和“怎么动起来”（signaling / messaging），\n这篇换个角度，讲讲 Lumino 里另一条很关键的线：command 系统——也就是“把行为抽象成命令，再让各种入口去触发它”。\n先理解一下：为什么需要 command 系统？ 在 IDE 这种应用里，很多操作其实是同一个行为被不同入口复用，比如：\n“保存文件” 可以来自菜单、快捷键、命令面板、右键菜单、工具栏按钮…… “关闭当前标签” 既可以点击 Tab 上的小叉，也可以用快捷键，或者命令面板。 如果每个入口都自己绑一份逻辑，很快就会变成维护噩梦。\ncommand 系统做的事情就是：\n先用一个 全局唯一的 id 定义一个命令（以及它的 label、是否可用等信息）。 再在需要的地方“挂上入口”：菜单项、按钮、快捷键、命令面板…… 这样改行为只改命令本身，所有入口自然同步更新。\nCommandRegistry：命令的集中注册中心 Lumino 的命令系统核心是 CommandRegistry，看一个最小例子：\n1import { CommandRegistry } from \u0026#39;@lumino/commands\u0026#39;; 2 3const commands = new CommandRegistry(); 4 5// 1. 注册一个最简单的命令 6commands.addCommand(\u0026#39;app:hello\u0026#39;, { 7 label: \u0026#39;Say Hello\u0026#39;, 8 caption: \u0026#39;Print a hello message to console\u0026#39;, 9 isEnabled: () =\u0026gt; true, 10 execute: () =\u0026gt; { 11 console.log(\u0026#39;Hello from command!\u0026#39;); 12 }, 13}); 14 15// 2. 代码里任意地方都可以通过 id 来执行这个命令 16commands.execute(\u0026#39;app:hello\u0026#39;); 几个点：\n命令 id 一般用 'namespace:action' 这种风格，方便在大项目里避免冲突。 label 是展示在菜单 / 命令面板等 UI 上的文字。 isEnabled / isVisible / isToggled 可以用来控制命令当前是否可用、是否显示、是否处于“选中状态”，这在 IDE 里很常见。 从 Theia 的角度看，其实也有一套自己的 CommandRegistry / CommandContribution，设计思路和 Lumino 非常像，只是集成更深入到整个框架里。\n命令与快捷键：addKeyBinding、键盘处理与 FocusTracker 有了命令之后，下一件事情就是给它配快捷键，并且让这些快捷键只在“对的地方”生效。\n在 Lumino 里，命令和快捷键仍然由 CommandRegistry 负责，底下则依赖 @lumino/keyboard 和 FocusTracker 来协调：\n1import { CommandRegistry } from \u0026#39;@lumino/commands\u0026#39;; 2 3const commands = new CommandRegistry(); 4 5commands.addCommand(\u0026#39;file:save\u0026#39;, { 6 label: \u0026#39;Save File\u0026#39;, 7 execute: () =\u0026gt; { 8 console.log(\u0026#39;Saving file...\u0026#39;); 9 }, 10}); 11 12commands.addKeyBinding({ 13 keys: [\u0026#39;Accel S\u0026#39;], // Accel = Ctrl (Windows/Linux) or Cmd (macOS) 14 selector: \u0026#39;body\u0026#39;, 15 command: \u0026#39;file:save\u0026#39;, 16}); 要点：\nkeys 使用的是一种类似 VS Code 的按键描述：['Accel S'] / ['Ctrl Shift P'] / ['Alt Enter'] 等。 selector 是一个 CSS 选择器，表示当前事件发生在哪个元素上时，这个快捷键才生效。 例如只在某个容器内生效，可以用 '#editor' 等。 在底层，Lumino 会结合 @lumino/keyboard 对原生键盘事件做一些规范化处理（比如统一不同平台的修饰键表示），\n同时配合 FocusTracker 跟踪“当前活动 Widget”，从而决定哪些 keybinding 应该响应、哪些应该忽略。\n一个简化后的心智模型是：\nCommandRegistry 维护了一张「按键组合 → 命令 id」的映射表（加上 selector 过滤）。 键盘事件进来后先被标准化，再根据事件发生位置和当前 focus，去匹配对应的 keybinding； 一旦匹配成功，就回到 command 系统，执行那条命令。 Theia 在自己的命令/快捷键系统里也有类似概念：\n先定义命令，再绑定快捷键，UI 的各个部分只是“使用者”，不会直接关心行为细节；\n而哪个视图当前“有焦点”，由 FocusTracker 之类的机制来决定。\n命令与菜单/按钮：不同入口复用同一段逻辑 在 Widget 里你可以直接调用 commands.execute('id')，\n如果要做一个“命令按钮”，可以这么写一个小辅助 Widget（示意）：\n1import { CommandRegistry } from \u0026#39;@lumino/commands\u0026#39;; 2import { Widget } from \u0026#39;@lumino/widgets\u0026#39;; 3 4class CommandButton extends Widget { 5 constructor( 6 private commands: CommandRegistry, 7 private commandId: string 8 ) { 9 super({ node: document.createElement(\u0026#39;button\u0026#39;) }); 10 this.addClass(\u0026#39;my-CommandButton\u0026#39;); 11 } 12 13 protected onAfterAttach(msg: any): void { 14 this._render(); 15 this.node.addEventListener(\u0026#39;click\u0026#39;, this); 16 } 17 18 protected onBeforeDetach(msg: any): void { 19 this.node.removeEventListener(\u0026#39;click\u0026#39;, this); 20 } 21 22 handleEvent(event: Event): void { 23 if (event.type === \u0026#39;click\u0026#39;) { 24 void this.commands.execute(this.commandId); 25 } 26 } 27 28 private _render(): void { 29 const cmd = this.commands.listCommands().find(id =\u0026gt; id === this.commandId); 30 const label = this.commands.label(this.commandId) ?? this.commandId; 31 (this.node as HTMLButtonElement).textContent = label; 32 (this.node as HTMLButtonElement).disabled = !this.commands.isEnabled(this.commandId); 33 } 34} 这个例子有点简化，但表达了一个重要事实：\n按钮只是命令的一个“皮肤”，它关心的是：现在要显示什么文字、是否可点、点了之后执行哪个命令。\n菜单项同理，只不过一般会有一个菜单系统来批量把命令挂成 MenuItem。\n命令参数与上下文：不只是“开关”动作 命令系统真正好用的地方在于它不是只能做“无参动作”，而是可以携带参数与上下文：\n1commands.addCommand(\u0026#39;editor:close-file\u0026#39;, { 2 label: \u0026#39;Close File\u0026#39;, 3 execute: (args: { uri: string }) =\u0026gt; { 4 console.log(\u0026#39;Closing file:\u0026#39;, args.uri); 5 }, 6}); 7 8// 从不同地方用不同参数执行 9commands.execute(\u0026#39;editor:close-file\u0026#39;, { uri: \u0026#39;/path/to/a.ts\u0026#39; }); 10commands.execute(\u0026#39;editor:close-file\u0026#39;, { uri: \u0026#39;/path/to/b.ts\u0026#39; }); 在 IDE 里，很常见的模式是：\n命令本身只负责“干什么”。 谁来触发、用什么参数触发，由具体入口（当前选中的标签、右键菜单里的目标对象、命令面板里的上下文等）来决定。 Theia 在自己的 Command API 里也有类似的 executeCommand(id, ...args) 签名——这一层几乎可以一一对应到 Lumino 的命令设计上。\n在 Theia / Lumino 源码里看 command 的一些观察点 我个人在翻 Theia + Lumino 相关代码时，通常会刻意关注这些地方：\n命令 id 的命名空间： 不同模块一般会有自己的前缀，比如 file:*、editor:*、view:* 等，读起来更有方向感。 命令注册集中在哪儿： Theia 里通常有类似 CommandContribution 的地方集中注册命令。 Lumino 里则是你自己 new 一个 CommandRegistry，然后在初始化阶段把命令都挂上去。 快捷键和菜单是怎么“消费”这些命令的： 对着命令 id 往回找，可以很快看到有哪些入口会触发这条命令。 一旦搞清楚这条线，很多“这个按钮到底做了什么”“这个快捷键为什么不生效”的问题，就有比较清晰的排查路径了。\n小结：command 系统 = 行为的“中枢神经” 把前几篇加上这一篇连起来看，大概可以得到这样一幅图：\nWidget / 布局系统：决定“界面长什么样、东西摆在哪儿”。 signaling / messaging：决定“状态和生命周期怎么流动”。 command 系统：把具体“要做什么”从 UI 入口里抽出来，集中管理、复用和编排。 对我来说，理解 Lumino 的 command 系统最大的收益是：\n再看 Theia 的命令/菜单/快捷键那一坨代码时，脑子里有了一个更底层、更简洁的模型可以对照，知道哪些是框架通用模式，哪些才是 Theia 自己加的业务抽象。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/lumino%E7%9A%84command%E7%B3%BB%E7%BB%9F/","section":"docs","title":"Lumino 的 command 系统：把行为从按钮里解放出来"},{"body":" 前面几篇更多是把一块块“砖”（Widget、布局、command 等）单独拎出来看，\n这篇换个视角：把这些东西装进一个完整的 Lumino 应用里，顺带看看菜单栏、工具栏、右键菜单这些常见 UI 是怎么围绕 command 系统一起工作的。\n@lumino/application：把零散的能力装进一个 App 如果只用 @lumino/widgets，你完全可以手动 new 一个 DockPanel / BoxPanel，往里塞 Widget，然后挂到 document.body 上。\n但一旦你想要：\n全局的 CommandRegistry 和快捷键处理 顶部菜单栏（MenuBar） 右键菜单（ContextMenu） 工具栏、命令面板之类的“全局 UI” 就会发现需要一个更高级的“应用骨架”来帮你把这些拼在一起，这就是 @lumino/application 要做的事情。\n它的核心概念通常包括：\nApplication：整个 Lumino 应用的入口，负责启动、挂载、管理命令等。 Shell：应用的外壳，内部才是我们熟悉的布局（通常会内嵌一个 DockPanel 等）。 在 Theia 里你也能看到类似的影子：\n有一个 Application / FrontendApplication 的东西启动整套系统，然后有 ApplicationShell 作为 UI 壳。\n一个极简 Lumino Application 骨架 很多示例会这么写一个最小壳（伪代码略简化，只看结构）：\n1import { CommandRegistry } from \u0026#39;@lumino/commands\u0026#39;; 2import { DockPanel, Widget } from \u0026#39;@lumino/widgets\u0026#39;; 3import { Application } from \u0026#39;@lumino/application\u0026#39;; 4 5// 1. 定义一个简单的 Shell（内部有一个 DockPanel） 6class SimpleShell extends Widget { 7 readonly dock: DockPanel; 8 9 constructor() { 10 super(); 11 this.addClass(\u0026#39;my-SimpleShell\u0026#39;); 12 13 this.dock = new DockPanel(); 14 this.dock.id = \u0026#39;main-dock\u0026#39;; 15 16 // 把 dock 的 DOM 挂到 shell 的 node 上 17 this.node.appendChild(this.dock.node); 18 } 19} 20 21// 2. 定义 Application，指定 Shell 和 CommandRegistry 22class SimpleApplication extends Application\u0026lt;SimpleShell\u0026gt; { 23 constructor(options: Application.IOptions\u0026lt;SimpleShell\u0026gt;) { 24 super(options); 25 } 26} 27 28// 3. 启动应用 29const commands = new CommandRegistry(); 30const shell = new SimpleShell(); 31 32const app = new SimpleApplication({ 33 shell, 34 commands, 35}); 36 37window.addEventListener(\u0026#39;load\u0026#39;, () =\u0026gt; { 38 app.start(); // 挂载并启动整个应用 39}); 这里很多细节可以展开讲，但对我们来说，先记住两点就够了：\nApplication 负责 glue code：把命令、快捷键、菜单、shell 这些能力粘在一起。 Shell 负责布局容器：内部才是 DockPanel / SplitPanel / TabBar 等。 接下来就可以往这个骨架上挂菜单栏、工具栏、右键菜单了。\n菜单栏：Menu + MenuBar 菜单栏是 Lumino 里和 command 系统结合得最紧的一块 UI。\n基本思路是：\n用 Menu 代表一个下拉菜单（比如「文件」「编辑」）。 把这些 Menu 挂到 MenuBar 上。 每个菜单项对应一个命令 id。 一个简化示例：\n1import { CommandRegistry } from \u0026#39;@lumino/commands\u0026#39;; 2import { Menu, MenuBar } from \u0026#39;@lumino/widgets\u0026#39;; 3 4const commands = new CommandRegistry(); 5 6commands.addCommand(\u0026#39;file:new\u0026#39;, { 7 label: \u0026#39;New File\u0026#39;, 8 execute: () =\u0026gt; { 9 console.log(\u0026#39;New file\u0026#39;); 10 }, 11}); 12 13commands.addCommand(\u0026#39;file:open\u0026#39;, { 14 label: \u0026#39;Open File\u0026#39;, 15 execute: () =\u0026gt; { 16 console.log(\u0026#39;Open file\u0026#39;); 17 }, 18}); 19 20// 创建一个“文件”菜单 21const fileMenu = new Menu({ commands }); 22fileMenu.title.label = \u0026#39;File\u0026#39;; 23fileMenu.addItem({ command: \u0026#39;file:new\u0026#39; }); 24fileMenu.addItem({ command: \u0026#39;file:open\u0026#39; }); 25 26// 创建菜单栏并挂上去 27const menuBar = new MenuBar(); 28menuBar.addMenu(fileMenu); 29 30document.body.appendChild(menuBar.node); 要点：\nMenu 和 MenuBar 都依赖一个 CommandRegistry 实例，通过 command id 来渲染菜单项的 label / enabled 状态等。 一旦命令的 label/isEnabled 逻辑变了，菜单 UI 会自动跟着更新。 在 Theia 里，菜单栏同样是围绕 command 系统构建的，只不过多了层 MenuContribution / 配置化的菜单树；但底层这条“命令驱动菜单项”的思路是一致的。\n右键菜单：ContextMenu 右键菜单的使用体验和菜单栏类似，但触发方式是基于鼠标事件 + DOM 选择器。\nLumino 提供了一个 ContextMenu 帮你管理：\n1import { CommandRegistry } from \u0026#39;@lumino/commands\u0026#39;; 2import { ContextMenu } from \u0026#39;@lumino/widgets\u0026#39;; 3 4const commands = new CommandRegistry(); 5 6commands.addCommand(\u0026#39;editor:copy\u0026#39;, { 7 label: \u0026#39;Copy\u0026#39;, 8 execute: () =\u0026gt; { 9 console.log(\u0026#39;Copy!\u0026#39;); 10 }, 11}); 12 13const contextMenu = new ContextMenu({ commands }); 14 15// 针对特定区域注册右键菜单项 16contextMenu.addItem({ 17 command: \u0026#39;editor:copy\u0026#39;, 18 selector: \u0026#39;.my-Editor\u0026#39;, 19 rank: 1, 20}); 21 22// 全局监听 contextmenu 事件 23window.addEventListener(\u0026#39;contextmenu\u0026#39;, event =\u0026gt; { 24 contextMenu.open(event); 25}); 这里的关键点有两个：\nselector 决定了“在哪些 DOM 元素上右键，才会显示这条菜单项”。 ContextMenu 内部同样是通过 command id 去取 label / isEnabled / execute。 从 Theia 的视角看，右键菜单也是类似的套路：\n不同 view/contribution 注册自己的上下文菜单项，最终映射到同一个命令系统上。\n工具栏：一组“命令按钮”的容器 Lumino 没有强制你必须用某种 Toolbar 类型，你可以：\n直接用某个 Panel / Widget 当作工具栏容器； 在里面放一堆“命令按钮”——比如前面那篇 command 文里示意的 CommandButton Widget。 一个非常简化的伪代码例子：\n1import { CommandRegistry } from \u0026#39;@lumino/commands\u0026#39;; 2import { Panel, Widget } from \u0026#39;@lumino/widgets\u0026#39;; 3 4class CommandButton extends Widget { 5 constructor( 6 private commands: CommandRegistry, 7 private commandId: string 8 ) { 9 super({ node: document.createElement(\u0026#39;button\u0026#39;) }); 10 this.addClass(\u0026#39;my-CommandButton\u0026#39;); 11 } 12 13 protected onAfterAttach(msg: any): void { 14 this._render(); 15 this.node.addEventListener(\u0026#39;click\u0026#39;, this); 16 } 17 18 protected onBeforeDetach(msg: any): void { 19 this.node.removeEventListener(\u0026#39;click\u0026#39;, this); 20 } 21 22 handleEvent(event: Event): void { 23 if (event.type === \u0026#39;click\u0026#39;) { 24 void this.commands.execute(this.commandId); 25 } 26 } 27 28 private _render(): void { 29 const label = this.commands.label(this.commandId) ?? this.commandId; 30 (this.node as HTMLButtonElement).textContent = label; 31 (this.node as HTMLButtonElement).disabled = !this.commands.isEnabled(this.commandId); 32 } 33} 34 35// 工具栏容器 36const toolbar = new Panel(); 37toolbar.id = \u0026#39;main-toolbar\u0026#39;; 38 39toolbar.addWidget(new CommandButton(commands, \u0026#39;file:new\u0026#39;)); 40toolbar.addWidget(new CommandButton(commands, \u0026#39;file:open\u0026#39;)); 本质上，工具栏只是“水平摆了一排命令按钮的 Panel”，\n真正的行为还是集中在 command 系统里。\n在 Theia 中你也会看到各种 View/Editor 的 toolbar，本质上也是给某一组命令提供一块更显眼的入口区域。\n把这些拼回 Application 视角 如果把前面的东西都装回 Application 里，一个简化的心智模型大概是这样：\nApplication 创建并持有： 一个 CommandRegistry（命令与快捷键）。 一个 Shell（里面是 DockPanel 等布局）。 一个 MenuBar + 一个 ContextMenu + 若干工具栏 Widget。 Shell 负责给布局和各种视图（Widget）腾位置。 菜单栏 / 右键菜单 / 工具栏，仅仅是围绕 CommandRegistry 渲染 UI 的不同外壳。 Theia 则在这个基础上又往上盖了一层：\n有自己的 CommandContribution / MenuContribution 接口，让扩展可以注册命令和菜单，而不用直接操作 Lumino 的 API。 有抽象出来的 ApplicationShell，把 Lumino Shell 的细节再包一层，让 IDE 级的需求（多语言支持、view/container 抽象等）更好处理。 小结：Application + 菜单体系 = 把“命令世界”塞进一个真正的 App 到这篇为止，跟 Lumino 相关的几条主干大概就比较齐了：\nWidget / 布局系统：东西长什么样，摆在哪儿。 signaling / messaging：状态和生命周期的流动。 command 系统：行为的抽象与复用。 Application + 菜单 / 工具栏 / 右键菜单：把这些能力装进一个“完整应用壳”里。 对我来说，理解 @lumino/application 这一层最大的好处是：\n再看 Theia 的启动流程和 Shell 代码时，不会把“IDE 自己的那一层”与“Lumino 提供的通用骨架”混在一起，看见 Application/Shell/Menu/Command 这些词汇，脑子里都有一个明确的 Lumino 版本可以对照。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/lumino%E7%9A%84%E5%BA%94%E7%94%A8%E9%AA%A8%E6%9E%B6_application%E4%B8%8E%E8%8F%9C%E5%8D%95%E5%B7%A5%E5%85%B7%E6%A0%8F%E7%B3%BB%E7%BB%9F/","section":"docs","title":"Lumino 的应用骨架：Application + 菜单 / 工具栏 / 右键菜单"},{"body":" 前几篇基本都站在“Lumino 自己的一亩三分地”里看，这篇稍微往外看一步：\nLumino 的 @lumino/virtualdom 是什么东西，它和 React/Vue 这种主流框架的 VDOM 有什么不一样，以及如果项目里已经用了 React/Vue，要怎么和 Lumino 玩到一起。\n@lumino/virtualdom 是什么？ 官方的定位很简单：一个极轻量的 Virtual DOM 实现，主要服务于 Lumino 自己的 Widget 体系。\n使用方式大致是：\n用 h() 函数描述一棵虚拟节点树； 调用 VirtualDOM.render() 把这棵树“打补丁”到某个真实 DOM 节点下； Lumino 内部的一些 Widget（比如菜单、命令面板等）都是用这套 VDOM 来写渲染逻辑的。 一个最小例子（只看基本感受）：\n1import { h, VirtualDOM } from \u0026#39;@lumino/virtualdom\u0026#39;; 2 3const vnode = h.div( 4 { className: \u0026#39;my-box\u0026#39; }, 5 h.h1(\u0026#39;Hello Lumino virtualdom\u0026#39;), 6 h.p(\u0026#39;This is a simple paragraph.\u0026#39;), 7); 8 9// 把虚拟节点渲染到某个容器里 10const host = document.getElementById(\u0026#39;app\u0026#39;)!; 11VirtualDOM.render(vnode, host); 特点很明显：\nAPI 风格有点像 React 的 createElement，但借助 h.tagName() 简化了一些。 不搞组件生命周期、状态管理、hook 之类的大系统，只负责“描述一棵树，然后高效地 patch 到 DOM 上”。 和 React/Vue 的对比：它刻意“不长大”的地方 我自己的理解是：Lumino 的 virtualdom 更像是“给框架内部组件用的工具库”，而不是一个完整的 UI 框架。\n对比 React/Vue，一些明显的差异：\n无组件状态/生命周期抽象\nReact 有 setState / hooks、类组件生命周期； Vue 有响应式数据系统、watch、computed 等； Lumino virtualdom 完全不管“数据从哪来、什么时候更新”，它只管接收一棵 VNode 树，然后渲染/更新。 无路由 / 全家桶生态\nReact/Vue 的生态里会自然长出 Router、Store（Redux/Vuex/Pinia）、Form 等各种东西； Lumino virtualdom 刻意保持“只做 VDOM 打补丁”的小工具姿态——状态、路由、数据流全交给外面的世界（比如 Widget / 应用）。 和 Lumino Widget 深度绑定，而不是面向浏览器全局\n在很多 Lumino Widget 里，渲染代码是 VirtualDOM.render(this.render(), this.node) 这样的调用； 即：Widget 负责生命周期和状态，virtualdom 只是帮它把 “render() 返回的描述” 变成 DOM。 从阅读源码的角度看，这种设计有一个好处：\n你在 Widget 里还是用 imperative（命令式）逻辑管理状态、调用 update()，只是把 DOM 细节交给 VDOM 去算 diff。\n在 Widget 里使用 virtualdom：一个完整小例子 结合前面 Widget 的生命周期，可以写一个“小型 React 风味”的 Widget：\n1import { Widget } from \u0026#39;@lumino/widgets\u0026#39;; 2import { h, VirtualDOM } from \u0026#39;@lumino/virtualdom\u0026#39;; 3 4class CounterWidget extends Widget { 5 private _count = 0; 6 7 constructor() { 8 super(); 9 this.addClass(\u0026#39;my-VdomCounter\u0026#39;); 10 } 11 12 protected onAfterAttach(msg: any): void { 13 this._render(); 14 this.node.addEventListener(\u0026#39;click\u0026#39;, this); 15 } 16 17 protected onBeforeDetach(msg: any): void { 18 this.node.removeEventListener(\u0026#39;click\u0026#39;, this); 19 } 20 21 handleEvent(event: Event): void { 22 if (event.type === \u0026#39;click\u0026#39;) { 23 this._count++; 24 this.update(); // 会触发 onUpdateRequest 25 } 26 } 27 28 protected onUpdateRequest(msg: any): void { 29 this._render(); 30 } 31 32 private _render(): void { 33 const vnode = h.div( 34 { className: \u0026#39;counter-root\u0026#39; }, 35 h.h1(`Count: ${this._count}`), 36 h.p(\u0026#39;点击任意位置增加计数\u0026#39;), 37 ); 38 39 VirtualDOM.render(vnode, this.node); 40 } 41} 这里你可以看到：\n没有 React 的 useState / setState，状态就是类字段 _count。 更新时手动调用 this.update()，然后在 onUpdateRequest 里重新走一遍 _render()。 _render() 里完全用 VDOM 来描述 DOM 结构，VirtualDOM 负责做 diff + patch。 这对于已经习惯 React/Vue 的人来说，既有点熟悉，又保留了 Lumino 自己的“Widget 主导一切”的感觉。\n如果工程里已经有 React/Vue，要怎么和 Lumino 配合？ 现实世界里更常见的情况是：项目主 UI 框架已经是 React/Vue，但希望用 Theia/Lumino 提供的 IDE 壳能力，或者反过来在 Lumino/Theia 里嵌入一块 React/Vue 视图。\n我目前比较认可的几种组合方式：\n1. Lumino 作为“外壳”，React/Vue 作为内部视图 思路：\n用 Lumino 的 Widget / DockPanel / command / 菜单等搭出外壳； 写一个“桥接 Widget”，在它的 DOM 节点内挂载 React/Vue 组件。 伪代码示例（React 版）：\n1// Lumino 侧 Widget 2import { Widget } from \u0026#39;@lumino/widgets\u0026#39;; 3import React from \u0026#39;react\u0026#39;; 4import { createRoot, Root } from \u0026#39;react-dom/client\u0026#39;; 5import { MyReactPanel } from \u0026#39;./MyReactPanel\u0026#39;; 6 7class ReactHostWidget extends Widget { 8 private _root: Root | null = null; 9 10 constructor() { 11 super(); 12 this.addClass(\u0026#39;my-ReactHostWidget\u0026#39;); 13 } 14 15 protected onAfterAttach(msg: any): void { 16 this._root = createRoot(this.node); 17 this._root.render(\u0026lt;MyReactPanel /\u0026gt;); 18 } 19 20 protected onBeforeDetach(msg: any): void { 21 this._root?.unmount(); 22 this._root = null; 23 } 24} 关键点：\n在 Widget 的生命周期里挂/卸 React/Vue 应用，这样不会和 Lumino 的 attach/detach 打架。 这时你基本不会再用 @lumino/virtualdom，而是让 React 自己管理这块子树。 Theia 社区里已经有不少扩展就是这么做的：\n核心壳用 Lumino/Theia，业务视图用 React/Vue，这样既能享受 IDE 级的布局和命令系统，又能复用已有的组件库和生态。\n2. React/Vue 作为主 UI，Lumino 组件嵌进去（不太常见但可以） 反过来的情况也存在：你的应用主架子是 React/Vue，只想要一块 Lumino 的 DockPanel / datagrid。\n典型做法：\n在 React/Vue 组件里，用一个 ref 拿到 DOM 容器； 在 onMounted / useEffect 里创建 Lumino Widget，并用 Widget.attach 挂进去； 在组件卸载时调用相应的 dispose / detach。 伪代码就不展开了，思路和上一节是镜像关系——只是这回由 React/Vue 管生命周期，Lumino 当 guest。\n3. virtualdom 自己 + React/Vue 混用？不推荐硬混 理论上你可以在某个 Widget 里一会儿用 VirtualDOM.render，一会儿又在子节点里挂 React/Vue，\n只要边界划清楚（谁管哪棵 DOM 子树）就不会直接冲突。\n但从工程实践角度看，我更建议：\n要么这一块完全交给 React/Vue（Widget 只当壳）； 要么这一块完全用 Lumino virtualdom； 避免在同一小块 UI 里又 VDOM 又 React/Vue，调试起来很烧脑。 和 React/Vue 相比，什么时候更适合用 Lumino 自己的 virtualdom？ 结合这几篇的上下文，我自己的结论是：\n如果这块 UI 高度和 Lumino Widget / DockPanel / command 系统一体化，比如：\n菜单、命令面板、内置对话框； 和布局、焦点、命令密切耦合的小组件；\n那直接用 Lumino virtualdom 是最自然的选择。 如果这块 UI 更像一个独立业务模块，比如：\n复杂表单、可视化、业务面板； 已经有一整套 React/Vue 组件可以直接拿来用；\n那就让 React/Vue 当里面的“小世界”，Lumino 当外壳就好。 从学习角度看，搞明白 Lumino virtualdom 的价值在于：\n再读 Lumino 和 Theia 一些“看起来像 React，又不是 React”的组件实现时，脑子里会有个更清晰的模型； 真要在 IDE 壳里嵌 React/Vue，也知道边界应该画在哪儿、哪些该交给谁来管。 ","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/lumino%E7%9A%84virtualdom_%E4%B8%8Ereact_vue%E7%9A%84%E5%AF%B9%E6%AF%94%E4%B8%8E%E7%BB%93%E5%90%88/","section":"docs","title":"Lumino 的 virtualdom：轻量 VDOM、对比 React/Vue 以及如何结合使用"},{"body":" 前面在讲 Widget / signaling / messaging 的时候，其实一直有个“隐身角色”：\n谁来负责把事件监听、定时器、模型订阅这些东西在合适的时机清掉？\n这篇就从 @lumino/disposable 讲起，顺便把几类常见组件的生命周期串一遍。\n@lumino/disposable：一个很小但到处都在用的模式 @lumino/disposable 暴露的大致内容很简单：\nIDisposable 接口：只有一个 dispose(): void 方法； DisposableDelegate：包装一个 () =\u0026gt; void 的小工具，dispose() 时调用这个函数； DisposableSet：一组 disposable 的集合，可以一次性 dispose() 全部。 最朴素的用法是：\n1import { DisposableDelegate, DisposableSet } from \u0026#39;@lumino/disposable\u0026#39;; 2 3// 单个 disposable：包一段“清理逻辑” 4const d1 = new DisposableDelegate(() =\u0026gt; { 5 console.log(\u0026#39;clean up something\u0026#39;); 6}); 7 8// disposable 集合：方便成批管理 9const bag = new DisposableSet(); 10bag.add(d1); 11bag.add(new DisposableDelegate(() =\u0026gt; console.log(\u0026#39;another cleanup\u0026#39;))); 12 13// 在合适的时机统一释放 14bag.dispose(); 看起来非常简单，但它的价值在于——给“资源释放”这件事一个统一的抽象，\n在大型框架（比如 Theia）里，很多服务/组件都会实现 IDisposable，方便在应用关闭或容器销毁时统一清理。\n把 disposable 和 Widget 生命周期结合起来 以 Widget 为例，一个常见套路是：\n在 onAfterAttach 里订阅事件、signal、定时器等； 在 onBeforeDetach 或 Widget 自身的 dispose() 里用 DisposableSet 把这些资源一次性释放。 一个简单的示例：\n1import { Widget } from \u0026#39;@lumino/widgets\u0026#39;; 2import { DisposableSet, DisposableDelegate } from \u0026#39;@lumino/disposable\u0026#39;; 3import { ISignal, Signal } from \u0026#39;@lumino/signaling\u0026#39;; 4 5class Model { 6 private _changed = new Signal\u0026lt;Model, void\u0026gt;(this); 7 8 get changed(): ISignal\u0026lt;Model, void\u0026gt; { 9 return this._changed; 10 } 11 12 trigger() { 13 this._changed.emit(void 0); 14 } 15} 16 17class MyWidget extends Widget { 18 private _model = new Model(); 19 private _toDispose = new DisposableSet(); 20 21 constructor() { 22 super(); 23 this.addClass(\u0026#39;my-DisposableDemo\u0026#39;); 24 } 25 26 protected onAfterAttach(msg: any): void { 27 // 1. 订阅 model 的 signal 28 this._model.changed.connect(this.onModelChanged, this); 29 this._toDispose.add( 30 new DisposableDelegate(() =\u0026gt; { 31 this._model.changed.disconnect(this.onModelChanged, this); 32 }), 33 ); 34 35 // 2. 绑定 DOM 事件 36 const handler = () =\u0026gt; this._model.trigger(); 37 this.node.addEventListener(\u0026#39;click\u0026#39;, handler); 38 this._toDispose.add( 39 new DisposableDelegate(() =\u0026gt; { 40 this.node.removeEventListener(\u0026#39;click\u0026#39;, handler); 41 }), 42 ); 43 } 44 45 protected onBeforeDetach(msg: any): void { 46 // 3. 在离开 DOM 前统一清理 47 this._toDispose.dispose(); 48 } 49 50 private onModelChanged(sender: Model): void { 51 console.log(\u0026#39;model changed\u0026#39;); 52 } 53} 这段代码表达的意思很简单：\n只要 Widget 不再挂在页面上，它附带的各种监听/订阅都应该跟着寿终正寝，而不是在后台默默泄露。\n在 Theia 里也有类似的模式，只不过很多时候是通过依赖注入 + DisposableCollection（和 Lumino 很像）来管理。\n常见组件的生命周期：从 Application 到 Widget 顺着 disposable 的话题，把几种常见层级的生命周期按“自上而下”捋一下（简化版，只讲和清理相关的点）：\n1. Application 层 创建阶段： new Application / FrontendApplication； 构造 CommandRegistry、Shell、菜单系统等； 注册各种服务、贡献点（在 Theia 里是 Contribution）。 运行阶段： 通过命令、菜单、布局等创建/销毁一批批 Widget / 视图。 销毁阶段： 应用关闭时，调用 Application 的 dispose()，它再递归调用 shell / 服务等的 dispose()。 这里 @lumino/disposable 的作用是给“服务”和“子系统”一个统一的离场接口，便于 Application 在 shutdown 时不遗漏。\n2. Shell / 布局层 以包含 DockPanel 的 Shell 为例：\n创建/attach：DockPanel 被挂到 DOM 上，子 Widget 依次收到 onAfterAttach。 布局变化：拆分/合并/关闭标签，部分 Widget 被从 DockPanel 中移除，触发 onBeforeDetach。 彻底销毁：Shell 自身被 dispose()，通常会把内部所有 Widget dispose() 一遍。 在这个层级上，比较重要的是：DockPanel 自己也实现了 dispose()，会清理内部的布局状态和监听，\n不然长时间折腾布局可能会造成内存堆积。\n3. 单个 Widget 层 对于一个普通 Widget，生命周期大概是这样的：\n构造函数：初始化状态，但不要操作 DOM（因为还没 attach）。 onAfterAttach： 可以安全地访问 this.node 所在的 DOM 环境； 适合绑定事件、启动定时器、订阅模型 signal。 onUpdateRequest / onResize： 响应外界的更新/布局变化； 通常通过 this.update() 触发。 onBeforeDetach： 从 DOM 中卸载前最后的机会； 适合解除事件监听、取消定时任务、断开 signal 订阅（通常配合 DisposableSet）。 dispose()： Widget 生命周期的最终终点； 会确保不再接受消息循环，内部资源应在这里全部释放。 在 Theia 的 ReactWidget 等封装里，这套生命周期会再被转译成更贴近 React 的钩子，但底层还是 Lumino 的消息/生命周期模型在运转。\n在 Theia/Lumino 里看“生命周期 + 资源释放”的几个观察点 实际翻代码或写扩展时，我自己会刻意留意这些地方：\n有没有实现/继承某个 IDisposable / DisposableCollection： 有的话，基本可以推断这个对象在某处会被集中 dispose()； 自己往里面加资源（比如 toDispose.push(...)）就比较安全。 Widget 是否在 onBeforeDetach 或 dispose() 里对事件/信号做了对称的清理： 如果只在 onAfterAttach 里 addEventListener 或 connect，没有拆，就要小心可能的泄露。 服务/单例对象里有没有长生命周期的订阅： 比如 singleton service 订阅了很多 view/model 的事件，却从不释放，这种在 IDE 跑久了很容易炸内存。 把这些模式装进脑子之后，再看 Theia / Lumino 源码里各种“清理逻辑”，会觉得亲切很多：\n大多数看起来“啰嗦”的 dispose 代码，其实都是在给长跑型应用买安全感。\n小结：disposable 是“看不见，但处处在”的一层保障 总结一下这一篇想说的：\n@lumino/disposable 本身非常小，但给“资源释放”提供了一个统一接口和组合工具； 把它和 Widget / Shell / Application 等不同层级的生命周期结合起来，可以形成一套相对清晰的“谁负责善后”的约定； 在像 Theia 这种长时间运行的 IDE 场景里，这种模式对避免内存泄露、事件乱飞有很现实的意义。 写这一篇更像是给自己加一个过滤器：\n以后看到 dispose()、Disposable*、onBeforeDetach 这些字样时，脑子里会自动敲个钟——这里是在讲“善后”，值得多看两眼。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/lumino%E7%9A%84disposable%E4%B8%8E%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","section":"docs","title":"Lumino 的 disposable 与组件生命周期：东西造出来，总要有人负责善后"},{"body":" 前面几篇更多在讲架构和机制，这篇换个角度，把问题缩成一句话：\nLumino 这种“Widget + virtualdom + 布局系统”的组合，在性能上大概处于什么水平，它的瓶颈在哪儿，以及和 React 相比，我们在优化时应该注意什么。\n先说定位：Lumino 关心的“性能问题”跟普通业务前端不太一样 先别急着把 Lumino 和“做后台管理界面”的 React App 放一起比。\nLumino 设计时主要盯的是这几类压力场景：\nIDE / 开发工具：长时间运行、窗口/面板频繁打开关闭、拖拽分屏、Tab 切换。 数据工具（如 JupyterLab）：同时存在大量 Widget（输出面板、Notebook 单元格、数据表格等），需要在有限屏幕下做虚拟化和布局计算。 所以它更在意：\n布局计算和重绘频率：频繁拖拽、分屏、缩放时，不能把浏览器卡死。 大量 Widget 并存时的管理成本：每个 Widget 都有生命周期和消息循环，调度如果粗糙很容易爆栈/卡顿。 长时间运行时的内存稳定性：不希望 IDE 打开一天之后越来越卡。 而 React 更常被用在：\n复杂但以“表单 + 列表 + 图表”为主的业务 UI； 更强调「声明式 + 可组合」的开发体验，性能问题多集中在 diff 频率、组件粒度、状态切片等方面。 这两个世界有重叠，但焦点不完全一样。\nLumino 层面的性能基石：三块砖 粗略看，Lumino 在性能上主要依赖三块基石：\n轻量的 virtualdom\n不搞复杂的 hook/state 体系，就是一个“描述虚拟树 + 打补丁”的库； 这使得它在内部组件（菜单、命令面板等）的 DOM 更新上成本比较可控。 消息驱动的 Widget 生命周期（messaging）\n用 MessageLoop 把 onUpdateRequest / onResize 这些钩子调度起来，避免直接递归和多余调用； 可以在必要时把多个更新合并到一轮消息循环中。 布局组件的增量更新\nDockPanel / SplitPanel / TabBar 等布局变化时，只动受影响的子树； 内置一些合理的限制（比如拖拽区域的命中计算、布局树的结构）来避免退化成“全局重排”。 这些东西加在一起，可以撑起 JupyterLab / Theia 这种规模的应用在普通开发机上长期运行。\n和 React 的几个典型对比点 1. 更新触发的心智模型 React：\nsetState / hook 改变状态 → 触发一次“从根/某个子树开始的重新渲染” → React 内部做 diff + commit； 强调“你只描述最终状态，我来算中间过程”。 Lumino：\n大部分时候是“你显式调用 widget.update()”，然后在 onUpdateRequest 里决定怎么渲染（用 virtualdom 或直接 DOM）； 更强调“由你来控制何时重绘，我帮你调度生命周期”和“给你一个 VDOM 工具加速 patch”。 结果是：\nReact 更适合大面积声明式 UI，性能优化偏向“减小渲染树 / 拆状态 / memo”。 Lumino 更适合精细控制少量但复杂的 Widget，性能优化偏向“控制 update 频率 / 减少不必要的消息派发 / 控制布局复杂度”。 2. diff 粒度与重绘策略 React：\n通常从某个组件子树根开始 diff； 有 React.memo、shouldComponentUpdate、hook 依赖数组等机制帮你减少不必要的 diff。 Lumino virtualdom：\n你自己决定在 _render() 里构造多大的一棵 VNode 树，然后交给 VirtualDOM.render； 没有组件级别的“自动跳过”，需要你从 Widget 设计上就把“更新频繁的小块”和“很少变的大块”拆开。 这意味着：\n在 Lumino 里，不要让一个 Widget 的 _render() 管太多内容，否则每次 update() 都会 diff 一大块； 对比 React 的“拆组件”，这里更像是“拆 Widget 或拆局部视图”。 3. 布局和重排成本 React 本身不负责布局，只是更新 DOM，布局/reflow 由 CSS 决定； Lumino 的 DockPanel / SplitPanel 自己参与了布局决策（位置、尺寸计算）， 优点：IDE 类需求实现起来更可控； 风险：布局树如果太复杂、嵌套太深，频繁拖拽/resize 时的计算成本会抬高。 这里更接近“游戏 UI / 自己写布局引擎”的思路，而不是纯 CSS 布局。\n在复杂 IDE 场景里，这反而是优势：可以精确控制哪些区域需要重算，哪些可以保持不动。\n在 Lumino 里常见的几个性能坑 \u0026amp; 优化思路 结合前面讲过的模块，我自己会注意这些点：\n1. 不要滥用 update()，尤其是“级联 update” 典型坑：\nA Widget 的 onUpdateRequest 里调用 B 的 update()，B 的 onUpdateRequest 又调用 C 的 update()…… 如果缺乏节制，很容易在一次状态变化里触发多层 Widget 的级联重绘。 优化思路：\n做好“状态层”和“视图层”的拆分，用 signaling 把模型变化广播出去，让每个 Widget 自己决定何时 update()； 能批量更新的地方，尽量合并到一次 update() 调用里，而不是在一个事件回调里多次触发。 2. 大量 Widget 并存时，注意生命周期清理 长时间运行的 IDE 容易出现的不是“单次卡顿”，而是：\n某些 Widget 虽然从布局里移除了，但没有被 dispose()； 或者 onBeforeDetach 里没有清掉事件监听 / signal 订阅； 导致消息循环还在偷偷调度它们，内存占用和 CPU 占用慢慢累积。 这里和 React 很像：\nReact 要在 useEffect 里写好 cleanup，Lumino 要在 onBeforeDetach / dispose() 里配合 disposable 把尾巴收干净。\n3. 布局树的复杂度控制 在 DockPanel 里，如果你疯狂拆分区域、嵌套 Panel，理论上布局计算会变重。\n常见的工程级策略：\n设计时限制最大分屏层级（比如不要嵌套太多层 split）； 对某些“辅助视图”采用 overlay/抽屉之类的轻量展示方式，而不是都塞进 DockPanel 树里； 对布局做序列化/还原时，也可以顺便做一些“瘦身”（比如合并已经空掉的区域）。 React 这边类似的问题是“大而全的组件树 + 过多 context/hook”，\n但解决手段不同：React 偏向拆组件和状态切片，Lumino 偏向合理剪裁布局树和 Widget 粒度。\n当你在 Theia 上做二次开发时，可以关注的性能点 站在 Theia 使用者的角度，很多底层优化已经由 Lumino 负责了，我们更需要关注的是：\n自己的扩展/视图里：\n避免在高频事件（如 mousemove、scroll）里频繁 update()； 用合理的 debouce/throttle 包一下，或者只在状态真正变化时更新； 注意 dispose() / onBeforeDetach 把事件监听和 signal 断干净。 和 React 结合时：\nReact 组件本身继续遵守常规优化套路（比如 memo、避免在 render 里创建新函数等）； 注意 React 的更新不要频繁触发 Lumino 布局/尺寸变更，必要时可以把某些区域固定尺寸，减少 reflow。 总体感觉是：\nLumino 提供的是一套偏“工程型工具”的基础设施，默认性能足够支撑 IDE 等重度场景；\n真正更容易踩坑的地方，往往是在我们的扩展/业务视图里对 update/布局/资源释放的粗心使用。\n小结：别指望它像 React 一样“自动聪明”，但它给了你足够的控制力 最后收个口：\n和 React 相比，Lumino 在“性能自动优化”的花活上要朴素很多——没有 hook 依赖分析、没有调度优先级、没有 concurrent 模式。 但它给了你另一种东西：对生命周期和布局非常直接的控制权，再配上一套轻量 virtualdom 和消息循环，让你能在 IDE 这类复杂场景里按需、精确地优化。 从我的学习体验来说，\n把 Lumino 当成“低层基础设施 + 需要你自己有性能意识的工具箱”，再用 React/Vue 承载那些更偏业务的视图，是一个相对舒服的分工方式。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/lumino%E7%9A%84%E6%80%A7%E8%83%BD%E4%B8%8E%E4%BC%98%E5%8C%96_%E4%B8%8Ereact%E7%9A%84%E5%AF%B9%E6%AF%94%E6%80%9D%E8%80%83/","section":"docs","title":"Lumino 的性能与优化：与 React 的对比思考"},{"body":" 前面写了很多 Lumino 在 IDE / JupyterLab 里的实际用法，这篇稍微发散一点，\n聊聊如果用 Lumino 去做“视频编辑器”这类重工具型应用，会长成什么样，以及哪些能力是天然对口的。\n为什么一提视频编辑器，就容易想到 Lumino 这种框架？ 先拆一下典型“视频编辑器”的几个 UI 特征（不管是 PR、DaVinci 还是浏览器里的在线剪辑）：\n多区域布局：时间线、媒体资源库、预览窗口、属性面板、效果面板、调色窗口……一大堆 Panel。 强交互拖拽：拖媒体到时间线、拖动片段边界、拖调色曲线、拖调音量关键帧。 大量可配置视图：不同工作区（剪辑、调色、音频）下，面板组合和布局都不一样。 长时间运行 + 复杂状态：项目可能开着一整天不停修改，Undo/Redo 状态很重。 这些需求和 IDE / 数据分析工具的共性是很明显的：\n都是“界面复杂 + 布局多变 + 交互重 + 状态多”的工具型应用。\n而 Lumino 恰好就是为这类场景准备的：\nDockPanel / SplitPanel / TabBar：负责复杂布局和可停靠窗口。 signaling / command / virtualdom：负责状态联动和界面渲染。 dragdrop / keyboard / FocusTracker：负责拖拽、快捷键、焦点管理。 所以从“气质”上，Lumino 和视频编辑器这类产品是很对味的。\n用 Lumino 搭一个视频编辑器大致会怎么分层？ 如果用前面几篇写过的模块来想象，可以粗略划成几层：\n应用壳（Application + Shell）\n提供主菜单（文件/编辑/视图/窗口）、工具栏、全局命令面板。 管理不同的“工作区布局”（剪辑视图、调色视图等）——本质上是 DockPanel 布局的不同预设。 布局层（DockPanel / SplitPanel / TabBar）\n左侧：媒体资源浏览器 / 项目结构。 中间：预览窗口 + 时间线区域（可以再分上下）。 右侧：属性面板 / 效果堆栈 / 调色工具。 面板可以拖来拖去、拆分成多屏、存成自定义布局，这些都可以直接复用 Lumino 的 dock 布局能力。 视图 Widget 层\nMediaLibraryWidget：展示素材缩略图、支持拖拽到时间线。 TimelineWidget：展示多轨道时间线、关键帧、剪辑片段。 PreviewWidget：视频实时预览。 InspectorWidget：展示当前选中片段/效果的属性。 这些 Widget 既可以自己用 Lumino virtualdom 写 UI，也可以内部挂 React/Vue 组件。 状态与命令层（signaling + command）\n项目状态：轨道、片段、效果、关键帧等数据结构。 命令：剪切、复制、粘贴、撤销、重做、插入片段、应用效果…… 不同 Widget 通过 signal 订阅这些模型的变化，同步界面；菜单/快捷键/工具栏按钮通过 command 触发修改。 性能 \u0026amp; 后端处理层\n真正的音视频编解码、渲染、导出通常在 WebAssembly/原生层或后台服务里做； Lumino 更多负责“项目编辑界面”和“动作编排”，而不是在 JS 层做重度解码。 从这个角度看，Lumino 提供的是一套“编辑器 UI 基础设施”，而具体的视频处理内核可以根据项目选择 ffmpeg wasm、本地原生模块、远程服务等。\n一些具体的 UI 例子：Lumino 能帮上哪些忙？ 1. 时间线与多轨布局 时间线本身可以是一个自定义 TimelineWidget，内部负责：\n用 Canvas / SVG / DOM 绘制轨道、片段、波形； 使用 Lumino 的 dragdrop 系统处理拖拽片段、调整长度、移动关键帧； 通过 signaling 把“当前播放头位置”“选中片段”等状态广播给其它 Widget（比如预览和 inspector）。 外层用 DockPanel 把 TimelineWidget 和 PreviewWidget 等组合起来：\n类似 VS Code 的 editor group，只不过这里是“剪辑工作区”。\n2. 可停靠的工具面板 调色、音频、特效、属性这些面板，很像 IDE 里的 Outline / Problems / Debug / Terminal：\n每个都是一个独立 Widget，可以在 DockPanel 里自由停靠。 通过命令/菜单控制它们的显隐（视图菜单里勾选）。 用户可以自己拖动这些面板，形成符合个人习惯的 layout，布局可以用 saveLayout/restoreLayout 存起来。 这部分几乎可以原样照搬 Theia 的做法，只是里面放的不是代码相关视图，而是视频相关工具。\n3. 复杂表格/列表：素材管理、效果列表 素材管理、效果堆栈、关键帧列表等，都有一种“半表格半树”的味道：\n这时可以考虑用 Lumino 的 datagrid / Tree 组件，加上 virtualdom 做定制渲染， 比如：\n左侧媒体库用 Tree 展示项目层级 + 媒体类型。 效果堆栈区用 list + draggable item 来展示当前片段挂了哪些效果。 关键帧列表用 datagrid 的行列模型来支撑复杂交互。 这些东西单独实现一遍成本很高，而 Lumino 已经有一部分现成积木可以用。\n和 React/Vue 生态结合的想象 现实里完全用 Lumino 写一个大视频编辑器，可能会觉得在业务 UI 上“有点原始”；\n更现实一点的路线是：\n用 Lumino 搭“工作台壳子”：布局、命令系统、快捷键、菜单、工具栏、右键菜单，这些都交给 Lumino； 用 React/Vue 写“具体工具面板”：比如调色曲线、参数调节表单、项目设置对话框，内部直接用熟悉的组件库（Ant Design、Element Plus 等）。 桥接方式前面 virtualdom 那篇已经提过：\n用一个 Lumino Widget 包住 React/Vue 入口，在 Widget 的生命周期里挂载/卸载前端框架。\n这样可以同时：\n复用 Lumino 在“多窗口、多布局、多命令”的长板； 也享受 React/Vue 在业务组件生态上的丰富度。 实际上有没有类似方向的项目？ 公开世界里，更多是“重工具 + Web 技术”的趋势，例如：\n基于浏览器的 IDE（Theia、VS Code Web等）； 在线白板、在线设计工具（Figma 等）； 在线音视频编辑器（各大 SaaS 产品）。 它们不一定直接用 Lumino，但解决的问题非常类似：\n在浏览器里构建一个长时间运行、交互重、有复杂布局的“工作台”。\n从个人视角看，Lumino 更像是一个“通用工作台 UI 底座”的候选之一：\n如果你本身就对 Theia 架构熟悉，那么把那一套方法论迁移到“视频编辑器”“数据可视化工作台”“在线 IDE for 某领域”等产品上，理论上是完全可行的。\n小结：把 Lumino 当成“通用工具类应用壳”的一个选项 这一篇更像是“脑洞 + 架构草图笔记”，总结一下核心观点：\n视频编辑器这类工具型应用和 IDE 在 UI 形态上高度相似：多 Panel、可停靠布局、重度拖拽、复杂状态。 Lumino 在布局、命令、事件、Widget 模型上的设计，天然适合做“工作台壳子”； 真正的音视频处理、业务逻辑可以交给专门的内核（WASM/原生/服务端）和 React/Vue 等业务 UI 框架，Lumino 负责把这一切编排到一个统一的桌面感界面里。 对我个人来说，这也是为什么在看完 Theia + Lumino 源码之后，会下意识把它们当成“以后做各种专业工具型 Web 应用的备选底座”——\n不一定每次都用，但一旦要做的是“工作站”而不是“普通网站”，Lumino 这套东西就值得往脑子里冒一下。**\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/lumino%E5%9C%A8%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%91%E5%99%A8%E7%AD%89%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%83%BD%E6%80%A7%E4%B8%8E%E6%83%B3%E8%B1%A1/","section":"docs","title":"Lumino 在视频编辑器等工具类应用中的可能性与想象"},{"body":" 安装 可以通过 npm 或者 yarn 来引入 InversifyJS：\n1yarn add inversify reflect-metadata InversifyJS 类型定义包含在 inversify npm 包中。InversifyJS 需要 experimentalDecorators、 emitDecoratorMetadata 和 lib 编译选项开启在 tsconfig.json 文件中。 1{ 2 \u0026#34;compilerOptions\u0026#34;: { 3 \u0026#34;experimentalDecorators\u0026#34;: true, 4 \u0026#34;emitDecoratorMetadata\u0026#34;: true 5 } 6} InversifyJS 需要一个支持下面特性的现代 JavaScript 引擎：\nReflect metadata Promise (仅在使用 provider injection 时需要) Proxy (仅在使用 activation handlers 时需要) 如果你的环境不支持其中的特性，那么需要引入 shim 或者 polyfill。\n环境支持和 polyfills InversifyJS 需要一个现代的 JavaScript 引擎，需要支持 Promise、 Map、 Metadata Reflection API 和 Proxy 对象。 如果你的环境不支持这些的化，就需要引入 shim 或者 polyfill。\nMetadata Reflection API reflect-metadata polyfill 仅在进入应用时需要引入一次，因为反射对象是一个全局单例。更多详情参见这里。 始终需要。使用 reflect-metadata 作为 polyfill。\n1yarn install reflect-metadata reflect-metadata 的类型定义已在 npm 包中被包含。你需要添加如下引用到 tsconfig.json 中的类型字段：\n1{ 2 \u0026#34;compilerOptions\u0026#34;: { 3 \u0026#34;types\u0026#34;: [\u0026#34;reflect-metadata\u0026#34;] 4 } 5} 最后，引入 reflect-metadata。如果你使用：\n1import \u0026#34;reflect-metadata\u0026#34;; 如果你在使用网页浏览器那么可以使用 script 标签：\n1\u0026lt;script src=\u0026#34;./node_modules/reflect-metadata/Reflect.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 这将创建全局反射对象。\nMap Map 在使用 InversifyJS 3 或者更高版本时需要。\n大多数现代 JavaScript 引擎支持 map，但如果你需要支持旧浏览器，那么需要使用 map polyfill (比如 es6-map)。\nPromise Promise 仅在使用 注入提供者 时需要。\n多数现代 JavaScript 引擎支持 promise，但如果你需要支持就浏览器，那么需要使用 promise polyfill (比如 es6-promise 或者 bluebird)。\n","link":"https://misakaJimmy.github.io/docs/frontend/inversifyjs/install/","section":"docs","title":"项目中引入 InversifyJS"},{"body":" 代码解析 1import * as inversify from \u0026#39;inversify\u0026#39;; 2import \u0026#39;reflect-metadata\u0026#39;; 引入 inversify 以及 reflect-metadata 两个包。\n1const TYPES = { 2 // 忍者 3 Ninja: \u0026#39;Ninja\u0026#39;, 4 // 武士刀 5 Katana: \u0026#39;Katana\u0026#39;, 6 // 手里剑 7 Shuriken: \u0026#39;Shuriken\u0026#39; 8} 定义了类对应的映射，这里定义了三个类，看过火影的应该很容易理解Ninja(忍者)、Katana(武士刀)和Shuriken(手里剑)之间的关系。\n1class Katana { 2 hit() { 3 return \u0026#39;cut!\u0026#39;; 4 } 5} 6 7class Shuriken { 8 throw() { 9 return \u0026#39;hit!\u0026#39;; 10 } 11} 12 13class Ninja { 14 private _katana: Katana; 15 private _shuriken: Shuriken; 16 17 constructor(katana: Katana, shuriken: Shuriken) { 18 this._katana = katana; 19 this._shuriken = shuriken; 20 } 21 22 fight() { 23 return this._katana.hit(); 24 } 25 26 sneak() { 27 return this._shuriken.throw(); 28 } 29} 接着是Ninja(忍者)、Katana(武士刀)和Shuriken(手里剑)三个类的实现。其中 Katana 类实现了 hit 方法，Shuriken 实现了 throw 方法，Ninja 中定义了两个私有对象 _katana 和 _shuriken，并在构造函数之中传入这个两个对象，Ninja 类中的 fight 方法中将调用 _katana 的 hit 方法，sneak 方法中将调用 _shuriken 的 throw 方法。\n1// 声明可被注入以及其依赖项 2inversify.decorate(inversify.injectable(), Katana); 3inversify.decorate(inversify.injectable(), Shuriken); 4inversify.decorate(inversify.injectable(), Ninja); 5inversify.decorate(inversify.inject(TYPES.Katana), Ninja, 0); 6inversify.decorate(inversify.inject(TYPES.Shuriken), Ninja, 1); 7 8// 声明绑定关系 9const container = new inversify.Container(); 10container.bind(TYPES.Ninja).to(Ninja); 11container.bind(TYPES.Katana).to(Katana); 12container.bind(TYPES.Shuriken).to(Shuriken); //@TODO\n这里终于引入了依赖注入的概念，这里使用了 decorate 来将 Katana、Shuriken和Ninja\n","link":"https://misakaJimmy.github.io/docs/frontend/inversifyjs/base-ts-example/","section":"docs","title":"InversifyJS 基础演示(TS)"},{"body":" 前面几篇都在聊“看得见”的东西（Widget、布局、命令、virtualdom 等），\n这篇换个口味，把那些在源码里经常蹦出来、但平时不太会单独提的模块凑一块儿：@lumino/algorithm、@lumino/collections、@lumino/properties、@lumino/polling ……\n顺便和大家更熟悉的 Lodash 做个对比：它们分别在解决什么类型的问题，什么时候用谁更合适。\n先定个调：这是“框架内部基建”，不是“业务工具库” Lodash 更像是：\n给业务代码用的通用数据处理工具箱：map / filter / cloneDeep / debounce / throttle / groupBy 等等； 强调对各种 JS 内建类型（Array、Object、Function）的补强，兼容历史浏览器。 而 Lumino 这一堆模块，更像是：\n给 Lumino 自己和 IDE 级应用用的“内部基建”：数据结构、算法、属性系统、轮询等； API 设计更偏 TypeScript + 框架场景，几乎不考虑早期浏览器兼容性。 简单一句话：\nLodash 是“通用瑞士军刀”；这些 Lumino 模块是“为这套框架量身定制的扳手和螺丝刀”。\n@lumino/algorithm：一小撮“拿来就用”的算法积木 里面的东西大多是一些针对 Iterable/Array 的小算法，比如：\n搜索：find, lowerBound, upperBound 排序：topologicSort 等 集合操作：iter 系列辅助函数 使用风格有点像“更 TypeScript 友好的小算法集合”，常见场景：\n在 Lumino 内部，需要对一组命令、Widget、菜单项等做有序插入、二分搜索； 对树/图做一些简单排序/遍历（比如拓扑排序）。 对比 Lodash：\nLodash 的 sortBy, find, uniqBy 更偏向“业务数据处理”； @lumino/algorithm 更偏“框架内部用的小一撮专用算法”，数量少但目标明确。 如果你是在写业务逻辑，大部分时候继续用 Lodash / 原生 Array 方法就够；\n只有在跟 Lumino 内部数据结构打交道时，才有机会顺手蹭 @lumino/algorithm 的现成实现。\n@lumino/collections：为框架准备的容器，而不是通用 Map/Set 替代品 这个包里常见的是一些更高阶的数据结构，比如：\n有序映射、队列之类的容器； 针对框架内部常见场景（比如事件队列、消息队列）做了一些优化/封装。 和 Lodash 的差异在于：\nLodash 主要操作的是已有的 Array/Object； @lumino/collections 更在意“在框架内部长期存在的结构”——比如消息队列、观察者列表，这些东西在 IDE 里会长时间活着。 对我们写扩展/业务代码的人来说，用到它的机会不一定很多，但在读 Lumino/Theia 源码时一旦看到这些类型，就知道：\n这是一个“框架级容器”，生命周期和作用域往往比较大； 性能/复杂度的考量可能比一般业务数组要敏感些。 @lumino/properties：给对象挂“扩展属性”的正规方式 @lumino/properties 解决的痛点是：\n当你想给一个对象额外挂点状态，又不想真的往这个对象上加字段时，该怎么办？\n典型用法（示意）：\n1import { AttachedProperty } from \u0026#39;@lumino/properties\u0026#39;; 2 3class MyWidget { /* ... */ } 4 5// 为 MyWidget 定义一个“附加属性” 6const someFlag = new AttachedProperty\u0026lt;MyWidget, boolean\u0026gt;({ 7 name: \u0026#39;someFlag\u0026#39;, 8 create: () =\u0026gt; false, // 默认值 9}); 10 11const w = new MyWidget(); 12 13// 读取 / 设置就像访问属性一样 14console.log(someFlag.get(w)); // false 15someFlag.set(w, true); 底层可以类比成一个“带元数据的 WeakMap”：\n不会污染原对象的字段，又能给任意对象挂上一些扩展状态——在框架里尤其适合做：\n插件/扩展为核心对象挂额外标记； 在不破坏封装的前提下，给一些内部对象加“侧写信息”。 对比 Lodash：\nLodash 通常直接在对象上加字段，或者用 WeakMap 自己管理映射； @lumino/properties 提供的是一个更体系化、可组合、带默认值的“扩展属性”机制。 如果你是在 Lumino 的语境里写扩展，这个模式会比“到处塞私有字段”更干净；\n换成纯业务代码场景，继续用 Lodash/WeakMap 也完全没问题。\n@lumino/polling：比 setInterval 高一档的轮询封装 在 IDE / 工具类应用里，“定期刷新点东西”是很常见的需求，比如：\n定时刷新某个视图的数据； 对某项异步任务的状态做轮询。 裸写 setInterval 容易踩到的问题包括：\n错误处理杂乱； 在页面隐藏/应用未激活时白白浪费资源； 和 Widget/Application 生命周期脱节，容易忘记清理。 @lumino/polling 试图给这件事一个更框架化的解决方案，比如：\n支持退避策略（失败时拉长间隔）； 支持基于可见性/活跃状态暂停； 有比较统一的取消/错误处理入口。 对比 Lodash：\nLodash 提供的是 debounce / throttle 这类节流/防抖工具； @lumino/polling 管的是“有生命周期、有状态的轮询任务”，层级不太一样。 在 Theia/Lumino 里，如果你要写一个“长期存在的后台轮询”，用 @lumino/polling 会更贴近框架的风格；\n如果只是简单防抖按钮点击/搜索输入，继续用 Lodash 的 debounce/throttle 就好。\n这些模块在整个 Lumino / Theia 里的角色 从整体架构视角看，这些“工具 \u0026amp; 基础设施模块”主要起到几个作用：\n让框架内部代码更可读/可维护：\n有了 algorithm / collections，很多地方不用重复造小轮子； properties 让扩展属性的模式统一； polling 让轮询逻辑长得比较像样。 给长生命周期应用提供更稳的基石：\nIDE 这种东西不开浏览器调试工具，开一天两天照样得扛住； 这些基础设施都是为了在这种“长跑”场景下少踩坑服务的。 从“和 Lodash 的关系”来看，可以简单这么想：\nLodash：偏“横向通用”的数据/函数工具库，哪里都能用； Lumino 这些基础设施模块：偏“纵向专用”的框架内部基石，和 Widget / Application / 命令系统这些垂直集成得很紧。 小结：什么时候该想起它们，而不是顺手就 Lodash 一把梭？ 对我个人来说，大概有这么几个“脑中提示”：\n当我在读 Lumino / Theia 源码，看到这几个包名时： 会提醒自己“这块是框架内部基建”，值得多看两眼模式而不只是把实现当黑盒。 当我在做 Theia/Lumino 扩展，需要： 给现有对象挂扩展属性 → 想起 @lumino/properties； 写长期存在的轮询逻辑 → 想起 @lumino/polling； 依赖框架已有的数据结构/算法 → 看看 algorithm / collections 里有没有现成的。 而在纯业务逻辑里： 处理数组/对象/字符串 → 还是优先用 Lodash 或原生 API，更符合团队经验和生态习惯。 这一篇就当是给这些“在代码里经常路过却不太会专门聊”的模块做个小索引：\n以后再碰到它们时，能立刻知道：这是 Lumino 在打地基，而不是在和 Lodash 抢活。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/lumino%E7%9A%84%E5%B7%A5%E5%85%B7%E4%B8%8E%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%A8%A1%E5%9D%97_%E4%B8%8Elodash%E7%9A%84%E5%AF%B9%E6%AF%94%E6%9D%82%E8%B0%88/","section":"docs","title":"Lumino 的工具与基础设施模块：与 Lodash 的对比杂谈"},{"body":" 安装yarn 下载 nodejs 通过 npm 安装 1npm install -g yarn 查看版本 1yarn --version 设置淘宝源 1yarn config set registry https://registry.npm.taobao.org 2yarn config set sass_binary_site https://npm.taobao.org/mirrors/node-sass # node-sass 二进制包镜像 3yarn config set electron_mirror https://npm.taobao.org/mirrors/electron/ # electron 二进制包镜像 4yarn config set ELECTRON_MIRROR https://cdn.npm.taobao.org/dist/electron/ # electron 二进制包镜像 5yarn config set puppeteer_download_host https://npm.taobao.org/mirrors # puppeteer 二进制包镜像 6yarn config set chromedriver_cdnurl https://npm.taobao.org/mirrors/chromedriver # chromedriver 二进制包镜像 7yarn config set operadriver_cdnurl https://npm.taobao.org/mirrors/operadriver # operadriver 二进制包镜像 8yarn config set phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs # phantomjs 二进制包镜像 9yarn config set selenium_cdnurl https://npm.taobao.org/mirrors/selenium # selenium 二进制包镜像 10yarn config set node_inspector_cdnurl https://npm.taobao.org/mirrors/node-inspector # node-inspector 二进制包镜像 yarn 与 npm 命令对比 npm yarn 注释 npm init yarn init 初始化项目 npm install yarn 安装全部依赖 npm install react --save yarn add react 安装某个依赖，保存到 dependencies npm uninstall react --save yarn remove react 移除某个依赖 npm install react --save-dev yarn add react --dev 安装某依赖,保存到 devDependencies npm update [package] --save yarn upgrade [package] 更新生产环境某个依赖包 npm install axios --global yarn global add axios 全局安装某个依赖 npm install --save axios vue-axios yarn add axios vue-axios 同时下载多个依赖包 npm install [package]@[version] yarn add [package]@[version] 安装指定版本的包 npm rebuild yarn install --force 重新下载所有包 npm --save 和 npm --save-dev 区别 npm5版本之前，必须要加上--save，才会将包记录到package.json npm5版本之后开始，--save是默认值了，可以省略不写\n--save 简写 -S 会被记录到dependencies【生产环境】\nnpm 等同 yarn npm i jquery // npm i jquery --save = yarn add jquery npm i jquery -S = yarn add jquery -S // yarn 只有简写 --save-dev 简写 -D 会被记录到devDependencies【开发环境】\nnpm 等同 yarn npm i webpack -D // npm i webpack --save-dev = yarn add webpack -D // yarn 只有简写 dependencies:项目依赖，项目实际运行需要的依赖，上线还是需要的，如（vue，jquery） devDependencies:开发依赖，只在开发时需要的依赖，实际上线不需要的，如（webpack） yarn对比npm的优点 离线模式 yarn会有一个缓存目录，会缓存以前安装过的软件包，再次安装时就不必从网络下载了，大大加速安装速度。\n依赖关系确定性 在每一台机器上针对同一个工程安装依赖时，生成的依赖关系顺序和版本是一致的。\n网络性能优化 下载软件时会优化请求顺序，避免请求瀑布发生。\n网络回弹 yarn在某个安装包请求失败时不会导致安装失败，它会自动去尝试重新安装。而npm则会毫不犹豫的失败，导致得再来一次，耗费时间。\n多注册来源 所有的依赖包，不管他被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是 npm 要么是 bower, 防止出现混乱不一致。\n扁平模式 对于多个包依赖同一个子包的情况，yarn会尽量提取为同一个包，防止出现多处副本，浪费空间。比如1.2中，yarn会为babel-generator和babel-helper-define-map 创建同一个lodash子依赖，这样就节约一份的空间。\n","link":"https://misakaJimmy.github.io/docs/frontend/tools/yarn/","section":"docs","title":"Yarn"},{"body":" 项目链接：github.com/lerna/lerna Lerna 是一个管理工具，用于管理包含多个软件包（package）的 JavaScript 项目。\n关于 将大型代码仓库分割成多个独立版本化的 软件包（package）对于代码共享来说非常有用。但是，如果某些更改 跨越了多个代码仓库的话将变得很 麻烦 并且难以跟踪，并且， 跨越多个代码仓库的测试将迅速变得非常复杂。\n为了解决这些（以及许多其它）问题，某些项目会将 代码仓库分割成多个软件包（package），并将每个软件包存放到独立的代码仓库中。但是，例如 Babel, React, Angular, Ember, Meteor, Jest, 等项目以及许多其他项目则是在 一个代码仓库中包含了多个软件包（package）并进行开发。\nLerna is a tool that optimizes the workflow around managing multi-package repositories with git and npm.\nLerna 还可以减少开发和构建环境中大量包副本的时间和空间需求——这通常是将项目分成许多单独的 NPM 包的缺点。有关详细信息，请参阅 hoist documentation。\nLerna repo 是什么样的？ 它实际上很简单。您的文件结构如下所示：\n1my-lerna-repo/ 2 package.json 3 packages/ 4 package-1/ 5 package.json 6 package-2/ 7 package.json Lerna 能做什么？ Lerna 中的两个主要命令是 lerna bootstrap 和 lerna publish。\nbootstrap 将 repo 中的依赖项链接在一起。 publish 将帮助发布任何更新的包。\nLerna 不能做什么？ Lerna 不是 serverless monorepos 的部署工具。Hoisting 可能与传统的无服务器 monorepo 部署技术不兼容。\n入门 本着用新不用旧的原则，本文像官方文档学习，使用 Lerna 3.0。\n比起npm作者偏爱用yarn，如果不喜欢yarn的可以参考 yarn 与 npm 命令对比\n推荐全局安装 Lerna\n1yarn add -g lerna 接下来，我们将创建一个新的 git 代码仓库：\n1git init lerna-repo \u0026amp;\u0026amp; cd lerna-repo 现在，我们将上述仓库转变为一个 Lerna 仓库：\n1lerna init 这将创建一个lerna.json配置文件和一个packages文件夹，因此您的文件夹现在应如下所示：\n1lerna-repo/ 2 packages/ 3 package.json 4 lerna.json 如何使用Lerna Lerna 允许您使用以下两种模式之一来管理您的项目：Fixed 或 Independent。\nFixed/Locked 模式 (default) Fixed模式 Lerna 项目在单个版本行上运行。版本保存在lerna.json项目根目录下的文件中version。当你运行时lerna publish，如果一个模块自上次发布以来已经更新，它将更新到你发布的新版本。这意味着您只在需要时发布新版本的包。\n注意：如果您的主要版本为零，则所有更新都被认为是破坏性的。因此，lerna publish使用主要版本零运行并选择任何非预发布版本号将导致为所有包发布新版本，即使自上次发布以来并非所有包都已更改。 这是Babel当前使用的模式。如果您想自动将所有包版本绑定在一起，请使用此选项。这种方法的一个问题是，任何包的重大变化都会导致所有包都有一个新的主要版本。\nIndependent 模式 lerna init --independent\n独立模式 Lerna 项目允许维护人员彼此独立地增加包版本。每次发布时，您都会收到有关已更改的每个包的提示，以指定它是补丁、次要、主要还是自定义更改。\n独立模式允许您更具体地更新每个包的版本，并且对一组组件有意义。将此模式与语义释放之类的东西结合起来会减轻痛苦。（atlassian/lerna-semantic-release已经有这方面的工作）。\n将lerna.json中的version设置为independent以运行Independent模式。 基本概念 Lerna在运行命令时遇到错误会记录到一个lerna-debug.log文件（与 npm-debug.log 相同）。\nLerna 还支持scoped packages。\nlerna.json 1{ 2 \u0026#34;version\u0026#34;: \u0026#34;1.1.3\u0026#34;, 3 \u0026#34;npmClient\u0026#34;: \u0026#34;yarn\u0026#34;, 4 \u0026#34;command\u0026#34;: { 5 \u0026#34;publish\u0026#34;: { 6 \u0026#34;ignoreChanges\u0026#34;: [\u0026#34;ignored-file\u0026#34;, \u0026#34;*.md\u0026#34;], 7 \u0026#34;message\u0026#34;: \u0026#34;chore(release): publish\u0026#34;, 8 \u0026#34;registry\u0026#34;: \u0026#34;https://npm.pkg.github.com\u0026#34; 9 }, 10 \u0026#34;bootstrap\u0026#34;: { 11 \u0026#34;ignore\u0026#34;: \u0026#34;component-*\u0026#34;, 12 \u0026#34;npmClientArgs\u0026#34;: [\u0026#34;--no-package-lock\u0026#34;] 13 } 14 }, 15 \u0026#34;packages\u0026#34;: [\u0026#34;packages/*\u0026#34;] 16} version: 存储库的当前版本 npmClient: 用于指定特定客户端以运行命令的选项（也可以在每个命令的基础上指定）。更改为\u0026quot;yarn\u0026quot;使用 yarn 运行所有命令。默认为“npm” command.publish.ignoreChanges: 不包含在lerna changed/publish. 使用它来防止不必要地发布新版本以进行更改，例如修复README.md错字 command.publish.message: 执行版本更新以进行发布时的自定义提交消息。有关更多详细信息，请参阅@lerna/version command.publish.registry: 使用它来设置要发布到的自定义注册表 url 而不是 npmjs.org，如果需要，您必须已经过身份验证 command.bootstrap.ignore: lerna bootstrap 运行命令时不会引导的 glob 数组 command.bootstrap.npmClientArgs: 在 lerna bootstrap 运行时将传递到 npm install 的数据 command.bootstrap.scope: 一个用于 lerna bootstrap 运行时，限制在运行命令时将引导哪些包的一个 glob 数组 packages: 用作包位置的 glob 数组 配置文件lerna.json中的packages字段一个 glob 数组用来匹配拥有package.json的文件夹，这是 lerna 识别\u0026quot;子\u0026quot;包的方式（相对于项目\u0026quot;根\u0026quot;目录 package.json，它旨在管理整个 repo 的开发依赖项和脚本）。\n默认情况下，lerna 将包列表初始化为[\u0026quot;packages/*\u0026quot;]，但您也可以使用其他目录，例如[\u0026quot;modules/*\u0026quot;], 或[\u0026quot;package1\u0026quot;, \u0026quot;package2\u0026quot;]. 定义的 glob 与所在的目录相关，lerna.json通常是存储库根目录。唯一的限制是您不能直接嵌套包位置，但这也是“普通”npm 包共享的限制。\n例如，[\u0026quot;packages/*\u0026quot;, \u0026quot;src/**\u0026quot;]匹配这棵树：\n1packages/ 2├── foo-pkg 3│ └── package.json 4├── bar-pkg 5│ └── package.json 6├── baz-pkg 7│ └── package.json 8└── qux-pkg 9 └── package.json 10src/ 11├── admin 12│ ├── my-app 13│ │ └── package.json 14│ ├── stuff 15│ │ └── package.json 16│ └── things 17│ └── package.json 18├── profile 19│ └── more-things 20│ └── package.json 21├── property 22│ ├── more-stuff 23│ │ └── package.json 24│ └── other-things 25│ └── package.json 26└── upload 27 └── other-stuff 28 └── package.json 在下面定位叶子包packages/*被认为是“最佳实践”，但不是使用 Lerna 的要求。\n废弃字段 有些lerna.json字段不再使用。值得注意的包括：\nlerna: 最初用于表示 Lerna 的当前版本。在 v3 中 过时 并且 删除 常见的devDependencies 大多数devDependencies可以拉到 Lerna repo 的根目录lerna link convert\n上述命令将自动 hoist things 并使用相关 file: 说明符。\nHoisting 有几个好处：\n所有包都使用相同版本的给定依赖项 可以使用Snyk等自动化工具使根目录中的依赖项保持最新 减少依赖安装时间 需要更少的存储空间 请注意，devDependencies提供 npm 脚本使用的“二进制”可执行文件仍然需要直接安装在使用它们的每个包中。\n例如，在这种情况下，为了 lerna run nsp（以及在包的目录中 npm run nsp）正常工作，nsp依赖项是必需的：\n1{ 2 \u0026#34;scripts\u0026#34;: { 3 \u0026#34;nsp\u0026#34;: \u0026#34;nsp\u0026#34; 4 }, 5 \u0026#34;devDependencies\u0026#34;: { 6 \u0026#34;nsp\u0026#34;: \u0026#34;^2.3.3\u0026#34; 7 } 8} Git 托管的依赖项 Lerna 允许将本地依赖包的目标版本编写为带有（例如#committish#v1.0.0或#semver:^1.0.0 ）的git 远程 url ，而不是正常的数字版本范围。当包必须是私有的并且不需要私有 npm 注册表时，这允许通过 git 存储库分发包。\n请注意，lerna 不会将git 历史记录实际拆分为单独的只读存储库。这是用户的责任。\n1// packages/pkg-1/package.json 2{ 3 name: \u0026#34;pkg-1\u0026#34;, 4 version: \u0026#34;1.0.0\u0026#34;, 5 dependencies: { 6 \u0026#34;pkg-2\u0026#34;: \u0026#34;github:example-user/pkg-2#v1.0.0\u0026#34; 7 } 8} 9 10// packages/pkg-2/package.json 11{ 12 name: \u0026#34;pkg-2\u0026#34;, 13 version: \u0026#34;1.0.0\u0026#34; 14} 在上面的例子中，\nlerna bootstrap将正确符号链接pkg-2到pkg-1. lerna publish将在pkg-2更改时更新pkg-1 committish (#v1.0.0) 自述文件徽章 正在使用Lerna？添加一个 README 徽章来展示它：\n1[![lerna](https://img.shields.io/badge/maintained%20with-lerna-cc00ff.svg)](https://lerna.js.org/) ","link":"https://misakaJimmy.github.io/docs/frontend/tools/lerna/","section":"docs","title":"Lerna"},{"body":" 对类的支持 InversifyJS 允许类对其他类的直接依赖。这样做时，您需要使用装饰器 @injectable，但不需要使用装饰器 @inject。\n使用类作为服务标识时不需要 @inject 装饰器。因为编译器能为我们生成的元数据。但是别忘记下面的配置：\n导入 reflect-metadata 在 tsconfig.json 文件中设置 emitDecoratorMetadata 为 true 1import { Container, injectable, inject } from \u0026#34;inversify\u0026#34;; 2 3@injectable() 4class Katana { 5 public hit() { 6 return \u0026#34;cut!\u0026#34;; 7 } 8} 9 10@injectable() 11class Shuriken { 12 public throw() { 13 return \u0026#34;hit!\u0026#34;; 14 } 15} 16 17@injectable() 18class Ninja implements Ninja { 19 20 private _katana: Katana; 21 private _shuriken: Shuriken; 22 23 public constructor(katana: Katana, shuriken: Shuriken) { 24 this._katana = katana; 25 this._shuriken = shuriken; 26 } 27 28 public fight() { return this._katana.hit(); }; 29 public sneak() { return this._shuriken.throw(); }; 30 31} 32 33var container = new Container(); 34container.bind\u0026lt;Ninja\u0026gt;(Ninja).to(Ninja); 35container.bind\u0026lt;Katana\u0026gt;(Katana).to(Katana); 36container.bind\u0026lt;Shuriken\u0026gt;(Shuriken).to(Shuriken); 具体类型绑定自身 如果要解析的类型是具体类型，绑定注册会感到重复和冗长：\n1container.bind\u0026lt;Samurai\u0026gt;(Samurai).to(Samurai); 更好的解决方式是使用 toSelf 方法:\n1container.bind\u0026lt;Samurai\u0026gt;(Samurai).toSelf(); 已知局限性: 类作为标识符和循环依赖 如果在循环依赖中使用类作为标识符会被抛出异常：\nError: Missing required @Inject or @multiinject annotation in: argument 0 in class Dom. 例子:\n1import \u0026#34;reflect-metadata\u0026#34;; 2import { Container, injectable } from \u0026#34;inversify\u0026#34;; 3import getDecorators from \u0026#34;inversify-inject-decorators\u0026#34;; 4 5let container = new Container(); 6let { lazyInject } = getDecorators(container); 7 8@injectable() 9class Dom { 10 public domUi: DomUi; 11 constructor (domUi: DomUi) { 12 this.domUi = domUi; 13 } 14} 15 16@injectable() 17class DomUi { 18 @lazyInject(Dom) public dom: Dom; 19} 20 21@injectable() 22class Test { 23 constructor(dom: Dom) { 24 console.log(dom); 25 } 26} 27 28container.bind\u0026lt;Dom\u0026gt;(Dom).toSelf().inSingletonScope(); 29container.bind\u0026lt;DomUi\u0026gt;(DomUi).toSelf().inSingletonScope(); 30const dom = container.resolve(Test); // Error! 这个错误可能有点误导，因为当使用类作为服务标识，@inject 等注解不需要使用，如果我们添加 @inject(Dom) 或 @inject(DomUi) 的注解，依然会抛出相同的异常。因为装饰器被调用的时候，类还没有被声明，所以装饰器被调用为 @inject(undefined)，导致 InversifyJS 认为对应的注解没有被添加。\n解决办法是使用 Symbol，比如 Symbol.for(\u0026quot;Dom\u0026quot;) 作为服务标识而不是 Dom 这样的类 :\n","link":"https://misakaJimmy.github.io/docs/frontend/inversifyjs/classes-as-id/","section":"docs","title":"对类的支持"},{"body":" Symbol 原文链接：developer.mozilla.org symbol 是一种基本数据类型 （primitive data type）。Symbol()函数会返回symbol类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：\u0026quot;new Symbol()\u0026quot;。\n语法 1Symbol([description]) 参数 description 可选 可选的，字符串类型。对symbol的描述，可用于调试但不是访问symbol本身。\n描述 直接使用Symbol()创建新的symbol类型，并用一个可选的字符串作为其描述。\n1var sym1 = Symbol(); 2var sym2 = Symbol(\u0026#39;foo\u0026#39;); 3var sym3 = Symbol(\u0026#39;foo\u0026#39;); 上面的代码创建了三个新的symbol类型。 注意，Symbol(\u0026quot;foo\u0026quot;) 不会强制将字符串 “foo” 转换成symbol类型。它每次都会创建一个新的 symbol类型：\n1Symbol(\u0026#34;foo\u0026#34;) === Symbol(\u0026#34;foo\u0026#34;); // false 下面带有 new 运算符的语法将抛出 TypeError 错误：\n1var sym = new Symbol(); // TypeError 这会阻止创建一个显式的 Symbol 包装器对象而不是一个 Symbol 值。围绕原始数据类型创建一个显式包装器对象从 ECMAScript 6 开始不再被支持。 然而，现有的原始包装器对象，如 new Boolean、new String以及new Number，因为遗留原因仍可被创建。\n如果你真的想创建一个 Symbol 包装器对象 (Symbol wrapper object)，你可以使用 Object() 函数：\n1var sym = Symbol(\u0026#34;foo\u0026#34;); 2typeof sym; // \u0026#34;symbol\u0026#34; 3var symObj = Object(sym); 4typeof symObj; // \u0026#34;object\u0026#34; 全局共享的 Symbol 上面使用Symbol() 函数的语法，不会在你的整个代码库中创建一个可用的全局的symbol类型。 要创建跨文件可用的symbol，甚至跨域（每个都有它自己的全局作用域） , 使用 Symbol.for() 方法和 Symbol.keyFor() 方法从全局的symbol注册表设置和取得symbol。\n在对象中查找 Symbol 属性 Object.getOwnPropertySymbols() 方法让你在查找一个给定对象的符号属性时返回一个symbol类型的数组。注意，每个初始化的对象都是没有自己的symbol属性的，因此这个数组可能为空，除非你已经在对象上设置了symbol属性。\n属性 ","link":"https://misakaJimmy.github.io/docs/frontend/basic/symbol/","section":"docs","title":"Symbol"},{"body":" install docker-compose v2 官方 github\n1wget https://github.com/docker/compose-cli/releases/download/v2.0.0-beta.6/docker-compose-linux-amd64 2sudo chmod a+x ./docker-compose-linux-amd64 3mkdir ~/.docker/cli-plugins 4sudo mv ./docker-compose-linux-amd64 ~/.docker/cli-plugins/docker-compose ","link":"https://misakaJimmy.github.io/docs/linux/docker/install-docker-compose-v2/","section":"docs","title":""},{"body":"","link":"https://misakaJimmy.github.io/categories/","section":"categories","title":"Categories"},{"body":" MisakaJimmy'S Lifelong Learning. Whether pursuing personal interests and passions or chasing professional ambitions, lifelong learning can help us to achieve personal fulfillment and satisfaction.\nStart Learning\n","link":"https://misakaJimmy.github.io/","section":"","title":"MisakaJimmy Blog"},{"body":" Node-gyp 与 Node Headers 原理解析 在进行 VSCode 插件开发、LSP 服务开发或涉及本地能力扩展时，经常会遇到 node-gyp。很多人只知道“它会编译东西”，但不清楚它到底做什么。\n本文从工程视角讲清楚：\nnode-gyp 是什么 node headers 是什么 它们在实际项目中的作用 为什么国内经常安装失败 在 IDE / 工具链场景下的实际意义 一句话解释 node-gyp：用于编译 Node.js C++ 原生扩展的构建工具 node headers：编译原生扩展时所需的 Node.js C/C++ 接口声明文件 1. 为什么需要 node-gyp？ Node.js 底层是 C++（基于 V8 引擎）。\n大部分 npm 包是 JavaScript 编写的，但某些对性能要求较高的模块使用 C++ 编写，例如：\n数据库驱动 加密库 图像处理库 本地文件系统增强模块 高性能 AST 解析库 终端模拟（如 node-pty） 这些模块需要：\n将 C++ 代码编译为 Node 可加载的二进制模块（.node 文件）\nnode-gyp 就是完成这个编译过程的工具。\n2. node-gyp 实际做了什么？ node-gyp 的核心工作流程：\n读取项目中的 binding.gyp 调用 Python 和系统 C++ 编译器 链接 Node.js 运行时接口 生成 .node 二进制文件 生成的文件类似：\n1build/Release/xxx.node 在 JavaScript 中可以这样加载：\n1require(\u0026#39;./build/Release/xxx.node\u0026#39;) 3. 什么是 Node Headers？ 在编写 C++ 扩展时，代码通常包含：\n1#include \u0026lt;node.h\u0026gt; 2#include \u0026lt;v8.h\u0026gt; 这些头文件并不是系统自带的，而是：\n对应 Node.js 版本的 C/C++ 接口声明文件\n每个 Node 版本都有对应的 headers，例如：\n1node-v20.x.x-headers.tar.gz node-gyp 在编译前会自动下载当前 Node 版本的 headers。\n如果版本不匹配，编译会失败。\n4. 为什么国内经常卡在下载阶段？ 默认下载地址是：\n1https://nodejs.org/dist/ 在国内网络环境下访问较慢，因此常见报错：\n1There appears to be trouble with your network connection 解决方法是配置镜像：\n1npm config set registry https://registry.npmmirror.com 2npm config set disturl https://npmmirror.com/mirrors/node 5. 在 IDE / 工具链场景中的典型应用 在 AI IDE 或 DevTool 开发中，常见会触发 node-gyp 的模块包括：\nsqlite3 better-sqlite3 sharp node-pty 某些本地 embedding 库 例如：\nIDE 内嵌终端通常依赖 node-pty 本地代码索引可能依赖 sqlite 高性能文本处理可能依赖 native 扩展 因此在开发 VSCode 插件或 LSP 时，理解 node-gyp 是有实际意义的。\n6. 未来在 AI IDE 中的潜在价值 在构建 AI IDE 或大型开发工具时，可能涉及：\n高性能代码索引 本地 embedding 增量解析器 AST 加速 大文件处理 这些场景往往需要 native 扩展。\n理解 node-gyp 有助于：\n解决安装问题 分析构建失败原因 理解 Node 扩展运行机制 做性能层面的工程决策 总结 名称 作用 node-gyp 编译 Node.js C++ 原生扩展 node headers 提供 Node C/C++ 接口声明 .node 文件 编译后的二进制动态库 ","link":"https://misakaJimmy.github.io/docs/frontend/tools/node-gyp/","section":"docs","title":"Node-gyp 与 Node Headers 原理解析"},{"body":"","link":"https://misakaJimmy.github.io/tags/","section":"tags","title":"Tags"}]