[{"body":"前端学习笔记\n","link":"https://misakaJimmy.github.io/docs/frontend/","title":"Frontend"},{"body":"什么是终身学习？ 终身学习是一种以个人发展为重点的自发教育形式。虽然终身学习没有标准化的定义，但它通常是指发生在正规教育机构之外的学习，例如学校、大学或企业培训。\r\r然而，终身学习并不一定限于非正式学习。最好将其描述为以实现个人成就为目的的自愿。实现这一目标的手段可能会导致非正式或正式的教育。\n终身学习的重要性 无论是追求个人兴趣和激情，还是追求职业抱负，终身学习都可以帮助我们实现个人成就感和满足感。\n它承认人类有探索、学习和成长的自然动力，并鼓励我们通过关注激发我们灵感的想法和目标来提高我们自己的生活质量和自我价值感。\n我们都是终身学习者 但是个人成就感是什么意思呢？\n现实情况是，我们大多数人在正规学校教育和工作之外都有目标或兴趣。这就是作为人类的一部分含义：我们有天生的好奇心，我们是天生的学习者。我们的发展和成长得益于我们的学习能力。\n终身学习认识到并非我们所有的学习都来自课堂。\n 例如，在童年时期，我们学习说话或骑自行车。 作为成年人，我们学习如何使用智能手机或学习如何烹饪新菜。  这些是我们每天通过社交、反复试验或自发学习进行的日常终身学习的例子。\n个人成就和发展是指引导我们学习新事物的自然兴趣、好奇心和动机。我们为自己学习，而不是为别人学习。\n终身学习的关键清单  自主性 自我激励或自我发起 并不总是需要成本 通常是非正式的 自学或寻求指导 动机是出于个人兴趣或个人发展  终身学习的例子 以下是您可以参与的一些终身学习计划类型：\n 培养新技能（例如缝纫、烹饪、编程、公开演讲等） 自学学习（例如学习一门新语言、研究感兴趣的话题、订阅播客等） 学习一项新的运动或活动（例如参加武术、学习滑雪、学习锻炼等） 学习使用新技术（智能设备、新软件应用程序等） 获取新知识（通过在线教育或课堂课程学习自学课程）  终身学习的好处 将终身学习融入您的生活可以带来许多长期利益，包括：\n1. 新的自我激励 有时，我们在做某事时会陷入常规，仅仅是因为我们必须这样做，例如去上班或打扫房子。\n弄清楚是什么激发了你的灵感，让你重新回到驾驶座上，并提醒你在生活中你真的可以做你想做的事情。\n2. 认同个人兴趣和目标 重新点燃让你成为一个人的东西，减少无聊，让生活更有趣，甚至可以打开未来的机会。\n如果你专注于它们，你永远不知道你的兴趣会把你带到哪里。\n3. 其他个人和专业技能的提高 在我们忙于学习新技能或获取新知识的同时，我们也在培养其他有价值的技能，这些技能可以在我们的个人和职业生活中为我们提供帮助。\n这是因为我们利用其他技能来学习新事物。例如，学习缝纫需要解决问题。学习绘画涉及培养创造力。\n技能发展可以包括人际交往能力、创造力、解决问题的能力、批判性思维、领导力、反思、适应能力等等。\n4. 增强自信心 在某些方面变得更有知识或技能可以增加我们在个人和职业生活中的自信心。\n 在我们的个人生活中，这种自信可以源于投入时间和精力学习和提高的满足感，给我们一种成就感。 在我们的职业生涯中，这种自信可以是我们对自己的知识和应用所学知识的能力的信任感。  我需要积极主动地进行终身学习吗？ 大多数人会在日常生活中的某个时刻通过与他人交谈、根据个人兴趣浏览互联网、阅读报纸或参与个人兴趣来学习新东西。\n但是，如果出于个人、家庭或职业原因，更加努力地学习新事物很重要，或者需要一个更有条理的结构，那么这里有一些开始的步骤。\n如何在生活中采用终身学习？ 1. 认清自己的个人兴趣和目标 终身学习是关于你自己，而不是其他人以及他们想要什么。反思你对什么充满热情以及你对自己未来的展望。\n如果职业发展是您的个人兴趣，那么有多种方法可以参与自主学习来实现这一目标。如果学习历史是您的热情，那么同样有其他方法可以进一步探索这种兴趣。\n2. 列出你想学习或能够做的事情 一旦你确定了是什么激励了你，探索你想要实现的特定兴趣或目标是什么。\n回到我们对历史充满热情的例子，也许只是希望扩大对欧洲历史的了解。或者也许兴趣如此强烈以至于攻读博士学位。是梦想的目标。\n这两者都是不同的兴趣水平，需要不同的学习方式。\n3. 确定您想如何参与以及可用的资源 实现我们的个人目标首先要弄清楚如何开始。\n研究和阅读兴趣和目标可以帮助制定如何去学习它。\n以我们的历史为例：只想了解更多特定历史时期的人可以在图书馆目录、博客、杂志和播客中找到专门针对该主题的书籍，甚至博物馆和讲座。\n想要获得博士学位的个人。在历史上，个人目标可以研究可以兼职或在线完成的大学课程，以及达到博士学位所需的步骤。\n4. 将学习目标融入你的生活 在忙碌的生活中制定新的学习目标需要考虑和努力。如果你不为它腾出时间和空间，它就不会发生。\n它很容易导致气馁或完全放弃学习计划。\n计划新学习计划的要求如何融入您的生活，或者您需要做些什么来使其适应。例如，如果学习一门新语言是学习目标，你能每天抽出一小时的时间吗？还是每天 15 分钟听起来更现实？\n了解您可以为学习目标投入的时间和空间可以帮助您长期坚持目标。\n5. 做出承诺 做出参与新学习计划的决定是最后也是最重要的一步。如果您设定了切合实际的期望并有自我激励来实现它，那么请致力于它并避免找借口。\n","link":"https://misakaJimmy.github.io/docs/","title":"Lifelong Learning"},{"body":"1docker pull bitnami/postgresql:12 docker-compose 1version:\u0026#39;3.5\u0026#39;23services:4postgres:5container_name:postgres_container6image:postgres7environment:8POSTGRES_USER:postgres9POSTGRES_PASSWORD:password10PGDATA:/data/postgres11volumes:12- postgres:/data/postgres13ports:14- \u0026#34;5432:5432\u0026#34;15networks:16- postgres17restart:unless-stopped1819pgadmin:20container_name:pgadmin_container21image:dpage/pgadmin422environment:23PGADMIN_DEFAULT_EMAIL:misakajimmy@gmail.com24PGADMIN_DEFAULT_PASSWORD:admin25PGADMIN_CONFIG_SERVER_MODE:\u0026#39;False\u0026#39;26volumes:27- pgadmin:/root/.pgadmin2829ports:30- \u0026#34;3080:80\u0026#34;31networks:32- postgres33restart:unless-stopped3435networks:36postgres:37driver:bridge3839volumes:40postgres:41pgadmin:","link":"https://misakaJimmy.github.io/docs/database/postgresql/postgresql-docker/","title":"PostgreSQL Docker 启动"},{"body":"","link":"https://misakaJimmy.github.io/docs/frontend/tools/","title":"前端常用工具链"},{"body":"数据库笔记\n","link":"https://misakaJimmy.github.io/docs/database/","title":"DataBase"},{"body":"直接官网下载安装，安装时记得记下安装路径。\n根目录如下图所示，bin下是 PostgreSQL 的命令行控制程序，pgAdmin4 下是 PostpreSQL 的可视化管理程序。\n添加 bin 到环境变量之中 记下到 bin 文件夹的绝对路径， 我这里是 D:\\Program Files\\PostgreSQL\\12\\bin ，添加到系统变量和用户变量的 Path 之中。\n然后打开 Terminal ，输入\n1pg_ctl.exe start -D \u0026#34;D:\\Program Files\\PostgreSQL\\12\\data\u0026#34; 然后打开 pgAdmin ， 输入 host 和 Password 。\n角色 \u0026quot;postgres\u0026quot; 不存在 Terminal 中出现角色不存在，导致无法正常连接到postgre服务。\n使用管理员权限打开 Powershell ， 输入\n1 pg_ctl.exe register -N \u0026#34;pgsql\u0026#34; -D \u0026#34;D:\\Program Files\\PostgreSQL\\12\\data\u0026#34; 将 postgresql 注册为服务\n","link":"https://misakaJimmy.github.io/docs/database/postgresql/windows-postgresql-usage/","title":"Windows PostgreSQL 使用"},{"body":"","link":"https://misakaJimmy.github.io/docs/frontend/basic/","title":"前端基础"},{"body":"一个强大又轻量的控制反转容器，提供给JavaScript 和 Node.js 应用使用，使用TypeScript编写。\n简介 nversifyJS 是一个轻量的 (4KB) 控制反转容器 (IoC)，可用于编写 TypeScript 和 JavaScript 应用。 它使用类构造函数去定义和注入它的依赖。InversifyJS API 很友好易懂, 鼓励对 OOP 和 IoC 最佳实践的应用.\n为什么要有 InversifyJS? JavaScript 现在支持面向对象编程，基于类的继承。 这些特性不错但事实上它们也是 危险的。 我们需要一个优秀的面向对象设计（比如 SOLID，Composite Reuse等）来保护我们避免这些威胁。然而，面向对象的设计是复杂的，所以我们创建了 InversifyJS。\nInversifyJS 是一个工具，它能帮助 JavaScript 开发者，写出出色的面向对象设计的代码。\n目标 InversifyJS有4个主要目标:\n  允许JavaScript开发人员编写遵循 SOLID 原则的代码。\n  促进并鼓励遵守最佳的面向对象编程和依赖注入实践。\n  尽可能少的运行时开销。\n  提供艺术编程体验和生态。\n  为什么要写这篇笔记 最近的项目中大量的运用到了 InversifyJS 所以有一些学习感悟心得想记录一下，本篇笔记大体上是基于 https://doc.inversify.cloud/zh_cn/ 这份中文文档来写的，比起原文档 API 字典式的记录 InversifyJS 的使用方法，本篇笔记更多的是主观的的记录自己的学习心得，以供自己以后回顾以及大家共同学习讨论。\n","link":"https://misakaJimmy.github.io/docs/frontend/inversifyjs/","title":"InversifyJS"},{"body":"","link":"https://misakaJimmy.github.io/docs/database/postgresql/","title":"PostgreSQL"},{"body":"安装 可以通过 npm 或者 yarn 来引入 InversifyJS：\n1yarn add inversify reflect-metadata \rInversifyJS 类型定义包含在 inversify npm 包中。InversifyJS 需要 experimentalDecorators、 emitDecoratorMetadata 和 lib 编译选项开启在 tsconfig.json 文件中。\r\r1{ 2 \u0026#34;compilerOptions\u0026#34;: { 3 \u0026#34;experimentalDecorators\u0026#34;: true, 4 \u0026#34;emitDecoratorMetadata\u0026#34;: true 5 } 6} InversifyJS 需要一个支持下面特性的现代 JavaScript 引擎：\n Reflect metadata Promise (仅在使用 provider injection 时需要) Proxy (仅在使用 activation handlers 时需要)  如果你的环境不支持其中的特性，那么需要引入 shim 或者 polyfill。\n环境支持和 polyfills InversifyJS 需要一个现代的 JavaScript 引擎，需要支持 Promise、 Map、 Metadata Reflection API 和 Proxy 对象。 如果你的环境不支持这些的化，就需要引入 shim 或者 polyfill。\nMetadata Reflection API reflect-metadata polyfill 仅在进入应用时需要引入一次，因为反射对象是一个全局单例。更多详情参见这里。\r\r始终需要。使用 reflect-metadata 作为 polyfill。\n1yarn install reflect-metadata reflect-metadata 的类型定义已在 npm 包中被包含。你需要添加如下引用到 tsconfig.json 中的类型字段：\n1{ 2 \u0026#34;compilerOptions\u0026#34;: { 3 \u0026#34;types\u0026#34;: [\u0026#34;reflect-metadata\u0026#34;] 4 } 5} 最后，引入 reflect-metadata。如果你使用：\n1import \u0026#34;reflect-metadata\u0026#34;; 如果你在使用网页浏览器那么可以使用 script 标签：\n1\u0026lt;script src=\u0026#34;./node_modules/reflect-metadata/Reflect.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 这将创建全局反射对象。\nMap Map 在使用 InversifyJS 3 或者更高版本时需要。\n大多数现代 JavaScript 引擎支持 map，但如果你需要支持旧浏览器，那么需要使用 map polyfill (比如 es6-map)。\nPromise Promise 仅在使用 注入提供者 时需要。\n多数现代 JavaScript 引擎支持 promise，但如果你需要支持就浏览器，那么需要使用 promise polyfill (比如 es6-promise 或者 bluebird)。\n","link":"https://misakaJimmy.github.io/docs/frontend/inversifyjs/install/","title":"项目中引入 InversifyJS"},{"body":"\r代码解析 1import * as inversify from \u0026#39;inversify\u0026#39;; 2import \u0026#39;reflect-metadata\u0026#39;; 引入 inversify 以及 reflect-metadata 两个包。\n1const TYPES = { 2 // 忍者 3 Ninja: \u0026#39;Ninja\u0026#39;, 4 // 武士刀 5 Katana: \u0026#39;Katana\u0026#39;, 6 // 手里剑 7 Shuriken: \u0026#39;Shuriken\u0026#39; 8} 定义了类对应的映射，这里定义了三个类，看过火影的应该很容易理解Ninja(忍者)、Katana(武士刀)和Shuriken(手里剑)之间的关系。\n1class Katana { 2 hit() { 3 return \u0026#39;cut!\u0026#39;; 4 } 5} 6 7class Shuriken { 8 throw() { 9 return \u0026#39;hit!\u0026#39;; 10 } 11} 12 13class Ninja { 14 private _katana: Katana; 15 private _shuriken: Shuriken; 16 17 constructor(katana: Katana, shuriken: Shuriken) { 18 this._katana = katana; 19 this._shuriken = shuriken; 20 } 21 22 fight() { 23 return this._katana.hit(); 24 } 25 26 sneak() { 27 return this._shuriken.throw(); 28 } 29} 接着是Ninja(忍者)、Katana(武士刀)和Shuriken(手里剑)三个类的实现。其中 Katana 类实现了 hit 方法，Shuriken 实现了 throw 方法，Ninja 中定义了两个私有对象 _katana 和 _shuriken，并在构造函数之中传入这个两个对象，Ninja 类中的 fight 方法中将调用 _katana 的 hit 方法，sneak 方法中将调用 _shuriken 的 throw 方法。\n1// 声明可被注入以及其依赖项 2inversify.decorate(inversify.injectable(), Katana); 3inversify.decorate(inversify.injectable(), Shuriken); 4inversify.decorate(inversify.injectable(), Ninja); 5inversify.decorate(inversify.inject(TYPES.Katana), Ninja, 0); 6inversify.decorate(inversify.inject(TYPES.Shuriken), Ninja, 1); 7 8// 声明绑定关系 9const container = new inversify.Container(); 10container.bind(TYPES.Ninja).to(Ninja); 11container.bind(TYPES.Katana).to(Katana); 12container.bind(TYPES.Shuriken).to(Shuriken); //@TODO\n这里终于引入了依赖注入的概念，这里使用了 decorate 来将 Katana、Shuriken和Ninja\n","link":"https://misakaJimmy.github.io/docs/frontend/inversifyjs/base-ts-example/","title":"InversifyJS 基础演示(TS)"},{"body":"安装yarn 下载 nodejs 通过 npm 安装 1npm install -g yarn 查看版本 1yarn --version 设置淘宝源 1yarn config set registry https://registry.npm.taobao.org 2yarn config set sass_binary_site https://npm.taobao.org/mirrors/node-sass # node-sass 二进制包镜像 3yarn config set electron_mirror https://npm.taobao.org/mirrors/electron/ # electron 二进制包镜像 4yarn config set ELECTRON_MIRROR https://cdn.npm.taobao.org/dist/electron/ # electron 二进制包镜像 5yarn config set puppeteer_download_host https://npm.taobao.org/mirrors # puppeteer 二进制包镜像 6yarn config set chromedriver_cdnurl https://npm.taobao.org/mirrors/chromedriver # chromedriver 二进制包镜像 7yarn config set operadriver_cdnurl https://npm.taobao.org/mirrors/operadriver # operadriver 二进制包镜像 8yarn config set phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs # phantomjs 二进制包镜像 9yarn config set selenium_cdnurl https://npm.taobao.org/mirrors/selenium # selenium 二进制包镜像 10yarn config set node_inspector_cdnurl https://npm.taobao.org/mirrors/node-inspector # node-inspector 二进制包镜像 yarn 与 npm 命令对比    npm yarn 注释     npm init yarn init 初始化项目   npm install yarn 安装全部依赖   npm install react --save yarn add react 安装某个依赖，保存到 dependencies   npm uninstall react --save yarn remove react 移除某个依赖   npm install react --save-dev yarn add react --dev 安装某依赖,保存到 devDependencies   npm update [package] --save yarn upgrade [package] 更新生产环境某个依赖包   npm install axios --global yarn global add axios 全局安装某个依赖   npm install --save axios vue-axios yarn add axios vue-axios 同时下载多个依赖包   npm install [package]@[version] yarn add [package]@[version] 安装指定版本的包   npm rebuild yarn install --force 重新下载所有包    npm --save 和 npm --save-dev 区别 npm5版本之前，必须要加上--save，才会将包记录到package.json npm5版本之后开始，--save是默认值了，可以省略不写\n--save 简写 -S 会被记录到dependencies【生产环境】\n   npm 等同 yarn     npm i jquery // npm i jquery --save = yarn add jquery   npm i jquery -S = yarn add jquery -S // yarn 只有简写    --save-dev 简写 -D 会被记录到devDependencies【开发环境】\n   npm 等同 yarn     npm i webpack -D // npm i webpack --save-dev = yarn add webpack -D // yarn 只有简写    dependencies:项目依赖，项目实际运行需要的依赖，上线还是需要的，如（vue，jquery） devDependencies:开发依赖，只在开发时需要的依赖，实际上线不需要的，如（webpack）\r\ryarn对比npm的优点  离线模式  yarn会有一个缓存目录，会缓存以前安装过的软件包，再次安装时就不必从网络下载了，大大加速安装速度。\n依赖关系确定性  在每一台机器上针对同一个工程安装依赖时，生成的依赖关系顺序和版本是一致的。\n网络性能优化  下载软件时会优化请求顺序，避免请求瀑布发生。\n网络回弹  yarn在某个安装包请求失败时不会导致安装失败，它会自动去尝试重新安装。而npm则会毫不犹豫的失败，导致得再来一次，耗费时间。\n多注册来源  所有的依赖包，不管他被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是 npm 要么是 bower, 防止出现混乱不一致。\n扁平模式  对于多个包依赖同一个子包的情况，yarn会尽量提取为同一个包，防止出现多处副本，浪费空间。比如1.2中，yarn会为babel-generator和babel-helper-define-map 创建同一个lodash子依赖，这样就节约一份的空间。\n","link":"https://misakaJimmy.github.io/docs/frontend/tools/yarn/","title":"Yarn"},{"body":"\r项目链接：github.com/lerna/lerna\r\rLerna 是一个管理工具，用于管理包含多个软件包（package）的 JavaScript 项目。\n关于 将大型代码仓库分割成多个独立版本化的 软件包（package）对于代码共享来说非常有用。但是，如果某些更改 跨越了多个代码仓库的话将变得很 麻烦 并且难以跟踪，并且， 跨越多个代码仓库的测试将迅速变得非常复杂。\n为了解决这些（以及许多其它）问题，某些项目会将 代码仓库分割成多个软件包（package），并将每个软件包存放到独立的代码仓库中。但是，例如 Babel, React, Angular, Ember, Meteor, Jest, 等项目以及许多其他项目则是在 一个代码仓库中包含了多个软件包（package）并进行开发。\nLerna is a tool that optimizes the workflow around managing multi-package repositories with git and npm.\nLerna 还可以减少开发和构建环境中大量包副本的时间和空间需求——这通常是将项目分成许多单独的 NPM 包的缺点。有关详细信息，请参阅 hoist documentation。\nLerna repo 是什么样的？ 它实际上很简单。您的文件结构如下所示：\n1my-lerna-repo/ 2 package.json 3 packages/ 4 package-1/ 5 package.json 6 package-2/ 7 package.json Lerna 能做什么？ Lerna 中的两个主要命令是 lerna bootstrap 和 lerna publish。\nbootstrap 将 repo 中的依赖项链接在一起。 publish 将帮助发布任何更新的包。\nLerna 不能做什么？ Lerna 不是 serverless monorepos 的部署工具。Hoisting 可能与传统的无服务器 monorepo 部署技术不兼容。\n入门 本着用新不用旧的原则，本文像官方文档学习，使用 Lerna 3.0。\n比起npm作者偏爱用yarn，如果不喜欢yarn的可以参考 yarn 与 npm 命令对比\n\r推荐全局安装 Lerna\n1yarn add -g lerna 接下来，我们将创建一个新的 git 代码仓库：\n1git init lerna-repo \u0026amp;\u0026amp; cd lerna-repo 现在，我们将上述仓库转变为一个 Lerna 仓库：\n1lerna init 这将创建一个lerna.json配置文件和一个packages文件夹，因此您的文件夹现在应如下所示：\n1lerna-repo/ 2 packages/ 3 package.json 4 lerna.json 如何使用Lerna Lerna 允许您使用以下两种模式之一来管理您的项目：Fixed 或 Independent。\nFixed/Locked 模式 (default) Fixed模式 Lerna 项目在单个版本行上运行。版本保存在lerna.json项目根目录下的文件中version。当你运行时lerna publish，如果一个模块自上次发布以来已经更新，它将更新到你发布的新版本。这意味着您只在需要时发布新版本的包。\n注意：如果您的主要版本为零，则所有更新都被认为是破坏性的。因此，lerna publish使用主要版本零运行并选择任何非预发布版本号将导致为所有包发布新版本，即使自上次发布以来并非所有包都已更改。\r\r这是Babel当前使用的模式。如果您想自动将所有包版本绑定在一起，请使用此选项。这种方法的一个问题是，任何包的重大变化都会导致所有包都有一个新的主要版本。\nIndependent 模式 lerna init --independent\n独立模式 Lerna 项目允许维护人员彼此独立地增加包版本。每次发布时，您都会收到有关已更改的每个包的提示，以指定它是补丁、次要、主要还是自定义更改。\n独立模式允许您更具体地更新每个包的版本，并且对一组组件有意义。将此模式与语义释放之类的东西结合起来会减轻痛苦。（atlassian/lerna-semantic-release已经有这方面的工作）。\n将lerna.json中的version设置为independent以运行Independent模式。\r\r基本概念 Lerna在运行命令时遇到错误会记录到一个lerna-debug.log文件（与 npm-debug.log 相同）。\nLerna 还支持scoped packages。\nlerna.json 1{ 2 \u0026#34;version\u0026#34;: \u0026#34;1.1.3\u0026#34;, 3 \u0026#34;npmClient\u0026#34;: \u0026#34;yarn\u0026#34;, 4 \u0026#34;command\u0026#34;: { 5 \u0026#34;publish\u0026#34;: { 6 \u0026#34;ignoreChanges\u0026#34;: [\u0026#34;ignored-file\u0026#34;, \u0026#34;*.md\u0026#34;], 7 \u0026#34;message\u0026#34;: \u0026#34;chore(release): publish\u0026#34;, 8 \u0026#34;registry\u0026#34;: \u0026#34;https://npm.pkg.github.com\u0026#34; 9 }, 10 \u0026#34;bootstrap\u0026#34;: { 11 \u0026#34;ignore\u0026#34;: \u0026#34;component-*\u0026#34;, 12 \u0026#34;npmClientArgs\u0026#34;: [\u0026#34;--no-package-lock\u0026#34;] 13 } 14 }, 15 \u0026#34;packages\u0026#34;: [\u0026#34;packages/*\u0026#34;] 16}  version: 存储库的当前版本 npmClient: 用于指定特定客户端以运行命令的选项（也可以在每个命令的基础上指定）。更改为\u0026quot;yarn\u0026quot;使用 yarn 运行所有命令。默认为“npm” command.publish.ignoreChanges: 不包含在lerna changed/publish. 使用它来防止不必要地发布新版本以进行更改，例如修复README.md错字 command.publish.message: 执行版本更新以进行发布时的自定义提交消息。有关更多详细信息，请参阅@lerna/version command.publish.registry: 使用它来设置要发布到的自定义注册表 url 而不是 npmjs.org，如果需要，您必须已经过身份验证 command.bootstrap.ignore: lerna bootstrap 运行命令时不会引导的 glob 数组 command.bootstrap.npmClientArgs: 在 lerna bootstrap 运行时将传递到 npm install 的数据 command.bootstrap.scope: 一个用于 lerna bootstrap 运行时，限制在运行命令时将引导哪些包的一个 glob 数组 packages: 用作包位置的 glob 数组  配置文件lerna.json中的packages字段一个 glob 数组用来匹配拥有package.json的文件夹，这是 lerna 识别\u0026quot;子\u0026quot;包的方式（相对于项目\u0026quot;根\u0026quot;目录 package.json，它旨在管理整个 repo 的开发依赖项和脚本）。\n默认情况下，lerna 将包列表初始化为[\u0026quot;packages/*\u0026quot;]，但您也可以使用其他目录，例如[\u0026quot;modules/*\u0026quot;], 或[\u0026quot;package1\u0026quot;, \u0026quot;package2\u0026quot;]. 定义的 glob 与所在的目录相关，lerna.json通常是存储库根目录。唯一的限制是您不能直接嵌套包位置，但这也是“普通”npm 包共享的限制。\n例如，[\u0026quot;packages/*\u0026quot;, \u0026quot;src/**\u0026quot;]匹配这棵树：\n1packages/ 2├── foo-pkg 3│ └── package.json 4├── bar-pkg 5│ └── package.json 6├── baz-pkg 7│ └── package.json 8└── qux-pkg 9 └── package.json 10src/ 11├── admin 12│ ├── my-app 13│ │ └── package.json 14│ ├── stuff 15│ │ └── package.json 16│ └── things 17│ └── package.json 18├── profile 19│ └── more-things 20│ └── package.json 21├── property 22│ ├── more-stuff 23│ │ └── package.json 24│ └── other-things 25│ └── package.json 26└── upload 27 └── other-stuff 28 └── package.json 在下面定位叶子包packages/*被认为是“最佳实践”，但不是使用 Lerna 的要求。\n废弃字段 有些lerna.json字段不再使用。值得注意的包括：\n lerna: 最初用于表示 Lerna 的当前版本。在 v3 中 过时 并且 删除  常见的devDependencies 大多数devDependencies可以拉到 Lerna repo 的根目录lerna link convert\n上述命令将自动 hoist things 并使用相关 file: 说明符。\nHoisting 有几个好处：\n 所有包都使用相同版本的给定依赖项 可以使用Snyk等自动化工具使根目录中的依赖项保持最新 减少依赖安装时间 需要更少的存储空间  请注意，devDependencies提供 npm 脚本使用的“二进制”可执行文件仍然需要直接安装在使用它们的每个包中。\n例如，在这种情况下，为了 lerna run nsp（以及在包的目录中 npm run nsp）正常工作，nsp依赖项是必需的：\n1{ 2 \u0026#34;scripts\u0026#34;: { 3 \u0026#34;nsp\u0026#34;: \u0026#34;nsp\u0026#34; 4 }, 5 \u0026#34;devDependencies\u0026#34;: { 6 \u0026#34;nsp\u0026#34;: \u0026#34;^2.3.3\u0026#34; 7 } 8} Git 托管的依赖项 Lerna 允许将本地依赖包的目标版本编写为带有（例如#committish#v1.0.0或#semver:^1.0.0 ）的git 远程 url ，而不是正常的数字版本范围。当包必须是私有的并且不需要私有 npm 注册表时，这允许通过 git 存储库分发包。\n请注意，lerna 不会将git 历史记录实际拆分为单独的只读存储库。这是用户的责任。\n1// packages/pkg-1/package.json 2{ 3 name: \u0026#34;pkg-1\u0026#34;, 4 version: \u0026#34;1.0.0\u0026#34;, 5 dependencies: { 6 \u0026#34;pkg-2\u0026#34;: \u0026#34;github:example-user/pkg-2#v1.0.0\u0026#34; 7 } 8} 9 10// packages/pkg-2/package.json 11{ 12 name: \u0026#34;pkg-2\u0026#34;, 13 version: \u0026#34;1.0.0\u0026#34; 14} 在上面的例子中，\n lerna bootstrap将正确符号链接pkg-2到pkg-1. lerna publish将在pkg-2更改时更新pkg-1 committish (#v1.0.0)  自述文件徽章 正在使用Lerna？添加一个 README 徽章来展示它：\n1[![lerna](https://img.shields.io/badge/maintained%20with-lerna-cc00ff.svg)](https://lerna.js.org/) ","link":"https://misakaJimmy.github.io/docs/frontend/tools/lerna/","title":"Lerna"},{"body":"对类的支持 InversifyJS 允许类对其他类的直接依赖。这样做时，您需要使用装饰器 @injectable，但不需要使用装饰器 @inject。\n使用类作为服务标识时不需要 @inject 装饰器。因为编译器能为我们生成的元数据。但是别忘记下面的配置：\n 导入 reflect-metadata 在 tsconfig.json 文件中设置 emitDecoratorMetadata 为 true  1import { Container, injectable, inject } from \u0026#34;inversify\u0026#34;; 2 3@injectable() 4class Katana { 5 public hit() { 6 return \u0026#34;cut!\u0026#34;; 7 } 8} 9 10@injectable() 11class Shuriken { 12 public throw() { 13 return \u0026#34;hit!\u0026#34;; 14 } 15} 16 17@injectable() 18class Ninja implements Ninja { 19 20 private _katana: Katana; 21 private _shuriken: Shuriken; 22 23 public constructor(katana: Katana, shuriken: Shuriken) { 24 this._katana = katana; 25 this._shuriken = shuriken; 26 } 27 28 public fight() { return this._katana.hit(); }; 29 public sneak() { return this._shuriken.throw(); }; 30 31} 32 33var container = new Container(); 34container.bind\u0026lt;Ninja\u0026gt;(Ninja).to(Ninja); 35container.bind\u0026lt;Katana\u0026gt;(Katana).to(Katana); 36container.bind\u0026lt;Shuriken\u0026gt;(Shuriken).to(Shuriken); 具体类型绑定自身 如果要解析的类型是具体类型，绑定注册会感到重复和冗长：\n1container.bind\u0026lt;Samurai\u0026gt;(Samurai).to(Samurai); 更好的解决方式是使用 toSelf 方法:\n1container.bind\u0026lt;Samurai\u0026gt;(Samurai).toSelf(); 已知局限性: 类作为标识符和循环依赖 如果在循环依赖中使用类作为标识符会被抛出异常：\nError: Missing required @Inject or @multiinject annotation in: argument 0 in class Dom.\r\r例子:\n1import \u0026#34;reflect-metadata\u0026#34;; 2import { Container, injectable } from \u0026#34;inversify\u0026#34;; 3import getDecorators from \u0026#34;inversify-inject-decorators\u0026#34;; 4 5let container = new Container(); 6let { lazyInject } = getDecorators(container); 7 8@injectable() 9class Dom { 10 public domUi: DomUi; 11 constructor (domUi: DomUi) { 12 this.domUi = domUi; 13 } 14} 15 16@injectable() 17class DomUi { 18 @lazyInject(Dom) public dom: Dom; 19} 20 21@injectable() 22class Test { 23 constructor(dom: Dom) { 24 console.log(dom); 25 } 26} 27 28container.bind\u0026lt;Dom\u0026gt;(Dom).toSelf().inSingletonScope(); 29container.bind\u0026lt;DomUi\u0026gt;(DomUi).toSelf().inSingletonScope(); 30const dom = container.resolve(Test); // Error! 这个错误可能有点误导，因为当使用类作为服务标识，@inject 等注解不需要使用，如果我们添加 @inject(Dom) 或 @inject(DomUi) 的注解，依然会抛出相同的异常。因为装饰器被调用的时候，类还没有被声明，所以装饰器被调用为 @inject(undefined)，导致 InversifyJS 认为对应的注解没有被添加。\n解决办法是使用 Symbol，比如 Symbol.for(\u0026quot;Dom\u0026quot;) 作为服务标识而不是 Dom 这样的类 :\n","link":"https://misakaJimmy.github.io/docs/frontend/inversifyjs/classes-as-id/","title":"对类的支持"},{"body":"Symbol 原文链接：developer.mozilla.org\r\rsymbol 是一种基本数据类型 （primitive data type）。Symbol()函数会返回symbol类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：\u0026quot;new Symbol()\u0026quot;。\n\r语法 1Symbol([description]) 参数  description 可选  可选的，字符串类型。对symbol的描述，可用于调试但不是访问symbol本身。\n描述 直接使用Symbol()创建新的symbol类型，并用一个可选的字符串作为其描述。\n1var sym1 = Symbol(); 2var sym2 = Symbol(\u0026#39;foo\u0026#39;); 3var sym3 = Symbol(\u0026#39;foo\u0026#39;); 上面的代码创建了三个新的symbol类型。 注意，Symbol(\u0026quot;foo\u0026quot;) 不会强制将字符串 “foo” 转换成symbol类型。它每次都会创建一个新的 symbol类型：\n1Symbol(\u0026#34;foo\u0026#34;) === Symbol(\u0026#34;foo\u0026#34;); // false 下面带有 new 运算符的语法将抛出 TypeError 错误：\n1var sym = new Symbol(); // TypeError 这会阻止创建一个显式的 Symbol 包装器对象而不是一个 Symbol 值。围绕原始数据类型创建一个显式包装器对象从 ECMAScript 6 开始不再被支持。 然而，现有的原始包装器对象，如 new Boolean、new String以及new Number，因为遗留原因仍可被创建。\n如果你真的想创建一个 Symbol 包装器对象 (Symbol wrapper object)，你可以使用 Object() 函数：\n1var sym = Symbol(\u0026#34;foo\u0026#34;); 2typeof sym; // \u0026#34;symbol\u0026#34; 3var symObj = Object(sym); 4typeof symObj; // \u0026#34;object\u0026#34; 全局共享的 Symbol 上面使用Symbol() 函数的语法，不会在你的整个代码库中创建一个可用的全局的symbol类型。 要创建跨文件可用的symbol，甚至跨域（每个都有它自己的全局作用域） , 使用 Symbol.for() 方法和 Symbol.keyFor() 方法从全局的symbol注册表设置和取得symbol。\n在对象中查找 Symbol 属性 Object.getOwnPropertySymbols() 方法让你在查找一个给定对象的符号属性时返回一个symbol类型的数组。注意，每个初始化的对象都是没有自己的symbol属性的，因此这个数组可能为空，除非你已经在对象上设置了symbol属性。\n属性 ","link":"https://misakaJimmy.github.io/docs/frontend/basic/symbol/","title":"Symbol"},{"body":"install docker-compose v2 官方 github\n1wget https://github.com/docker/compose-cli/releases/download/v2.0.0-beta.6/docker-compose-linux-amd64 2sudo chmod a+x ./docker-compose-linux-amd64 3mkdir ~/.docker/cli-plugins 4sudo mv ./docker-compose-linux-amd64 ~/.docker/cli-plugins/docker-compose ","link":"https://misakaJimmy.github.io/docs/linux/docker/install-docker-compose-v2/","title":""},{"body":"","link":"https://misakaJimmy.github.io/categories/","title":"Categories"},{"body":"MisakaJimmy'S Lifelong Learning. Whether pursuing personal interests and passions or chasing professional ambitions, lifelong learning can help us to achieve personal fulfillment and satisfaction.\nStart Learning\n\r\r\r","link":"https://misakaJimmy.github.io/","title":"MisakaJimmy Blog"},{"body":"","link":"https://misakaJimmy.github.io/tags/","title":"Tags"}]