[{"body":"前端学习笔记\n","link":"https://misakaJimmy.github.io/docs/frontend/","section":"docs","title":"Frontend"},{"body":" 这一篇算是 InversifyJS 系列的“序章”：不直接从 API 开始，而是\n先聊聊“没有 DI 容器的时候大家是怎么写代码的”、工厂模式是怎么一步步演化成依赖注入的，以及在 Java 生态里这些东西怎么玩，最后再回到为什么 Theia 要在前端世界选 InversifyJS。\n一切从“直接 new 依赖”开始 最原始的写法，大概是这样：\n1class OrderRepository { 2 findById(id: string) { /* ... */ } 3} 4 5class OrderService { 6 private repo = new OrderRepository(); 7 8 getOrder(id: string) { 9 return this.repo.findById(id); 10 } 11} 问题很明显：\nOrderService 紧耦合 到 OrderRepository 的具体实现； 想换成 CachedOrderRepository、RemoteOrderRepository，要改类内部代码； 单元测试时很难注入一个假的 Repository（mock / stub）。 这在小项目里还能忍，一旦项目大了，就会到处是“想改一个依赖，要改一片调用方”的情况。\n手工构造 + 工厂模式：第一步解耦 第一步通常是把构造权从类内部挪到外面：\n1class OrderService { 2 constructor(private repo: OrderRepository) {} 3} 4 5// 由外部代码负责 new 和组装 6const repo = new OrderRepository(); 7const service = new OrderService(repo); 好处：\nOrderService 只依赖抽象（构造参数类型），不关心具体实现； 测试时可以传入 FakeOrderRepository。 再往前走一点，就是工厂模式（Factory）：\n1class ServiceFactory { 2 createOrderService(): OrderService { 3 const repo = new OrderRepository(); 4 return new OrderService(repo); 5 } 6} 7 8const factory = new ServiceFactory(); 9const service = factory.createOrderService(); 工厂模式解决了“把组装逻辑集中起来”的问题，但新的问题是：\n复杂系统里工厂会变成“超级构造函数”，里面写满各种 if/配置分支； 多层依赖关系（A 依赖 B，B 依赖 C）时，工厂代码很快就变成一团。 Java 世界的答案：Spring / Guice / CDI 等 DI 容器 在 Java 生态里，随着应用变复杂（尤其是企业应用），大家基本达成共识：\n光靠手写工厂已经不够了，需要一个“通用的对象装配框架”来管依赖关系。\n几条主线大概是：\nSpring（最出圈的那个）\n通过 XML/注解/Java Config 声明 Bean 以及它们的依赖； IoC 容器负责扫描、实例化、注入、生命周期管理； 开发者主要关注“有哪些 Bean/Service，依赖什么”，而不是“怎么 new”。 Guice（Google 出的轻量 DI 框架）\n使用 Java 注解（@Inject 等）+ 模块配置类注册绑定； 更偏代码配置，少一点 XML/约定魔法。 两者虽然风格不同，但核心理念是一致的：\n你声明“某个抽象（接口/类）对应哪个实现”； 容器帮你自动 new 出带好依赖的对象（构造函数注入、字段注入等）； 生命周期 / 作用域统一交给容器管理。 这套模式把“对象的创建与组装”当成一个独立关心点（Inversion of Control），\n开发者不再到处 new，而是声明依赖，让容器来“喂”你需要的东西。\n回到 JavaScript/TypeScript：为什么也需要 DI？ 很多前端/Node 项目一开始会觉得：\n“JS 这么灵活，我直接 import + 函数就能搞定，为什么还要 DI 容器？”\n但一旦场景变成类似 Theia / VS Code / JupyterLab 这种：\n前后端分层、服务众多； 扩展点/插件系统； 需要在不同实现之间切换（浏览器版 / Electron 版 / Node 版）； 需要单元测试、集成测试时 mock 掉很多依赖； 你会发现：\n直接 import + new 会让模块之间耦合很紧； 想在不同 runtime 下切换实现（比如 Browser FS vs Node FS）会很痛苦； 写插件/扩展的人很难“往系统里塞一个实现”而不破坏现有代码。 这时，一个像 InversifyJS 这样的 DI 容器就开始变得有价值。\nInversifyJS：把 Java 世界那套“DI 思维”搬到 TS 上 InversifyJS 做的事情本质上很像“小号的 Spring/Guice，但针对 TypeScript/JS 生态做了适配”：\n用 TypeScript 装饰器（@injectable、@inject）+ reflect-metadata 提供类型信息； 用 Container 维护“服务标识符 → 实现”的绑定表； 支持作用域（单例/瞬时）、命名/标签绑定、多重注入等高级特性。 它解决的几个关键痛点和 Java 世界如出一辙：\n对象组装逻辑集中管理：不再到处 new，而是统一在模块中 bind()； 解耦实现与消费方：消费方只依赖抽象（接口/Token），容器背后替换实现； 支持插件/扩展点：多重绑定 + 多重注入，天然适合“贡献点”模式（Contribution）； 测试友好：可以在测试容器里重绑定（rebind）某些服务，用 fake/mock 实现替换。 为什么 Theia 这么重度使用 InversifyJS？ 结合前面的 Theia / Lumino 笔记，我自己对 Theia 选择 InversifyJS 的理解大概是：\nTheia 本质上是一个“可扩展平台”，不是一个封闭应用\n大量功能通过 extension/module 提供； 这些扩展需要声明它们依赖什么核心服务，而不是硬编码到具体实现。 前端/后端都有大量服务需要统一管理生命周期\n文件系统、工作区、编辑器管理、命令系统、布局、消息、日志…… 用一个 DI 容器把这些服务的创建/生命周期集中起来，是最自然的选择。 要支持不同运行时/部署形态\n浏览器 only / Electron / 后端语言服务器等； DI 容器让 Theia 可以在不同 runtime 下绑定不同实现，而扩展代码几乎不用改。 希望把 Java 世界成熟的“扩展点 + DI”模式直接搬到前端\nEclipse 平台本身就有一套非常成熟的扩展/服务架构； InversifyJS 很好地在 TS 世界里复刻了类似的 DI 能力。 从这个角度看，Theia 用 InversifyJS 并不是“为了用而用”，而是：\n为了实现“平台 + 扩展点 + 多 runtime”这一整套目标，DI 容器几乎是刚需，而 InversifyJS 是当下 TS 生态里最成熟、最契合这一诉求的选择之一。\n小结：先有“为什么需要 DI”，才有“选 InversifyJS” 这一篇想强调的是顺序问题：\n不是“我想用 InversifyJS，于是需要 DI”； 而是“我想做一个类似 Theia 这样的扩展型平台 → 我需要解耦依赖、集中组装、好测试 → DI 是合理路径 → 在 TS 生态里，InversifyJS 是一个合适的实现。” 对我个人来说，先把这个“前世今生”理清楚，再回头看 InversifyJS 的各种 API、Theia 的各种绑定文件时，心里会更踏实：\n我们不是在学一个库，而是在把一整套成熟的架构思路搬到前端项目里。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/inversifyjs/inversifyjs_%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F_%E4%BB%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%88%B0theia/","section":"docs","title":"InversifyJS：依赖注入的前世今生（从工厂模式到 Theia）"},{"body":" 什么是终身学习？ 终身学习是一种以个人发展为重点的自发教育形式。虽然终身学习没有标准化的定义，但它通常是指发生在正规教育机构之外的学习，例如学校、大学或企业培训。 然而，终身学习并不一定限于非正式学习。最好将其描述为以实现个人成就为目的的自愿。实现这一目标的手段可能会导致非正式或正式的教育。\n终身学习的重要性 无论是追求个人兴趣和激情，还是追求职业抱负，终身学习都可以帮助我们实现个人成就感和满足感。\n它承认人类有探索、学习和成长的自然动力，并鼓励我们通过关注激发我们灵感的想法和目标来提高我们自己的生活质量和自我价值感。\n我们都是终身学习者 但是个人成就感是什么意思呢？\n现实情况是，我们大多数人在正规学校教育和工作之外都有目标或兴趣。这就是作为人类的一部分含义：我们有天生的好奇心，我们是天生的学习者。我们的发展和成长得益于我们的学习能力。\n终身学习认识到并非我们所有的学习都来自课堂。\n例如，在童年时期，我们学习说话或骑自行车。 作为成年人，我们学习如何使用智能手机或学习如何烹饪新菜。 这些是我们每天通过社交、反复试验或自发学习进行的日常终身学习的例子。\n个人成就和发展是指引导我们学习新事物的自然兴趣、好奇心和动机。我们为自己学习，而不是为别人学习。\n终身学习的关键清单 自主性 自我激励或自我发起 并不总是需要成本 通常是非正式的 自学或寻求指导 动机是出于个人兴趣或个人发展 终身学习的例子 以下是您可以参与的一些终身学习计划类型：\n培养新技能（例如缝纫、烹饪、编程、公开演讲等） 自学学习（例如学习一门新语言、研究感兴趣的话题、订阅播客等） 学习一项新的运动或活动（例如参加武术、学习滑雪、学习锻炼等） 学习使用新技术（智能设备、新软件应用程序等） 获取新知识（通过在线教育或课堂课程学习自学课程） 终身学习的好处 将终身学习融入您的生活可以带来许多长期利益，包括：\n1. 新的自我激励 有时，我们在做某事时会陷入常规，仅仅是因为我们必须这样做，例如去上班或打扫房子。\n弄清楚是什么激发了你的灵感，让你重新回到驾驶座上，并提醒你在生活中你真的可以做你想做的事情。\n2. 认同个人兴趣和目标 重新点燃让你成为一个人的东西，减少无聊，让生活更有趣，甚至可以打开未来的机会。\n如果你专注于它们，你永远不知道你的兴趣会把你带到哪里。\n3. 其他个人和专业技能的提高 在我们忙于学习新技能或获取新知识的同时，我们也在培养其他有价值的技能，这些技能可以在我们的个人和职业生活中为我们提供帮助。\n这是因为我们利用其他技能来学习新事物。例如，学习缝纫需要解决问题。学习绘画涉及培养创造力。\n技能发展可以包括人际交往能力、创造力、解决问题的能力、批判性思维、领导力、反思、适应能力等等。\n4. 增强自信心 在某些方面变得更有知识或技能可以增加我们在个人和职业生活中的自信心。\n在我们的个人生活中，这种自信可以源于投入时间和精力学习和提高的满足感，给我们一种成就感。 在我们的职业生涯中，这种自信可以是我们对自己的知识和应用所学知识的能力的信任感。 我需要积极主动地进行终身学习吗？ 大多数人会在日常生活中的某个时刻通过与他人交谈、根据个人兴趣浏览互联网、阅读报纸或参与个人兴趣来学习新东西。\n但是，如果出于个人、家庭或职业原因，更加努力地学习新事物很重要，或者需要一个更有条理的结构，那么这里有一些开始的步骤。\n如何在生活中采用终身学习？ 1. 认清自己的个人兴趣和目标 终身学习是关于你自己，而不是其他人以及他们想要什么。反思你对什么充满热情以及你对自己未来的展望。\n如果职业发展是您的个人兴趣，那么有多种方法可以参与自主学习来实现这一目标。如果学习历史是您的热情，那么同样有其他方法可以进一步探索这种兴趣。\n2. 列出你想学习或能够做的事情 一旦你确定了是什么激励了你，探索你想要实现的特定兴趣或目标是什么。\n回到我们对历史充满热情的例子，也许只是希望扩大对欧洲历史的了解。或者也许兴趣如此强烈以至于攻读博士学位。是梦想的目标。\n这两者都是不同的兴趣水平，需要不同的学习方式。\n3. 确定您想如何参与以及可用的资源 实现我们的个人目标首先要弄清楚如何开始。\n研究和阅读兴趣和目标可以帮助制定如何去学习它。\n以我们的历史为例：只想了解更多特定历史时期的人可以在图书馆目录、博客、杂志和播客中找到专门针对该主题的书籍，甚至博物馆和讲座。\n想要获得博士学位的个人。在历史上，个人目标可以研究可以兼职或在线完成的大学课程，以及达到博士学位所需的步骤。\n4. 将学习目标融入你的生活 在忙碌的生活中制定新的学习目标需要考虑和努力。如果你不为它腾出时间和空间，它就不会发生。\n它很容易导致气馁或完全放弃学习计划。\n计划新学习计划的要求如何融入您的生活，或者您需要做些什么来使其适应。例如，如果学习一门新语言是学习目标，你能每天抽出一小时的时间吗？还是每天 15 分钟听起来更现实？\n了解您可以为学习目标投入的时间和空间可以帮助您长期坚持目标。\n5. 做出承诺 做出参与新学习计划的决定是最后也是最重要的一步。如果您设定了切合实际的期望并有自我激励来实现它，那么请致力于它并避免找借口。\n","link":"https://misakaJimmy.github.io/docs/","section":"docs","title":"Lifelong Learning"},{"body":" 这篇更像是我自己啃 Lumino 源码和周边资料的一些读书笔记，方便之后写 Theia 架构时有个“底层 UI 框架”的背景板。\nLumino 是什么？ 简单一句话：Lumino 是一套给 Web 应用带来「桌面应用感」窗口/布局系统的 UI 基础框架。\n它主打几个特性：\n可停靠（docking）和分屏布局：窗口可以左右、上下拖拽拆分，支持多层嵌套。 标签页（tabbed）管理：一个区域里可以放多个 tab，支持拖拽排序、拖出合并。 Widget 抽象：把 UI 组件都抽象成 Widget，对生命周期、布局和消息分发进行统一管理。 命令与快捷键系统：内建 Command \u0026amp; Keybinding 概念，方便 IDE 类应用统一处理交互。 如果你用过 JupyterLab 或 Theia，其实已经在间接使用 Lumino 了：那种可以随意拖拽 panel、拆分编辑区的体验，背后就是 Lumino 这套桌面感窗口系统在撑腰。\nLumino 的前世：从 PhosphorJS 到 JupyterLab 内核 Lumino 不是凭空冒出来的，它的前身叫 PhosphorJS：\n最早的动机：Jupyter 团队在做 JupyterLab 的时候，就不满足于“在页面里堆几个 iframe 或 div”，他们想要的是更像桌面 IDE 的体验——可以像 VS Code 一样随意拆分编辑器、停靠面板，于是就有了 PhosphorJS 这个专门做 dock layout 的 UI 库。 功能慢慢长胖：随着 JupyterLab 不断演进，PhosphorJS 也不再是单纯的 dock panel；它开始承担 widget 管理、命令系统、菜单/面板布局等一整套 UI 基础设施。 与应用高度耦合：PhosphorJS 一开始更多是“为 JupyterLab 服务”的内部项目，很多设计和 API 都是围绕 JupyterLab 的需求长出来的。 后来社区的诉求越来越明显：这套 UI 能不能抽出来，给别的 Web IDE / 工具类应用用？ 于是就出现了 Lumino 这个名字。\nLumino 的今生：从 Jupyter 内核到通用布局框架 可以粗暴地理解为：Lumino = “抽离重构之后的 PhosphorJS / JupyterLab UI 内核”。\n重新命名与打包：为了更清晰地区分历史包袱和全新定位，Jupyter 团队把原来的 PhosphorJS 抽出来，整理成一组以 @lumino/* 命名的 npm 包，做成一个相对独立、通用的 UI 框架。 更通用的定位：官方不再以“Jupyter 专用 UI 框架”自居，而是把 Lumino 当成“构建复杂、多窗口 Web 工具型应用”的基础设施——JupyterLab 是一个重度使用者，但不是唯一。 API 和模块划分更清晰：例如： @lumino/widgets：Widget 抽象、Panel、DockPanel、TabBar 等。 @lumino/signaling：轻量级事件/信号系统。 @lumino/commands：命令系统。 @lumino/messaging：Widget 间消息派发。 这些模块化拆分，让框架更适合作为通用依赖被其他项目引用。 在这个阶段，Theia 这类 IDE 平台就有机会直接复用 Lumino 的成果，而不用自己从头再造一套 dock layout 系统。\n为什么 IDE 类项目会盯上 Lumino？ 从 Theia 的视角看，选择 Lumino 有几层现实原因：\n不想自己再造一套复杂布局系统：多窗口、多分屏、拖拽合并这些需求看起来只是“UI 小细节”，但真正实现一遍是个大坑；Lumino 已经在 JupyterLab 里被狠狠验证过一轮。 桌面感交互体验成熟：Lumino 更像是在 Web 上实现了“迷你版桌面窗口管理器”，它处理的不是简单的 flex 布局，而是一整套 dock / tab / split 逻辑，这和 IDE 这种应用的交互模型高度吻合。 Widget + Command 的模式对 IDE 很友好：IDE 里充满了“视图 + 命令 + 快捷键”的组合，Lumino 内建的 widget + command 机制，可以和 Theia 自己的 command/菜单/快捷键系统自然对接。 对我个人来说，一开始看 Theia 源码的时候，看到那一堆 shell、panel、area 的布局逻辑时是有点懵的，直到顺藤摸瓜翻到 Lumino 的文档和代码，才慢慢意识到：\nTheia 自己只是在“描述要有哪些区域”，真正负责“怎么在页面上摆好这些区域”的，是 Lumino。\nLumino 的几个核心设计点（以一个学习者的视角） 从源码和示例里，我大致会把 Lumino 的核心设计分成几块来理解：\nWidget 是一等公民\n所有可视组件基本都被抽象成 Widget，Widget 负责： 管自己的 DOM 节点。 响应 attach/detach、resize 等生命周期。 这和 React/组件化思路有点像，但 Lumino 更偏底层，更关心“这个组件在页面哪个矩形区域里呈现”。 布局 = 容器 Widget 的组合\nDockPanel、SplitPanel、TabBar 这些都是特殊的“布局 Widget”，它们并不关心业务，只负责怎么把子 Widget 摆放到正确的位置。 这点对阅读 Theia 的外壳（shell）代码很关键：很多时候你看到的是 Theia 在操作 Lumino 的 DockPanel，而不是直接改 DOM。 信号和消息机制\n@lumino/signaling 提供了一种比裸 EventEmitter 更规整的信号系统，用来在 Widget 之间传递事件。 @lumino/messaging 则负责在 Widget 内部调度诸如 resize、update 这类消息，让布局和渲染有序进行。 这套机制是整个桌面感窗口系统稳定运行的“血液循环”。 命令系统\n@lumino/commands 定义命令、快捷键和菜单项之间的映射。 在 IDE 这个场景里，命令系统其实是 UI 的“第二条主线”：很多行为不是直接绑在按钮上，而是先声明成命令，再由不同的触发源（菜单、快捷键、按钮）去调用。 这些东西，如果只从 Theia 的扩展代码往下看，很容易糊成一片；反过来先在 Lumino 里把这些概念吃透，再回头看 Theia，会清爽很多。\n个人感受：为什么值得单独写一篇 Lumino 笔记？ 对我自己来说，Theia 架构里最“像黑盒”的一层就是桌面感窗口系统：\n我们一直在用 IDE 的分屏和停靠功能，但很少认真想过“浏览器里到底是怎么实现一个像桌面应用一样的窗口管理”的。\nLumino 刚好把这一块剥离成了一个可学习、可复用的库：\n作为 Theia 的使用者或扩展开发者，理解 Lumino 可以帮我们： 更自信地调整布局区域（main / bottom / left / right）。 在合适的地方插入自己的 Widget，而不是“瞎试位置”。 作为 对前端基础设施感兴趣的工程师，Lumino 又是一个很好的“源码读物”： 它不是花哨的 UI 组件库，而是偏底层的布局和交互内核。 既能看到经典的命令/消息/信号模式，又能看到它们如何落地到复杂产品（JupyterLab、Theia）里。 所以这篇就当是给后面几篇 Theia 架构解析打地基：\n先把 Lumino 这块“桌面感窗口系统”的底层认清楚，再去看 Theia 怎么在它之上堆出一个完整 IDE。\n这里面几个分析笔记毕竟不是详细的教程，只是我自己啃源码的读书笔记，可能会有些碎片化，但希望能给想要深入理解 Theia UI 架构的朋友一些启发。详细的示例代码我感觉 Lumino 官方文档已经写得不错了，想要上手的朋友可以直接看官方的文档，里面的示例就能挺好的说明问题了。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/","section":"docs","title":"Lumino：桌面感窗口系统的前世今生"},{"body":"1docker pull bitnami/postgresql:12 docker-compose 1version: \u0026#39;3.5\u0026#39; 2 3services: 4 postgres: 5 container_name: postgres_container 6 image: postgres 7 environment: 8 POSTGRES_USER: postgres 9 POSTGRES_PASSWORD: password 10 PGDATA: /data/postgres 11 volumes: 12 - postgres:/data/postgres 13 ports: 14 - \u0026#34;5432:5432\u0026#34; 15 networks: 16 - postgres 17 restart: unless-stopped 18 19 pgadmin: 20 container_name: pgadmin_container 21 image: dpage/pgadmin4 22 environment: 23 PGADMIN_DEFAULT_EMAIL: misakajimmy@gmail.com 24 PGADMIN_DEFAULT_PASSWORD: admin 25 PGADMIN_CONFIG_SERVER_MODE: \u0026#39;False\u0026#39; 26 volumes: 27 - pgadmin:/root/.pgadmin 28 29 ports: 30 - \u0026#34;3080:80\u0026#34; 31 networks: 32 - postgres 33 restart: unless-stopped 34 35networks: 36 postgres: 37 driver: bridge 38 39volumes: 40 postgres: 41 pgadmin: ","link":"https://misakaJimmy.github.io/docs/database/postgresql/postgresql-docker/","section":"docs","title":"PostgreSQL Docker 启动"},{"body":" 为什么要对 Theia 解析 从前端开发的视角来看，Theia 并不仅仅是一个“长得像 VS Code 的 IDE 壳”，而是一套可高度定制的开发平台。\n要想在自己的产品里稳定地集成 Theia（例如做云 IDE、企业内部开发平台、在线教学环境等），就必须理解它的整体架构：\nTheia 的客户端/服务端分层：前端运行在浏览器或桌面容器内，核心能力很多是通过后端扩展来完成的，需要清楚哪些逻辑应该放在前端、哪些要放在后端。 扩展机制与依赖注入（InversifyJS）：Theia 几乎所有功能都是扩展包拼装出来的，通过依赖注入进行解耦；只有理解这一套机制，才能正确地裁剪、替换或新增功能。 与 VS Code 插件生态的关系：Theia 支持 VS Code 插件协议，如果不了解其适配层与限制，很容易在选型插件时踩坑。 通过对 Theia 的架构进行系统性解析，可以帮助我们在二次开发时做出更合理的技术决策，例如：如何设计自己的扩展包结构、如何部署后端服务、以及在性能与可维护性之间做怎样的取舍。\n本人在 Theia 项目 1.0 的时期就开始研究 Theia 项目了，也仿照 Theia 项目做过一个静态的离线版本的 IDE 并做了些插件，也给这个项目提交过 commit (虽然很微小就是了)。后面虽然因为工作原因没有继续深入研究这个项目了，但一直对这个项目很感兴趣，最近又重新捡起来了，所以就想写一些关于 Theia 的架构解析的文章来记录一下自己的学习过程，也希望能对一些想要了解 Theia 的朋友有所帮助。\nTheia 1.0 和 2.0 的不同 总的来说，Theia 2.0 并不是“推倒重来”的全新产品，更像是在 1.x 基础上的一次体系化升级：核心理念（云 + 桌面双形态、前后端分离、通过扩展包拼装 IDE 功能）保持不变，但在依赖版本、扩展 API、VS Code 兼容性和项目结构等方面做了比较集中、成体系的调整。整体可以理解为：2.0 系列把 1.x 时代逐步累积的“技术债”和“历史包袱”做了一次清理，并顺带把底层技术栈和生态支持拉到了一个更现代的基线。\n架构与项目结构层面的差异 依旧是前后端分离 + 扩展驱动架构：1.0 和 2.0 在大架构上没有本质变化，仍然是 Browser/Electron 前端 + Node.js 后端扩展的模式，功能通过一系列 @theia/* 扩展包组合出来。 对历史包的清理：2.0 中，很多在 1.x 里长期被标记为 deprecated 的包和 API 被正式移除或合并，项目结构更扁平、命名也更统一，这对“跟着源码学架构”的人来说反而更清晰。 底层依赖的升级：随着 Node.js、Electron/Chromium、Monaco 等依赖版本的提升，2.0 在性能、安全性和新特性支持上更好，但也意味着一些依赖旧版本行为的代码在升级时需要仔细验证。 扩展 API 与 VS Code 生态的演进 清理旧的扩展点和内部 API：1.x 时代很多为兼容历史场景而留下的 service / contribution / command 等扩展点，在 2.0 中被统一和收敛，内部使用方式也更加一致，减少了“同一件事有多种写法”的情况。 更紧密地对齐 VS Code 插件 API：Theia 一直把“兼容 VS Code 插件”作为卖点，2.0 进一步对齐到了更高版本的 VS Code API，支持更多调试、语言服务、终端等新特性；一些早期特有的 Theia Plugin API 能力则被弱化或建议迁移到标准 VS Code 扩展模型上。 扩展开发体验的改进：官方脚手架、示例仓库和文档也围绕 2.0 做了更新，更强调以“应用 + 扩展包 + VS Code 插件”三层来思考项目结构，而不是简单堆 extension。 对使用者和二次开发者意味着什么？ 如果你有 1.0 时代的自研扩展：升级到 2.0 时，重点是排查：是否使用了已被标记为 deprecated 的 API、是否依赖了被重构的 service / contribution、是否直接 import 了内部模块。这部分改动通常集中在少数基础设施扩展上，迁移一次之后收益是长期的。 如果你更多是作为 Theia 应用的“集成者”（主要关心如何挑选和组合扩展、VS Code 插件）：2.0 带来的更多是“兼容性和可预期性”的提升，你可以更放心地复用社区的 VS Code 插件，同时获得更长的维护周期。 从学习角度看：选择在 2.0 版本重新梳理 Theia 架构是很划算的——一方面，很多历史遗留设计已经在 2.0 中被“官方示范”成更合理的形态；另一方面，你在阅读源码和设计自己扩展时，可以直接对标最新的一套最佳实践，而不必在 1.x 的历史折衷里兜圈子。 ","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/","section":"docs","title":"Theia 架构解析"},{"body":" 为什么要写这个系列的笔记 这个系列文章作为我 Web IDE 的开发心得笔记，至于为什么要做一款纯在线的 IDE 要从以下这么几点讲起。\nIDE 对于程序开发的作用 写程序无非就是以人类能理解的文本形式来有规律有目的控制计算机进行计算。而当在开发规模非常小时，比如当写一个简单功能的 bash 脚本时，直接对文本文件进行编辑，直接使用 echo 或者 Vim 都可以非常简单的解决问题，当然如果 Vim 经过一些改造，某种程度上其实也是一个 IDE。但是如果程序规模一旦大了之后，就会遇到以下的一些需求。\n代码缩进 语法检查 代码分包 代码高亮 语法提示 这些需求的满足对于写代码的人来说非常有帮助，开发者可以更多的将自己的注意力集中于实现当前的功能，而不是繁杂的语法或者其他的编程细节。在今天写代码更多的是为了实现功能，而不是为了去炫技，抱着一本魔法辞典去放魔法的时代已经过去了，更多的降低写代码的门槛以使得更多的更快的将学习者变成开发者是一个不可避免的大趋势，为了达成以上的愿景 IDE 就此诞生。\n如今市面上的 IDE 在我观测的范围内如今做的比较好的桌面级 IDE 为 VS Code 以及 JetBrain 家的一些列针对各种语言特化的 IDE。 VS Code 作为免费的 IDE，其极佳的扩展性以及丰富的扩展生态被广泛的在各个领域使用。JetBrain 作为一款付费 IDE 却仍然有强大的竞争力，其核心在于专注于对各种语言的特化，使得一种开发语言就有一款专门的 IDE 来对其中的开发痛点进行补足，相比起 VS Code 来更强的代码补全，代码高亮，以及更友好的开发环境配置，唯一的可能的不足就是收费？\n以上的 VS Code 和 JetBrain 作为桌面级别的IDE，用于专业开发者的开发自是极佳的，但是如果给一些刚入门的新手可能还是不够适合的，VS Code 在需要一些比较麻烦的环境配置，而且这个环节还是挺劝退的，而 JetBrain 作为一个付费 IDE 对于学习者也天然的会有畏惧心理。\n而如今市面上又出现了很多在线版本的 IDE，比如老牌 IDE 厂家 eclipse 的开源在线IDE theia，还有 code-server 等等。不同于传统的桌面级 IDE，这些网页版的 IDE 做出了一些与众不同的改变，它们将 IDE 脱离桌面环境运算可以放到服务器或者容器内，基于浏览器的 V8 引擎来对 IDE画面进行渲染，当然值得一提的是现在市面上出现了这么多的网页版 IDE 很大程度上归功于微软的 VS Code 项目，因为它本质上也是一个基于 chromium 浏览器的项目，你只要打开 Help\u0026gt;Toggle Devloper Tools 就能发现 chrome 的 develpoer tools。微软在 github 上有大量的 IDE 相关的开源项目，比如 monaco-editor,这是 VS Code 以及一众在线 IDE 的编辑器组件，其作为一个网页端的文本编辑器其功能已经非常完善了，所以很多 IDE 项目其实可以很大程度上避免重复的工作，尤其是文本编辑器这种需要针对 AST 来做一些彩色渲染高亮等的重复工作。\n我为什么要写一些 IDE 相关的内容 对于大多数人来说，更喜欢一些拿来即用的工具，对于工具好用就行无关其本质以及原理。但对于我个人来说，我会更好奇于事物本身的原理以及机制，拆解一些已经整合好的东西能给我带来一些满足感，或许我有一些结构主义的倾向\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/","section":"docs","title":"Web IDE 开发笔记"},{"body":"","link":"https://misakaJimmy.github.io/docs/frontend/tools/","section":"docs","title":"前端常用工具链"},{"body":"数据库笔记\n","link":"https://misakaJimmy.github.io/docs/database/","section":"docs","title":"DataBase"},{"body":" 这篇笔记是我在啃 Theia 源码时，发现几乎每个扩展、每个服务都在用 @injectable() 和 @inject()，于是顺藤摸瓜去学 InversifyJS 的一些记录。\n目标不是翻译官方 API 文档，而是给自己理一套「看 Theia 代码时脑子里应该有的依赖注入模型」，方便之后理解 Theia 的扩展系统、服务注册、模块化架构。\n推荐阅读顺序 如果是第一次系统看这一块，建议按下面的顺序读一遍：\n依赖注入的前世今生：InversifyJS_依赖注入的前世今生_从工厂模式到Theia 总览与动机：当前这篇 _index（为什么 Theia 选择 InversifyJS） 安装与配置：在项目中引入 InversifyJS：配置与依赖 基础示例：InversifyJS 基础示例：从传统依赖到依赖注入 核心概念：服务标识符与接口绑定、类作为标识符、作用域与生命周期、多种绑定方式、高级绑定 模块化与扩展点：ContainerModule、懒注入 \u0026amp; 循环依赖、测试中的容器用法 与 Theia 的映射：InversifyJS与Theia_从index_js看前端启动与模块装配、InversifyJS与Theia_概念对照表_从DI到扩展点 InversifyJS 是什么？ 简单一句话：InversifyJS 是一个轻量（约 4KB）的控制反转（IoC）容器，专门为 TypeScript/JavaScript 应用设计，通过依赖注入来管理对象之间的依赖关系。\n它解决的核心问题是：如何让代码更解耦、更可测试、更符合 SOLID 原则，而不是让每个类都自己 new 依赖，或者用全局单例到处传。\n如果你在写或研究 Theia，其实已经在间接使用 InversifyJS 了：\nTheia 的整个扩展系统、服务注册、模块化架构，底层都依赖 InversifyJS 的 Container 和装饰器机制。\n看 Theia 源码时，几乎每个扩展类都会看到 @injectable() 和 @inject(Symbol) 这样的标记，这就是 InversifyJS 在起作用。\n为什么 Theia 选择 InversifyJS？ 从 Theia 架构的角度看，选择 InversifyJS 有几个现实原因：\n扩展系统需要依赖注入：Theia 的扩展（Extension）都是通过 Contribution 接口注册的，每个 Contribution 可能需要依赖其他服务（比如 CommandRegistry、MenuRegistry、FileService 等）。如果不用 IoC 容器，就得手动传依赖，或者用全局变量，很快就会变成维护噩梦。\n服务注册与生命周期管理：Theia 里有很多“服务”（Service），比如 FileService、WorkspaceService、EditorService 等。这些服务需要：\n在应用启动时统一注册到容器里。 支持单例（singleton）或每次新建（transient）等不同生命周期。 支持接口绑定（bind\u0026lt;Interface\u0026gt;(Symbol).to(Implementation)），方便测试时替换实现。 这些需求，InversifyJS 都能很好地满足。\n模块化与可测试性：Theia 的扩展是模块化的，每个扩展包可以独立开发、测试。通过依赖注入，扩展可以声明“我需要什么服务”，而不需要知道这些服务是从哪儿来的、怎么创建的。这在写单元测试时特别有用：可以轻松 mock 掉依赖。\n对我个人来说，一开始看 Theia 源码的时候，看到那一堆 @injectable()、@inject()、container.bind().to() 时是有点懵的，直到去学了 InversifyJS 的基础概念，再回头看 Theia，才慢慢意识到：\nTheia 自己只是在“描述有哪些服务和扩展”，真正负责“怎么把这些东西组装起来、怎么管理依赖关系”的，是 InversifyJS。\nInversifyJS 的核心设计理念 从源码和文档里，我大致会把 InversifyJS 的核心设计分成几块来理解：\n装饰器 + 元数据反射\n通过 @injectable() 标记一个类“可以被注入”，通过 @inject(Symbol) 标记构造函数参数“需要注入什么”。 底层依赖 TypeScript 的装饰器和 reflect-metadata，在编译时/运行时生成元数据，告诉容器“这个类需要什么依赖”。 Container 作为依赖注册中心\n所有可注入的服务都要先 container.bind(Symbol).to(Class) 注册到容器里。 容器负责在需要时创建实例、解析依赖、管理生命周期（singleton/transient 等）。 Symbol 作为服务标识符\n在 Theia 里，几乎每个服务都会有一个对应的 Symbol 作为唯一标识（比如 FileService = Symbol('FileService')）。 这样做的好处是：可以绑定接口而不是具体类，方便测试时替换实现。 支持多种绑定策略\n可以绑定到类、绑定到值、绑定到工厂函数、绑定到动态值（provider）等。 支持命名绑定、标签绑定，方便在同一个接口有多个实现时区分。 这些东西，如果只从 Theia 的扩展代码往下看，很容易糊成一片；反过来先在 InversifyJS 里把这些概念吃透，再回头看 Theia，会清爽很多。\n个人感受：为什么值得单独写一篇 InversifyJS 笔记？ 对我自己来说，Theia 架构里最“像黑盒”的一层就是依赖注入系统：\n我们一直在用 IDE 的各种功能，但很少认真想过“这些扩展、这些服务是怎么被组装起来的、它们之间的依赖关系是怎么管理的”。\nInversifyJS 刚好把这一块剥离成了一个可学习、可复用的库：\n作为 Theia 的使用者或扩展开发者，理解 InversifyJS 可以帮我们：\n更自信地写扩展，知道怎么声明依赖、怎么注册服务。 在合适的地方用 @injectable() 和 @inject()，而不是“瞎试位置”。 写单元测试时，知道怎么 mock 依赖、怎么替换实现。 作为 对前端基础设施感兴趣的工程师，InversifyJS 又是一个很好的“源码读物”：\n它不是花哨的 UI 组件库，而是偏底层的依赖管理基础设施。 既能看到经典的 IoC/DI 模式，又能看到它们如何落地到复杂产品（Theia）里。 所以这篇就当是给后面几篇 Theia 架构解析打地基：\n先把 InversifyJS 这块“依赖注入系统”的底层认清楚，再去看 Theia 怎么在它之上堆出一个完整的 IDE 扩展系统。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/inversifyjs/","section":"docs","title":"InversifyJS：Theia 架构的依赖注入基石"},{"body":" 延续前一篇“前世今生”的笔记，这篇就专门盯着 Lumino 里最核心的那块：Widget 系统。\n目标不是翻译 API 文档，而是给自己理一套「看源码时脑子里应该有的模型」，顺手放点小 demo，方便之后查阅。\nWidget 在 Lumino 里的角色 在 Lumino 里，Widget 基本可以当成“一切可见 UI 的最小单位”：\n每个 Widget 都对应一个 DOM 元素（默认是 div，也可以自定义）。 Widget 负责自己的一些生命周期：什么时候挂到 DOM 上、什么时候从 DOM 上卸载、什么时候需要重绘。 更高级的组件（面板、停靠布局、TabBar 等）本质上也是 Widget，只是它们更偏“容器”。 所以，从 Theia 的角度看：\nTheia 在做布局时，其实是在安排一堆 Lumino Widget 怎么排队站好；而不是直接操作 DOM。\n一个最小可跑的 Lumino Widget Demo 先看个最小可运行的 Widget 示例，大致感受一下写法：\n1import { Widget } from \u0026#39;@lumino/widgets\u0026#39;; 2 3// 1. 定义一个最简单的 Widget 4class HelloWidget extends Widget { 5 constructor() { 6 super(); 7 this.addClass(\u0026#39;my-HelloWidget\u0026#39;); 8 this.node.textContent = \u0026#39;Hello from Lumino Widget 👋\u0026#39;; 9 } 10} 11 12// 2. 创建实例并挂载到页面 13const widget = new HelloWidget(); 14 15// shell / DockPanel 之类的容器里，通常会有类似的 attach 逻辑 16Widget.attach(widget, document.body); 几个点：\nWidget 自带一个 node 属性，代表它管理的 DOM 元素（默认 div）。 一般不会直接 appendChild 到 document.body，而是交给更高级的 Panel/应用壳来管理；这里为了示例直接挂载。 Widget 的生命周期：attach/detach/resize/update Lumino 给 Widget 设计了一套相对明确的生命周期钩子，这在复杂布局里非常重要。\n典型的几个方法：\nonAfterAttach(msg)：Widget 被插入到 DOM 后触发，适合做首次渲染、事件绑定。 onBeforeDetach(msg)：从 DOM 中移除前触发，可以在这里清理事件、定时器等。 onResize(msg)：容器大小变化时触发，用来响应布局变化。 onUpdateRequest(msg)：需要重新渲染时触发（手动 this.update() 会发起这个请求）。 一个稍微完整一点的例子：\n1import { Widget } from \u0026#39;@lumino/widgets\u0026#39;; 2 3class CounterWidget extends Widget { 4 private _count = 0; 5 6 constructor() { 7 super(); 8 this.addClass(\u0026#39;my-CounterWidget\u0026#39;); 9 } 10 11 // 第一次挂载时渲染 DOM 12 protected onAfterAttach(msg: any): void { 13 this._render(); 14 this.node.addEventListener(\u0026#39;click\u0026#39;, this); 15 } 16 17 // 卸载前清理事件 18 protected onBeforeDetach(msg: any): void { 19 this.node.removeEventListener(\u0026#39;click\u0026#39;, this); 20 } 21 22 // 简单的事件代理 23 handleEvent(event: Event): void { 24 switch (event.type) { 25 case \u0026#39;click\u0026#39;: 26 this._count++; 27 this.update(); // 触发 onUpdateRequest 28 break; 29 } 30 } 31 32 protected onUpdateRequest(msg: any): void { 33 this._render(); 34 } 35 36 private _render() { 37 this.node.textContent = `Clicked: ${this._count}`; 38 } 39} 这段代码有点“手工组件化”的味道：没有引入 React/Vue，而是直接围绕 Widget 生命周期和 update() 来组织逻辑。\n在 Theia 里，很多比较底层的 UI 扩展也是这种风格，只不过被包了一层框架自己的抽象。\nWidget 与容器：Panel / DockPanel / TabBar 的关系 Widget 自己只是一个“砖块”，真正决定布局的是各种“砖墙”——Panel 系列组件：\nPanel：最基础的容器 Widget，可以放一串子 Widget，按一个 layout（例如垂直/水平）来排布。 DockPanel：支持 dock / split / tab 的高级容器，是 IDE 风格布局的核心。 TabBar：显示 tab 页签的组件，通常和 DockPanel 或 TabPanel 一起使用。 粗暴一点的伪代码示意：\n1import { DockPanel, Widget } from \u0026#39;@lumino/widgets\u0026#39;; 2 3const dock = new DockPanel(); 4 5const w1 = new Widget(); 6const w2 = new Widget(); 7const w3 = new Widget(); 8 9w1.node.textContent = \u0026#39;左边的视图\u0026#39;; 10w2.node.textContent = \u0026#39;右上视图\u0026#39;; 11w3.node.textContent = \u0026#39;右下视图\u0026#39;; 12 13dock.addWidget(w1, { mode: \u0026#39;split-left\u0026#39; }); 14dock.addWidget(w2, { mode: \u0026#39;split-right\u0026#39; }); 15dock.addWidget(w3, { ref: w2, mode: \u0026#39;split-bottom\u0026#39; }); 16 17Widget.attach(dock, document.body); Theia 的 shell 其实就是在做类似的事情：\n先有一个包着 DockPanel 的根 Widget，然后把各个视图（文件树、编辑器、终端等）当作 Widget 塞进不同的区域。\nWidget 与信号/命令：更大一层的协作 单个 Widget 只是“会自己长大的一块砖”，真正构成应用的是：\n使用 @lumino/signaling 在 Widget 之间传递状态变化（类似轻量版事件总线）。 使用 @lumino/commands 注册命令，然后在 Widget 里触发或响应这些命令。 一个很常见的模式是：\n1import { CommandRegistry } from \u0026#39;@lumino/commands\u0026#39;; 2 3const commands = new CommandRegistry(); 4 5commands.addCommand(\u0026#39;app:hello\u0026#39;, { 6 label: \u0026#39;Say Hello\u0026#39;, 7 execute: () =\u0026gt; { 8 console.log(\u0026#39;Hello from command!\u0026#39;); 9 }, 10}); 11 12// Widget 里可以通过 commands.execute(\u0026#39;app:hello\u0026#39;) 来触发 在 Theia 里，会有自己一套 command/菜单/快捷键系统，但和 Lumino 的思路高度一致：\n先把行为抽象成命令，再决定从哪儿被触发（菜单、按钮、快捷键、命令面板……）。\n写在最后：为什么先啃 Widget 再看 Theia？ 对我个人的阅读路线来说，先啃 Lumino 的 Widget 系统有几个好处：\n再回头看 Theia 的 shell 和 layout 相关代码时，不会把“应用层逻辑”和“布局框架逻辑”混在一起。 当需要在 Theia 里塞一个自定义视图时，可以更有把握地选： 是做成 React 组件包在一个 Widget 里， 还是直接写一个 Lumino Widget，更贴近底层。 理解 Widget 的生命周期之后，碰到“为什么这个视图 resize 不对劲 / 渲染时机不对”的问题，也有地方可以下手 debug。 后面如果有精力，我可能会专门搞一篇“从一个简单的 Theia 扩展开始，顺藤摸瓜走到 Lumino Widget”的实战笔记，把两边的调用链串起来；这一篇就先当 Widget 层的查阅手册了。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/lumino%E7%9A%84widget%E7%B3%BB%E7%BB%9F/","section":"docs","title":"Lumino 的 Widget 系统：从概念到源码入口"},{"body":"直接官网下载安装，安装时记得记下安装路径。\n根目录如下图所示，bin下是 PostgreSQL 的命令行控制程序，pgAdmin4 下是 PostpreSQL 的可视化管理程序。\n添加 bin 到环境变量之中 记下到 bin 文件夹的绝对路径， 我这里是 D:\\Program Files\\PostgreSQL\\12\\bin ，添加到系统变量和用户变量的 Path 之中。\n然后打开 Terminal ，输入\n1pg_ctl.exe start -D \u0026#34;D:\\Program Files\\PostgreSQL\\12\\data\u0026#34; 然后打开 pgAdmin ， 输入 host 和 Password 。\n角色 \u0026quot;postgres\u0026quot; 不存在 Terminal 中出现角色不存在，导致无法正常连接到postgre服务。\n使用管理员权限打开 Powershell ， 输入\n1 pg_ctl.exe register -N \u0026#34;pgsql\u0026#34; -D \u0026#34;D:\\Program Files\\PostgreSQL\\12\\data\u0026#34; 将 postgresql 注册为服务\n","link":"https://misakaJimmy.github.io/docs/database/postgresql/windows-postgresql-usage/","section":"docs","title":"Windows PostgreSQL 使用"},{"body":"","link":"https://misakaJimmy.github.io/docs/frontend/basic/","section":"docs","title":"前端基础"},{"body":" 这篇就把 Widget 背后的两条“暗线”单拎出来：signaling 和 messaging。\n一个负责「谁对谁说话」，一个负责「什么时候该说话」，很多看起来“魔法般自动”的行为，其实都是这两套机制在背后运转。\n先分清楚：signaling vs messaging 到底谁管啥？ 我自己的粗暴理解：\nsignaling：更像是“业务层事件/信号系统”，解决的是——\n「A 的状态变了，B 想知道」。 典型场景：模型变化通知视图、多个 Widget 之间同步选中状态等。 messaging：更偏“框架内部的消息循环”，解决的是——\n「这个 Widget 现在应该执行哪个生命周期钩子」。 典型场景：onResize / onUpdateRequest / onAfterAttach 等这些钩子，其实都是通过 messaging 派发进来的。 一句话：\nsignaling 是「业务信号」；messaging 是「UI 框架自己的消息泵和生命周期调度」。\nsignaling：在 Widget / 模型之间传递“我变了”的信号 先看一个 @lumino/signaling 的最小例子，感受一下 API 风格：\n1import { ISignal, Signal } from \u0026#39;@lumino/signaling\u0026#39;; 2 3// 一个简单的模型对象 4class CounterModel { 5 private _value = 0; 6 private _changed = new Signal\u0026lt;CounterModel, number\u0026gt;(this); 7 8 // 对外暴露只读的 signal 9 get changed(): ISignal\u0026lt;CounterModel, number\u0026gt; { 10 return this._changed; 11 } 12 13 get value(): number { 14 return this._value; 15 } 16 17 increment(): void { 18 this._value++; 19 // 发出“我变了”的信号 20 this._changed.emit(this._value); 21 } 22} 23 24// 某个监听它的视图/Widget 25const model = new CounterModel(); 26 27model.changed.connect((sender, value) =\u0026gt; { 28 console.log(\u0026#39;Counter changed:\u0026#39;, sender, value); 29}); 30 31model.increment(); // 控制台会输出 Counter changed: ... 几个细节：\nSignal\u0026lt;Sender, Args\u0026gt; 里的第一个泛型是“信号的发送者类型”，第二个是“携带的数据类型”。 connect 接受一个回调 (sender, args) =\u0026gt; {}，这点跟 Qt 的 signal/slot 有点神似。 Widget 通常不会自己 new 一个 Signal，而是： 要么监听别的对象的信号。 要么在某个“模型对象”里管理 signal，然后 Widget 订阅它。 在 Theia 这种架构里，signaling 非常适合放在「状态/模型」那一层，让 UI 只是订阅并响应，而不是自己维护一堆 EventEmitter。\nsignaling + Widget 的一个组合小例子 再来一个「模型 + Widget」的小组合，接上上一篇的 Widget 思路：\n1import { ISignal, Signal } from \u0026#39;@lumino/signaling\u0026#39;; 2import { Widget } from \u0026#39;@lumino/widgets\u0026#39;; 3 4class CounterModel { 5 private _value = 0; 6 private _changed = new Signal\u0026lt;CounterModel, number\u0026gt;(this); 7 8 get changed(): ISignal\u0026lt;CounterModel, number\u0026gt; { 9 return this._changed; 10 } 11 12 get value(): number { 13 return this._value; 14 } 15 16 increment(): void { 17 this._value++; 18 this._changed.emit(this._value); 19 } 20} 21 22class CounterView extends Widget { 23 constructor(private model: CounterModel) { 24 super(); 25 this.addClass(\u0026#39;my-CounterView\u0026#39;); 26 27 // 订阅模型变化 28 this.model.changed.connect(this.onModelChanged, this); 29 } 30 31 protected onAfterAttach(msg: any): void { 32 this._render(); 33 this.node.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { 34 this.model.increment(); 35 }); 36 } 37 38 private onModelChanged(sender: CounterModel, value: number): void { 39 this._render(); 40 } 41 42 private _render(): void { 43 this.node.textContent = `Clicked: ${this.model.value}`; 44 } 45} 这里可以看到几个小模式：\nWidget 不直接修改自己的“业务状态”，而是通过 model 来改。 Widget 通过 signal.connect 订阅变化，然后在回调里调用 _render()。 从架构味道上讲，这和常见的 MVVM / 状态管理思路是一脉相承的，只是工具换成了 Lumino 的 Signal。 messaging：Widget 生命周期背后那条消息泵 再来看 messaging。大多数时候我们只会在 Widget 里重写这些方法：\nonAfterAttach onBeforeDetach onResize onUpdateRequest …… 但在 Lumino 内部，这些并不是直接「某处手动调用」，而是通过一个消息系统来派发：\n1import { Message, MessageLoop } from \u0026#39;@lumino/messaging\u0026#39;; 2import { Widget } from \u0026#39;@lumino/widgets\u0026#39;; 3 4class MyWidget extends Widget { 5 protected onUpdateRequest(msg: Message): void { 6 console.log(\u0026#39;update request:\u0026#39;, msg); 7 } 8} 9 10const w = new MyWidget(); 11 12// 手动触发一次 update 消息 13MessageLoop.sendMessage(w, Widget.Msg.UpdateRequest); MessageLoop.sendMessage 会把一条消息送进 Widget 的处理流程里，最终调用到 onUpdateRequest。\n在正常使用 DockPanel / Layout 的时候，这一切都是框架帮你调度好的，你只要实现对应的钩子函数就行。\n还有几个配套概念：\nWidget.Msg.UpdateRequest / ResizeRequest / AfterAttach 等是一些内置消息常量。 MessageLoop.postMessage 则是异步排队发送，在下一轮消息循环里处理，避免同步调用导致递归问题。 可以理解为：messaging 是让 Widget 的生命周期更像“消息驱动”的，而不是直接函数调用。\nsignaling + messaging 在实际阅读代码时的用法区别 我自己在看 Theia / Lumino 源码时，通常会这样区分两条线：\n看到 Signal / .connect() / .emit()： 把它当成“业务事件”，去想「谁在产生这个状态变化」「谁在消费它」。 这部分逻辑通常跟 UI 框架解耦，迁移到别的 UI 技术栈也可以重用。 看到 onXXXRequest / MessageLoop / Widget.Msg.*： 把它当成“UI 框架调度”，去想「这个 Widget 在什么时机会收到这些消息」。 这部分逻辑高度绑定 Lumino 的布局和渲染机制。 在调试问题时也很有用：\n如果是「状态没同步过去」→ 大概率看 signaling 的连接和 emit。 如果是「界面渲染/尺寸不对」→ 大概率看 messaging 对 onResize / onUpdateRequest 是否按预期触发。 小结：为什么我愿意为这俩单独写一篇？ 对我个人来说，signaling 和 messaging 有点像 Lumino 这套体系里的“底噪”：\n不刻意关注的时候，你只会看到 Widget、Panel、DockPanel 这些“可视”的部分。 但真想在 Theia 里写点更贴近底层的扩展，或者想搞明白一些诡异的刷新/状态问题时，最后都会顺藤摸瓜摸到这两块。 写这一篇，更像是给自己立一个“心智坐标系”：\n以后看到 Signal / MessageLoop 相关的调用时，脑子里能立刻知道——\n这是在搭“谁对谁说话”的桥，还是在调度“什么时候说话”的节奏。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/lumino%E7%9A%84signaling%E5%92%8Cmessaging%E7%B3%BB%E7%BB%9F/","section":"docs","title":"Lumino 的 signaling 和 messaging：状态与生命周期的底噪"},{"body":"","link":"https://misakaJimmy.github.io/docs/database/postgresql/","section":"docs","title":"PostgreSQL"},{"body":" 这篇主要记录一下在 TypeScript 项目里引入 InversifyJS 需要做的配置，以及一些容易踩的坑。\n如果你在写 Theia 扩展，这些配置通常已经在 Theia 的模板项目里配好了，但理解一下背后的原理，对排查问题会很有帮助。\n安装依赖 通过 npm 或 yarn 安装 InversifyJS 和它的必需依赖：\n1yarn add inversify reflect-metadata 2# 或 3npm install inversify reflect-metadata 两个包的作用：\ninversify：InversifyJS 的核心库，包含 Container、装饰器等。 reflect-metadata：提供元数据反射 API 的 polyfill，InversifyJS 依赖它来读取装饰器生成的类型信息。 TypeScript 配置：开启装饰器支持 InversifyJS 依赖 TypeScript 的装饰器和元数据反射功能，所以需要在 tsconfig.json 里开启相关选项：\n1{ 2 \u0026#34;compilerOptions\u0026#34;: { 3 \u0026#34;experimentalDecorators\u0026#34;: true, 4 \u0026#34;emitDecoratorMetadata\u0026#34;: true, 5 \u0026#34;types\u0026#34;: [\u0026#34;reflect-metadata\u0026#34;] 6 } 7} 几个关键选项：\nexperimentalDecorators: true：启用装饰器语法（@injectable()、@inject() 等）。 emitDecoratorMetadata: true：让 TypeScript 在编译时生成类型元数据，这样 InversifyJS 才能知道构造函数参数的类型。 types: [\u0026quot;reflect-metadata\u0026quot;]：引入 reflect-metadata 的类型定义。 如果 emitDecoratorMetadata 没开启，InversifyJS 就无法自动推断构造函数参数的类型，必须手动用 @inject(Symbol) 标记每个参数，否则会报错。 引入 reflect-metadata 在应用入口文件的最顶部（在任何其他 import 之前），必须先引入 reflect-metadata：\n1import \u0026#34;reflect-metadata\u0026#34;; // 必须在最前面！ 2 3import { Container, injectable, inject } from \u0026#34;inversify\u0026#34;; 4// ... 其他代码 reflect-metadata 必须在所有其他代码之前引入，因为它会修改全局的 Reflect 对象。如果引入顺序不对，装饰器可能无法正常工作。 如果在浏览器环境里用 \u0026lt;script\u0026gt; 标签引入：\n1\u0026lt;script src=\u0026#34;./node_modules/reflect-metadata/Reflect.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 2\u0026lt;script src=\u0026#34;./your-app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 环境支持与 polyfills InversifyJS 需要一些现代 JavaScript 特性，大多数现代环境都支持，但如果你需要支持旧浏览器，可能需要 polyfill：\n必需特性 Metadata Reflection API：通过 reflect-metadata 包提供（已安装）。 Map：InversifyJS 3+ 需要，现代浏览器都支持。如果需要支持旧浏览器，可以用 es6-map 作为 polyfill。 可选特性（仅在特定场景需要） Promise：仅在用到“provider injection”（异步工厂注入）时需要。现代环境都支持，旧浏览器可以用 es6-promise 或 bluebird。 Proxy：仅在用到“activation handlers”（激活处理器）时需要。现代环境都支持，旧浏览器可以用 proxy-polyfill。 在 Theia 项目中的情况 如果你在写 Theia 扩展，通常不需要自己配置这些：\nTheia 的模板项目（通过 yo theia-extension 生成）已经配好了 tsconfig.json。 reflect-metadata 已经在 Theia 的入口文件里引入了。 你只需要在扩展代码里 import { injectable, inject } from \u0026quot;inversify\u0026quot; 就能直接用。 但理解这些配置的原理，对排查“为什么我的装饰器不生效”“为什么容器解析失败”这类问题会很有帮助。\n常见问题排查 如果遇到装饰器不生效的问题，按这个顺序检查：\nreflect-metadata 是否在最前面引入？\n检查入口文件，确保 import \u0026quot;reflect-metadata\u0026quot; 在所有其他 import 之前。\ntsconfig.json 配置是否正确？\n确认 experimentalDecorators 和 emitDecoratorMetadata 都是 true。\nTypeScript 版本是否太旧？\nInversifyJS 需要 TypeScript 2.0+，建议用 3.0+ 以获得更好的装饰器支持。\n构建工具配置是否正确？\n如果用的是 webpack/vite 等，确保它们能正确处理装饰器语法（通常需要配合 ts-loader 或 @babel/preset-typescript）。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/inversifyjs/install/","section":"docs","title":"在项目中引入 InversifyJS：配置与依赖"},{"body":" 这篇用一个经典的“忍者-武器”例子，展示如何从“手动 new 依赖”演进到“用 InversifyJS 做依赖注入”。\n这个例子虽然简单，但涵盖了 InversifyJS 最核心的概念：@injectable()、@inject()、Container、绑定关系。\n下面是一个可运行的完整示例，你可以在 CodeSandbox 里直接编辑和运行：\n代码解析：一步步理解依赖注入 第一步：定义服务标识符（Symbol） 1const TYPES = { 2 Ninja: Symbol(\u0026#39;Ninja\u0026#39;), 3 Katana: Symbol(\u0026#39;Katana\u0026#39;), 4 Shuriken: Symbol(\u0026#39;Shuriken\u0026#39;) 5}; 这里定义了三个 Symbol 作为服务标识符。在 InversifyJS 里，Symbol 是推荐的服务标识方式，因为：\n避免字符串冲突（两个不同的 Symbol 永远不会相等）。 在 TypeScript 里可以配合泛型做类型安全（container.bind\u0026lt;Interface\u0026gt;(TYPES.Service).to(Implementation)）。 在 Theia 里，你经常会看到类似的模式：\n1export const FileService = Symbol(\u0026#39;FileService\u0026#39;); 2export const CommandRegistry = Symbol(\u0026#39;CommandRegistry\u0026#39;); 第二步：定义业务类 1class Katana { 2 hit() { 3 return \u0026#39;cut!\u0026#39;; 4 } 5} 6 7class Shuriken { 8 throw() { 9 return \u0026#39;hit!\u0026#39;; 10 } 11} 12 13class Ninja { 14 private _katana: Katana; 15 private _shuriken: Shuriken; 16 17 constructor(katana: Katana, shuriken: Shuriken) { 18 this._katana = katana; 19 this._shuriken = shuriken; 20 } 21 22 fight() { 23 return this._katana.hit(); 24 } 25 26 sneak() { 27 return this._shuriken.throw(); 28 } 29} 这是三个普通的类：\nKatana（武士刀）和 Shuriken（手里剑）是“武器”类，各自有攻击方法。 Ninja（忍者）依赖这两个武器，通过构造函数注入。 传统写法的问题：如果不用依赖注入，你得这样创建 Ninja：\n1const katana = new Katana(); 2const shuriken = new Shuriken(); 3const ninja = new Ninja(katana, shuriken); 这样写的问题：\n每次创建 Ninja 都要手动 new 依赖，代码重复。 如果 Katana 或 Shuriken 的构造函数变了，所有创建 Ninja 的地方都要改。 测试时很难 mock 依赖（比如想测试 Ninja 但不想真的创建 Katana）。 第三步：标记类为可注入 1import * as inversify from \u0026#39;inversify\u0026#39;; 2import \u0026#39;reflect-metadata\u0026#39;; 3 4// 方式一：用 decorate 函数（适合不能直接用装饰器语法的场景） 5inversify.decorate(inversify.injectable(), Katana); 6inversify.decorate(inversify.injectable(), Shuriken); 7inversify.decorate(inversify.injectable(), Ninja); 8inversify.decorate(inversify.inject(TYPES.Katana), Ninja, 0); 9inversify.decorate(inversify.inject(TYPES.Shuriken), Ninja, 1); 这里用 decorate 函数手动给类添加装饰器：\ninversify.decorate(inversify.injectable(), Class)：标记类为“可注入的”。 inversify.decorate(inversify.inject(Symbol), Class, index)：标记构造函数的第 index 个参数需要注入哪个服务。 更常见的写法（装饰器语法）：\n1@injectable() 2class Katana { 3 hit() { 4 return \u0026#39;cut!\u0026#39;; 5 } 6} 7 8@injectable() 9class Shuriken { 10 throw() { 11 return \u0026#39;hit!\u0026#39;; 12 } 13} 14 15@injectable() 16class Ninja { 17 constructor( 18 @inject(TYPES.Katana) private _katana: Katana, 19 @inject(TYPES.Shuriken) private _shuriken: Shuriken 20 ) {} 21 22 fight() { 23 return this._katana.hit(); 24 } 25 26 sneak() { 27 return this._shuriken.throw(); 28 } 29} 这种写法更简洁，也是 Theia 里最常见的模式。\n第四步：注册绑定关系 1const container = new inversify.Container(); 2 3container.bind(TYPES.Ninja).to(Ninja); 4container.bind(TYPES.Katana).to(Katana); 5container.bind(TYPES.Shuriken).to(Shuriken); 这里创建了一个 Container（容器），然后把所有服务注册进去：\ncontainer.bind(Symbol).to(Class)：告诉容器“当需要 Symbol 标识的服务时，创建 Class 的实例”。 第五步：从容器获取实例 1const ninja = container.get\u0026lt;Ninja\u0026gt;(TYPES.Ninja); 2console.log(ninja.fight()); // 输出: \u0026#34;cut!\u0026#34; 3console.log(ninja.sneak()); // 输出: \u0026#34;hit!\u0026#34; 现在不需要手动 new 了，直接 container.get() 就能拿到 Ninja 实例，容器会自动：\n发现 Ninja 需要 Katana 和 Shuriken。 先创建 Katana 和 Shuriken 的实例。 把这两个实例传给 Ninja 的构造函数。 返回创建好的 Ninja 实例。 这个例子说明了什么？ 从传统写法到依赖注入，最大的变化是：\n之前：Ninja 的创建者需要知道它依赖什么，手动组装。 现在：Ninja 的创建者只需要说“给我一个 Ninja”，容器负责组装所有依赖。 这个模式在 Theia 里非常常见：\n1// Theia 扩展里，你只需要这样写： 2@injectable() 3export class MyContribution implements CommandContribution { 4 constructor( 5 @inject(CommandRegistry) private commands: CommandRegistry, 6 @inject(FileService) private fileService: FileService 7 ) {} 8 9 // ... 使用 commands 和 fileService 10} Theia 的容器会在启动时自动创建 MyContribution 实例，并注入它需要的 CommandRegistry 和 FileService，你不需要关心这些服务是怎么创建的、在哪里创建的。\n下一步：更复杂的场景 这个基础例子展示了最简单的依赖注入，但实际项目里还会遇到：\n接口绑定：绑定到接口而不是具体类（bind\u0026lt;Interface\u0026gt;(Symbol).to(Implementation)）。 作用域：单例（inSingletonScope()）vs 每次新建（inTransientScope()）。 命名绑定和标签：同一个接口有多个实现时如何区分。 可选注入：某些依赖可能不存在（@optional()）。 这些会在后续文章里展开。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/inversifyjs/base-ts-example/","section":"docs","title":"InversifyJS 基础示例：从传统依赖到依赖注入"},{"body":" 前面两篇分别把 Widget 本身和 signaling/messaging 这两条“底噪”线理了一遍，这篇就顺着往上走一层：\nDockPanel / SplitPanel / TabBar 这一整套布局 Widget，怎么在页面上拼出一个 IDE 风格的桌面感布局。\n布局的基本思路：一堆容器 Widget 叠罗汉 用一句话先概括 Lumino 的布局观：\n普通 Widget：负责“内容”。 各种 Panel / Bar：负责“怎么把这些内容排布在一个二维平面上”。 典型的几类：\nPanel：最基础的容器，内部可以挂多个子 Widget。 BoxPanel / SplitPanel：负责水平/垂直方向的分割和拉伸。 TabBar + TabPanel：提供多标签切换的 UI。 DockPanel：把分屏 + 停靠 + Tab 组合在一起，是 IDE 布局的核心。 在 Theia 这类 IDE 里面，最外层的 Shell 一般会持有一个根 DockPanel，然后根据区域（left/right/bottom/main）往里面塞不同 Widget。\nSplitPanel：最基础的“可拖动分隔条” 先从相对简单的 SplitPanel 说起，它提供了一条可以拖动的分隔线，把空间按比例切给多个子 Widget。\n1import { SplitPanel, Widget } from \u0026#39;@lumino/widgets\u0026#39;; 2 3// 创建几个简单的内容 Widget 4function createContent(label: string, color: string): Widget { 5 const w = new Widget(); 6 w.addClass(\u0026#39;my-SplitPanel-Item\u0026#39;); 7 w.node.textContent = label; 8 w.node.style.background = color; 9 return w; 10} 11 12const left = createContent(\u0026#39;Left Pane\u0026#39;, \u0026#39;#f5d0c5\u0026#39;); 13const right = createContent(\u0026#39;Right Pane\u0026#39;, \u0026#39;#c5d0f5\u0026#39;); 14 15// 创建一个水平 SplitPanel 16const split = new SplitPanel({ orientation: \u0026#39;horizontal\u0026#39; }); 17split.addWidget(left); 18split.addWidget(right); 19 20SplitPanel.setStretch(left, 1); // 左右各 1 份 21SplitPanel.setStretch(right, 1); 22 23Widget.attach(split, document.body); 几个要点：\norientation 决定分割方向：'horizontal' 或 'vertical'。 setStretch 可以简单控制每个子 Widget 占多大比例。 用户拖动中间的分隔条时，内部会通过 messaging 触发子 Widget 的 onResize，从而驱动重绘。 在 IDE 里，SplitPanel 更像是很底层的一块积木，DockPanel 其实就是在更复杂的场景下组合和管理这些分裂出来的区域。\nTabBar / TabPanel：一组 Widget 共用一个“框”，靠 Tab 切换 第二块积木是 Tab，一组 Widget 共享一个可见区域，通过标签切换：\n1import { TabPanel, Widget } from \u0026#39;@lumino/widgets\u0026#39;; 2 3function createTab(label: string): Widget { 4 const w = new Widget(); 5 w.addClass(\u0026#39;my-TabPanel-Item\u0026#39;); 6 w.node.textContent = label; 7 return w; 8} 9 10const panel = new TabPanel(); 11panel.addWidget(createTab(\u0026#39;Tab A\u0026#39;)); 12panel.addWidget(createTab(\u0026#39;Tab B\u0026#39;)); 13panel.addWidget(createTab(\u0026#39;Tab C\u0026#39;)); 14 15Widget.attach(panel, document.body); 16panel.currentIndex = 0; // 默认选中第一个 这里 TabPanel 内部会管理一个 TabBar，以及与之对应的内容区域：\nTabBar 负责上面那一排可点击的标签。 内容区域负责展示当前激活的那个 Widget。 在 IDE 布局里，这个模式最典型的应用就是“一个编辑区里打开多个文件”的场景：每个编辑器是一个 Widget，中间那排文件名就是 TabBar。\nDockPanel：把 Split + Tab 全打包了 真正让布局变得“桌面感爆表”的是 DockPanel：它把分屏（split）、停靠（dock）和 Tab 三种能力揉到了一起。\n一个最小可感受效果的例子：\n1import { DockPanel, Widget } from \u0026#39;@lumino/widgets\u0026#39;; 2 3function createDockWidget(label: string, color: string): Widget { 4 const w = new Widget(); 5 w.addClass(\u0026#39;my-DockPanel-Item\u0026#39;); 6 w.node.textContent = label; 7 w.node.style.background = color; 8 return w; 9} 10 11const dock = new DockPanel(); 12 13const w1 = createDockWidget(\u0026#39;Main\u0026#39;, \u0026#39;#fef3c7\u0026#39;); 14const w2 = createDockWidget(\u0026#39;Right-Top\u0026#39;, \u0026#39;#e0f2fe\u0026#39;); 15const w3 = createDockWidget(\u0026#39;Right-Bottom\u0026#39;, \u0026#39;#dcfce7\u0026#39;); 16 17// 第一个 Widget 作为初始内容 18dock.addWidget(w1); 19 20// 在右侧拆出一个区域 21dock.addWidget(w2, { mode: \u0026#39;split-right\u0026#39;, ref: w1 }); 22 23// 在右侧区域再次向下拆分 24dock.addWidget(w3, { mode: \u0026#39;split-bottom\u0026#39;, ref: w2 }); 25 26Widget.attach(dock, document.body); 这里的关键是第二个参数 options：\nmode 决定“怎么插入”： 'split-right' / 'split-left' / 'split-top' / 'split-bottom'：在对应方向拆出一个新区域。 'tab-after' / 'tab-before'：在同一区域新建一个 Tab。 ref 指定一个“参考 Widget”，表示你要相对谁进行拆分/停靠。 在 Theia 里，当你从视图菜单里打开某个面板（比如 Outline / Problems），或者把终端拖到底部区域时，背后基本都是对 DockPanel.addWidget 的各种组合调用。\n布局数据的持久化和恢复（IDE 必备套路） IDE 类应用一个很常见的需求是：记住用户怎么折腾布局的，下次打开时还原。\nLumino 为此提供了布局序列化的能力——可以把当前 DockPanel 的结构 dump 成一个 JSON，然后再 restore 回来。\n概念上大概是这样（简化伪代码）：\n1import { DockPanel } from \u0026#39;@lumino/widgets\u0026#39;; 2 3const dock = new DockPanel(); 4 5// ... 中间用户各种拖拽、拆分、合并 ... 6 7// 1. 导出布局（可以存到 localStorage 或服务器） 8const layout = dock.saveLayout(); 9localStorage.setItem(\u0026#39;layout\u0026#39;, JSON.stringify(layout)); 10 11// 2. 重新创建 DockPanel 时恢复布局 12const saved = localStorage.getItem(\u0026#39;layout\u0026#39;); 13if (saved) { 14 const layoutObj = JSON.parse(saved); 15 dock.restoreLayout(layoutObj); 16} Theia 自己在应用层还会加一层封装：\n不只是还原「长得怎样」，还要确保对应的 Widget 能重新创建出来并填充到正确位置，这里就会涉及到 ViewRegistry / WidgetFactory 之类的机制——这一块更偏 Theia 自身架构，可以等讲到 Theia Shell 时再展开。\n这些布局 Widget 在 Theia 里的大致落位 结合前两篇，再把这几个 Widget 放回 Theia 的语境里看一下（简化心智模型）：\nLumino 的 Widget / DockPanel / TabBar / SplitPanel： 负责“物理布局”和“窗口行为”——桌面感的来源。 Theia 更多是作为“使用者”和“组织者”，去告诉 Lumino 怎么摆这些砖。 Theia 自己的 Shell / View / Contribution 层： 决定“有哪些区域”“每个区域里塞什么 Widget”“这些视图怎么注册/销毁/还原”。 在合适的时机调用 dock.addWidget / restoreLayout 等接口。 所以在读 Theia 代码的时候，我的习惯是：\n一旦看到涉及“main/left/right/bottom area 布局”的地方，就自动联想到背后一定有 Lumino 的 DockPanel 在运作。 遇到拖拽 / 合并 / 分屏相关逻辑时，会先在 Lumino 这几个布局 Widget 里找“底层行为”，再看 Theia 是怎么在上层包一层自己的抽象的。 小结：把这几块积木认清楚，再看 IDE 布局就不那么迷幻了 从 Widget -\u0026gt; signaling/messaging -\u0026gt; 布局 Widget（DockPanel / SplitPanel / TabBar）这一串看下来，大概可以得到一个还算清晰的图景：\nWidget：长什么样、放什么内容。 signaling / messaging：内部怎么“说话”和“按节奏动起来”。 DockPanel / SplitPanel / TabBar：这些砖最后怎么拼成一个能分屏、能拖拽、能记住布局的桌面感 UI。 对我来说，把这几块单独拎出来写一篇，是为了以后再遇到奇怪的布局问题（比如：某个视图拖不对地方 / 重启之后布局错乱），脑子里能快速定位：\n到底是 Theia 应用层的“视图注册/还原”出了问题，还是 Lumino 那边的布局行为需要再去翻一遍源码。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/lumino%E7%9A%84%E5%B8%83%E5%B1%80%E7%B3%BB%E7%BB%9F_dockpanel_splitpanel_tabbar/","section":"docs","title":"Lumino 的布局系统：DockPanel / SplitPanel / TabBar 一条龙"},{"body":" 这篇主要补上一个在 Theia 里非常核心、但官方文档容易“一笔带过”的概念：\n服务标识符（Service Identifier）到底用什么？为什么 Theia 到处都在用 Symbol，而不是直接用字符串？接口是怎么参与进来的？\n服务标识符到底是干嘛用的？ 在 InversifyJS 里，每一次 bind(...) 本质上是在回答两个问题：\n“我要注册一个什么服务？”（服务标识符，Service Identifier） “这个服务的实现是谁？”（绑定目标，比如类/值/工厂） 例如：\n1const TYPES = { 2 FileService: Symbol(\u0026#39;FileService\u0026#39;), 3}; 4 5container.bind(TYPES.FileService).to(FileServiceImpl); 这里 TYPES.FileService 就是“服务标识符”，FileServiceImpl 是具体实现。\n之后所有地方只要通过这个标识符就能获得对应的服务实例：\n1@injectable() 2class MyContribution { 3 constructor(@inject(TYPES.FileService) private readonly fileService: FileService) {} 4} 为什么推荐用 Symbol 而不是字符串？ 理论上 InversifyJS 支持几种类型当作服务标识符：\n字符串（'FileService'） Symbol（Symbol('FileService')） 类本身（FileServiceImpl） 在 Theia 这种大型项目里，Symbol 几乎是默认选择，原因主要有三点：\n避免命名冲突\n字符串 'FileService' 可能在不同模块里被不小心复用； Symbol('FileService') 就算名字一样，本质上也是两个完全不同的值，不会冲突。 自然配合接口绑定\nTypeScript 接口在运行时会被擦除（没有值），不能直接当服务标识；\n用 Symbol 可以把“接口的抽象名”和“运行时的具体值”桥接起来：\n1export const FileService = Symbol(\u0026#39;FileService\u0026#39;); 2 3export interface FileService { 4 read(uri: string): Promise\u0026lt;string\u0026gt;; 5 // ... 6} 7 8@injectable() 9class NodeFileService implements FileService { /* ... */ } 10 11container.bind\u0026lt;FileService\u0026gt;(FileService).to(NodeFileService); 可读性 + IDE 支持更好\n用 export const Xxx = Symbol('Xxx') 的方式，很容易在项目里全局搜索； IDE 能帮你追踪这个标识符在哪里被 bind / inject。 Theia 中类似的例子到处都是，比如 CommandRegistry、MessageService 等。\n接口绑定：在类型层面隐藏实现细节 用接口 + Symbol 的典型模式如下：\n1// tokens.ts 2export const TYPES = { 3 FileService: Symbol(\u0026#39;FileService\u0026#39;), 4} as const; 5 6// file-service.ts 7export interface FileService { 8 read(uri: string): Promise\u0026lt;string\u0026gt;; 9 write(uri: string, content: string): Promise\u0026lt;void\u0026gt;; 10} 11 12@injectable() 13export class FileServiceImpl implements FileService { 14 async read(uri: string) { /* ... */ } 15 async write(uri: string, content: string) { /* ... */ } 16} 17 18// di-config.ts 19container.bind\u0026lt;FileService\u0026gt;(TYPES.FileService).to(FileServiceImpl).inSingletonScope(); 关键点：\nbind\u0026lt;FileService\u0026gt;(TYPES.FileService) 里的 \u0026lt;FileService\u0026gt; 只是编译期类型信息，运行时会被擦除；\n真正决定“这是什么服务”的，是 TYPES.FileService 这个 Symbol；\n任何地方想要用这个服务，只需要依赖接口 + 标识符即可：\n1@injectable() 2class MyContribution { 3 constructor(@inject(TYPES.FileService) private readonly fileService: FileService) {} 4 // ... 5} 这样做的好处是：\n业务代码对实现类完全无感；\n替换实现（比如改用远程文件服务）只要改一处绑定：\n1container.rebind\u0026lt;FileService\u0026gt;(TYPES.FileService).to(RemoteFileServiceImpl); 这和 Theia 中大量“接口 + Symbol + 实现类”的模式完全一致。\n类作为标识符 vs Symbol 作为标识符 在另一篇《用类本身作为服务标识符》里已经详细展开了，这里简单对比一下：\n类作为 ID：\n✅ 简单、直观、小项目里很方便； ❌ 不适合接口绑定、不适合复杂场景（如循环依赖）。 Symbol 作为 ID：\n✅ 更适合大型项目：接口绑定、替换实现、避免冲突； ✅ 与 Theia 的实践完全一致； ❌ 初学时多一步“定义 Symbol”，略显啰嗦。 如果你的目标是理解并对齐 Theia 的架构风格，用 Symbol + 接口是更值得投入精力掌握的一套模式。\n在 Theia 源码里可以怎么“练习找一找”？ 我自己在看 Theia 时，会刻意做这些小练习：\n找一个服务，比如 FileService 或 WorkspaceService，顺藤摸瓜看看：\n对应的服务标识符是在哪个文件里定义的（一般是 symbol.ts 或 types.ts 一类）； 接口和实现类分别在哪； 绑定是在哪个 *-frontend-module 或 *-backend-module 里完成的。 看一个扩展类（比如某个 *Contribution）的构造函数：\n哪些依赖是通过 @inject(TYPES.XXX) 注入进来的； 这些 TYPES.XXX 在哪被定义，和哪些服务实现绑定在一起。 对我来说，这种“在源码里玩连连看”的过程，基本就是把 InversifyJS 的抽象和 Theia 的实际工程串起来的过程——\n一旦对 Symbol + 接口绑定这套模式足够熟悉，再看 Theia 的依赖注入就会轻松很多。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/inversifyjs/inversifyjs_%E6%9C%8D%E5%8A%A1%E6%A0%87%E8%AF%86%E7%AC%A6%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%BB%91%E5%AE%9A_symbol%E4%B8%8E%E6%8E%A5%E5%8F%A3/","section":"docs","title":"InversifyJS：服务标识符与接口绑定（Symbol 与接口）"},{"body":" 前面几篇更多在讲“长什么样”（Widget / 布局）和“怎么动起来”（signaling / messaging），\n这篇换个角度，讲讲 Lumino 里另一条很关键的线：command 系统——也就是“把行为抽象成命令，再让各种入口去触发它”。\n先理解一下：为什么需要 command 系统？ 在 IDE 这种应用里，很多操作其实是同一个行为被不同入口复用，比如：\n“保存文件” 可以来自菜单、快捷键、命令面板、右键菜单、工具栏按钮…… “关闭当前标签” 既可以点击 Tab 上的小叉，也可以用快捷键，或者命令面板。 如果每个入口都自己绑一份逻辑，很快就会变成维护噩梦。\ncommand 系统做的事情就是：\n先用一个 全局唯一的 id 定义一个命令（以及它的 label、是否可用等信息）。 再在需要的地方“挂上入口”：菜单项、按钮、快捷键、命令面板…… 这样改行为只改命令本身，所有入口自然同步更新。\nCommandRegistry：命令的集中注册中心 Lumino 的命令系统核心是 CommandRegistry，看一个最小例子：\n1import { CommandRegistry } from \u0026#39;@lumino/commands\u0026#39;; 2 3const commands = new CommandRegistry(); 4 5// 1. 注册一个最简单的命令 6commands.addCommand(\u0026#39;app:hello\u0026#39;, { 7 label: \u0026#39;Say Hello\u0026#39;, 8 caption: \u0026#39;Print a hello message to console\u0026#39;, 9 isEnabled: () =\u0026gt; true, 10 execute: () =\u0026gt; { 11 console.log(\u0026#39;Hello from command!\u0026#39;); 12 }, 13}); 14 15// 2. 代码里任意地方都可以通过 id 来执行这个命令 16commands.execute(\u0026#39;app:hello\u0026#39;); 几个点：\n命令 id 一般用 'namespace:action' 这种风格，方便在大项目里避免冲突。 label 是展示在菜单 / 命令面板等 UI 上的文字。 isEnabled / isVisible / isToggled 可以用来控制命令当前是否可用、是否显示、是否处于“选中状态”，这在 IDE 里很常见。 从 Theia 的角度看，其实也有一套自己的 CommandRegistry / CommandContribution，设计思路和 Lumino 非常像，只是集成更深入到整个框架里。\n命令与快捷键：addKeyBinding、键盘处理与 FocusTracker 有了命令之后，下一件事情就是给它配快捷键，并且让这些快捷键只在“对的地方”生效。\n在 Lumino 里，命令和快捷键仍然由 CommandRegistry 负责，底下则依赖 @lumino/keyboard 和 FocusTracker 来协调：\n1import { CommandRegistry } from \u0026#39;@lumino/commands\u0026#39;; 2 3const commands = new CommandRegistry(); 4 5commands.addCommand(\u0026#39;file:save\u0026#39;, { 6 label: \u0026#39;Save File\u0026#39;, 7 execute: () =\u0026gt; { 8 console.log(\u0026#39;Saving file...\u0026#39;); 9 }, 10}); 11 12commands.addKeyBinding({ 13 keys: [\u0026#39;Accel S\u0026#39;], // Accel = Ctrl (Windows/Linux) or Cmd (macOS) 14 selector: \u0026#39;body\u0026#39;, 15 command: \u0026#39;file:save\u0026#39;, 16}); 要点：\nkeys 使用的是一种类似 VS Code 的按键描述：['Accel S'] / ['Ctrl Shift P'] / ['Alt Enter'] 等。 selector 是一个 CSS 选择器，表示当前事件发生在哪个元素上时，这个快捷键才生效。 例如只在某个容器内生效，可以用 '#editor' 等。 在底层，Lumino 会结合 @lumino/keyboard 对原生键盘事件做一些规范化处理（比如统一不同平台的修饰键表示），\n同时配合 FocusTracker 跟踪“当前活动 Widget”，从而决定哪些 keybinding 应该响应、哪些应该忽略。\n一个简化后的心智模型是：\nCommandRegistry 维护了一张「按键组合 → 命令 id」的映射表（加上 selector 过滤）。 键盘事件进来后先被标准化，再根据事件发生位置和当前 focus，去匹配对应的 keybinding； 一旦匹配成功，就回到 command 系统，执行那条命令。 Theia 在自己的命令/快捷键系统里也有类似概念：\n先定义命令，再绑定快捷键，UI 的各个部分只是“使用者”，不会直接关心行为细节；\n而哪个视图当前“有焦点”，由 FocusTracker 之类的机制来决定。\n命令与菜单/按钮：不同入口复用同一段逻辑 在 Widget 里你可以直接调用 commands.execute('id')，\n如果要做一个“命令按钮”，可以这么写一个小辅助 Widget（示意）：\n1import { CommandRegistry } from \u0026#39;@lumino/commands\u0026#39;; 2import { Widget } from \u0026#39;@lumino/widgets\u0026#39;; 3 4class CommandButton extends Widget { 5 constructor( 6 private commands: CommandRegistry, 7 private commandId: string 8 ) { 9 super({ node: document.createElement(\u0026#39;button\u0026#39;) }); 10 this.addClass(\u0026#39;my-CommandButton\u0026#39;); 11 } 12 13 protected onAfterAttach(msg: any): void { 14 this._render(); 15 this.node.addEventListener(\u0026#39;click\u0026#39;, this); 16 } 17 18 protected onBeforeDetach(msg: any): void { 19 this.node.removeEventListener(\u0026#39;click\u0026#39;, this); 20 } 21 22 handleEvent(event: Event): void { 23 if (event.type === \u0026#39;click\u0026#39;) { 24 void this.commands.execute(this.commandId); 25 } 26 } 27 28 private _render(): void { 29 const cmd = this.commands.listCommands().find(id =\u0026gt; id === this.commandId); 30 const label = this.commands.label(this.commandId) ?? this.commandId; 31 (this.node as HTMLButtonElement).textContent = label; 32 (this.node as HTMLButtonElement).disabled = !this.commands.isEnabled(this.commandId); 33 } 34} 这个例子有点简化，但表达了一个重要事实：\n按钮只是命令的一个“皮肤”，它关心的是：现在要显示什么文字、是否可点、点了之后执行哪个命令。\n菜单项同理，只不过一般会有一个菜单系统来批量把命令挂成 MenuItem。\n命令参数与上下文：不只是“开关”动作 命令系统真正好用的地方在于它不是只能做“无参动作”，而是可以携带参数与上下文：\n1commands.addCommand(\u0026#39;editor:close-file\u0026#39;, { 2 label: \u0026#39;Close File\u0026#39;, 3 execute: (args: { uri: string }) =\u0026gt; { 4 console.log(\u0026#39;Closing file:\u0026#39;, args.uri); 5 }, 6}); 7 8// 从不同地方用不同参数执行 9commands.execute(\u0026#39;editor:close-file\u0026#39;, { uri: \u0026#39;/path/to/a.ts\u0026#39; }); 10commands.execute(\u0026#39;editor:close-file\u0026#39;, { uri: \u0026#39;/path/to/b.ts\u0026#39; }); 在 IDE 里，很常见的模式是：\n命令本身只负责“干什么”。 谁来触发、用什么参数触发，由具体入口（当前选中的标签、右键菜单里的目标对象、命令面板里的上下文等）来决定。 Theia 在自己的 Command API 里也有类似的 executeCommand(id, ...args) 签名——这一层几乎可以一一对应到 Lumino 的命令设计上。\n在 Theia / Lumino 源码里看 command 的一些观察点 我个人在翻 Theia + Lumino 相关代码时，通常会刻意关注这些地方：\n命令 id 的命名空间： 不同模块一般会有自己的前缀，比如 file:*、editor:*、view:* 等，读起来更有方向感。 命令注册集中在哪儿： Theia 里通常有类似 CommandContribution 的地方集中注册命令。 Lumino 里则是你自己 new 一个 CommandRegistry，然后在初始化阶段把命令都挂上去。 快捷键和菜单是怎么“消费”这些命令的： 对着命令 id 往回找，可以很快看到有哪些入口会触发这条命令。 一旦搞清楚这条线，很多“这个按钮到底做了什么”“这个快捷键为什么不生效”的问题，就有比较清晰的排查路径了。\n小结：command 系统 = 行为的“中枢神经” 把前几篇加上这一篇连起来看，大概可以得到这样一幅图：\nWidget / 布局系统：决定“界面长什么样、东西摆在哪儿”。 signaling / messaging：决定“状态和生命周期怎么流动”。 command 系统：把具体“要做什么”从 UI 入口里抽出来，集中管理、复用和编排。 对我来说，理解 Lumino 的 command 系统最大的收益是：\n再看 Theia 的命令/菜单/快捷键那一坨代码时，脑子里有了一个更底层、更简洁的模型可以对照，知道哪些是框架通用模式，哪些才是 Theia 自己加的业务抽象。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/lumino%E7%9A%84command%E7%B3%BB%E7%BB%9F/","section":"docs","title":"Lumino 的 command 系统：把行为从按钮里解放出来"},{"body":" 前面几篇更多是把一块块“砖”（Widget、布局、command 等）单独拎出来看，\n这篇换个视角：把这些东西装进一个完整的 Lumino 应用里，顺带看看菜单栏、工具栏、右键菜单这些常见 UI 是怎么围绕 command 系统一起工作的。\n@lumino/application：把零散的能力装进一个 App 如果只用 @lumino/widgets，你完全可以手动 new 一个 DockPanel / BoxPanel，往里塞 Widget，然后挂到 document.body 上。\n但一旦你想要：\n全局的 CommandRegistry 和快捷键处理 顶部菜单栏（MenuBar） 右键菜单（ContextMenu） 工具栏、命令面板之类的“全局 UI” 就会发现需要一个更高级的“应用骨架”来帮你把这些拼在一起，这就是 @lumino/application 要做的事情。\n它的核心概念通常包括：\nApplication：整个 Lumino 应用的入口，负责启动、挂载、管理命令等。 Shell：应用的外壳，内部才是我们熟悉的布局（通常会内嵌一个 DockPanel 等）。 在 Theia 里你也能看到类似的影子：\n有一个 Application / FrontendApplication 的东西启动整套系统，然后有 ApplicationShell 作为 UI 壳。\n一个极简 Lumino Application 骨架 很多示例会这么写一个最小壳（伪代码略简化，只看结构）：\n1import { CommandRegistry } from \u0026#39;@lumino/commands\u0026#39;; 2import { DockPanel, Widget } from \u0026#39;@lumino/widgets\u0026#39;; 3import { Application } from \u0026#39;@lumino/application\u0026#39;; 4 5// 1. 定义一个简单的 Shell（内部有一个 DockPanel） 6class SimpleShell extends Widget { 7 readonly dock: DockPanel; 8 9 constructor() { 10 super(); 11 this.addClass(\u0026#39;my-SimpleShell\u0026#39;); 12 13 this.dock = new DockPanel(); 14 this.dock.id = \u0026#39;main-dock\u0026#39;; 15 16 // 把 dock 的 DOM 挂到 shell 的 node 上 17 this.node.appendChild(this.dock.node); 18 } 19} 20 21// 2. 定义 Application，指定 Shell 和 CommandRegistry 22class SimpleApplication extends Application\u0026lt;SimpleShell\u0026gt; { 23 constructor(options: Application.IOptions\u0026lt;SimpleShell\u0026gt;) { 24 super(options); 25 } 26} 27 28// 3. 启动应用 29const commands = new CommandRegistry(); 30const shell = new SimpleShell(); 31 32const app = new SimpleApplication({ 33 shell, 34 commands, 35}); 36 37window.addEventListener(\u0026#39;load\u0026#39;, () =\u0026gt; { 38 app.start(); // 挂载并启动整个应用 39}); 这里很多细节可以展开讲，但对我们来说，先记住两点就够了：\nApplication 负责 glue code：把命令、快捷键、菜单、shell 这些能力粘在一起。 Shell 负责布局容器：内部才是 DockPanel / SplitPanel / TabBar 等。 接下来就可以往这个骨架上挂菜单栏、工具栏、右键菜单了。\n菜单栏：Menu + MenuBar 菜单栏是 Lumino 里和 command 系统结合得最紧的一块 UI。\n基本思路是：\n用 Menu 代表一个下拉菜单（比如「文件」「编辑」）。 把这些 Menu 挂到 MenuBar 上。 每个菜单项对应一个命令 id。 一个简化示例：\n1import { CommandRegistry } from \u0026#39;@lumino/commands\u0026#39;; 2import { Menu, MenuBar } from \u0026#39;@lumino/widgets\u0026#39;; 3 4const commands = new CommandRegistry(); 5 6commands.addCommand(\u0026#39;file:new\u0026#39;, { 7 label: \u0026#39;New File\u0026#39;, 8 execute: () =\u0026gt; { 9 console.log(\u0026#39;New file\u0026#39;); 10 }, 11}); 12 13commands.addCommand(\u0026#39;file:open\u0026#39;, { 14 label: \u0026#39;Open File\u0026#39;, 15 execute: () =\u0026gt; { 16 console.log(\u0026#39;Open file\u0026#39;); 17 }, 18}); 19 20// 创建一个“文件”菜单 21const fileMenu = new Menu({ commands }); 22fileMenu.title.label = \u0026#39;File\u0026#39;; 23fileMenu.addItem({ command: \u0026#39;file:new\u0026#39; }); 24fileMenu.addItem({ command: \u0026#39;file:open\u0026#39; }); 25 26// 创建菜单栏并挂上去 27const menuBar = new MenuBar(); 28menuBar.addMenu(fileMenu); 29 30document.body.appendChild(menuBar.node); 要点：\nMenu 和 MenuBar 都依赖一个 CommandRegistry 实例，通过 command id 来渲染菜单项的 label / enabled 状态等。 一旦命令的 label/isEnabled 逻辑变了，菜单 UI 会自动跟着更新。 在 Theia 里，菜单栏同样是围绕 command 系统构建的，只不过多了层 MenuContribution / 配置化的菜单树；但底层这条“命令驱动菜单项”的思路是一致的。\n右键菜单：ContextMenu 右键菜单的使用体验和菜单栏类似，但触发方式是基于鼠标事件 + DOM 选择器。\nLumino 提供了一个 ContextMenu 帮你管理：\n1import { CommandRegistry } from \u0026#39;@lumino/commands\u0026#39;; 2import { ContextMenu } from \u0026#39;@lumino/widgets\u0026#39;; 3 4const commands = new CommandRegistry(); 5 6commands.addCommand(\u0026#39;editor:copy\u0026#39;, { 7 label: \u0026#39;Copy\u0026#39;, 8 execute: () =\u0026gt; { 9 console.log(\u0026#39;Copy!\u0026#39;); 10 }, 11}); 12 13const contextMenu = new ContextMenu({ commands }); 14 15// 针对特定区域注册右键菜单项 16contextMenu.addItem({ 17 command: \u0026#39;editor:copy\u0026#39;, 18 selector: \u0026#39;.my-Editor\u0026#39;, 19 rank: 1, 20}); 21 22// 全局监听 contextmenu 事件 23window.addEventListener(\u0026#39;contextmenu\u0026#39;, event =\u0026gt; { 24 contextMenu.open(event); 25}); 这里的关键点有两个：\nselector 决定了“在哪些 DOM 元素上右键，才会显示这条菜单项”。 ContextMenu 内部同样是通过 command id 去取 label / isEnabled / execute。 从 Theia 的视角看，右键菜单也是类似的套路：\n不同 view/contribution 注册自己的上下文菜单项，最终映射到同一个命令系统上。\n工具栏：一组“命令按钮”的容器 Lumino 没有强制你必须用某种 Toolbar 类型，你可以：\n直接用某个 Panel / Widget 当作工具栏容器； 在里面放一堆“命令按钮”——比如前面那篇 command 文里示意的 CommandButton Widget。 一个非常简化的伪代码例子：\n1import { CommandRegistry } from \u0026#39;@lumino/commands\u0026#39;; 2import { Panel, Widget } from \u0026#39;@lumino/widgets\u0026#39;; 3 4class CommandButton extends Widget { 5 constructor( 6 private commands: CommandRegistry, 7 private commandId: string 8 ) { 9 super({ node: document.createElement(\u0026#39;button\u0026#39;) }); 10 this.addClass(\u0026#39;my-CommandButton\u0026#39;); 11 } 12 13 protected onAfterAttach(msg: any): void { 14 this._render(); 15 this.node.addEventListener(\u0026#39;click\u0026#39;, this); 16 } 17 18 protected onBeforeDetach(msg: any): void { 19 this.node.removeEventListener(\u0026#39;click\u0026#39;, this); 20 } 21 22 handleEvent(event: Event): void { 23 if (event.type === \u0026#39;click\u0026#39;) { 24 void this.commands.execute(this.commandId); 25 } 26 } 27 28 private _render(): void { 29 const label = this.commands.label(this.commandId) ?? this.commandId; 30 (this.node as HTMLButtonElement).textContent = label; 31 (this.node as HTMLButtonElement).disabled = !this.commands.isEnabled(this.commandId); 32 } 33} 34 35// 工具栏容器 36const toolbar = new Panel(); 37toolbar.id = \u0026#39;main-toolbar\u0026#39;; 38 39toolbar.addWidget(new CommandButton(commands, \u0026#39;file:new\u0026#39;)); 40toolbar.addWidget(new CommandButton(commands, \u0026#39;file:open\u0026#39;)); 本质上，工具栏只是“水平摆了一排命令按钮的 Panel”，\n真正的行为还是集中在 command 系统里。\n在 Theia 中你也会看到各种 View/Editor 的 toolbar，本质上也是给某一组命令提供一块更显眼的入口区域。\n把这些拼回 Application 视角 如果把前面的东西都装回 Application 里，一个简化的心智模型大概是这样：\nApplication 创建并持有： 一个 CommandRegistry（命令与快捷键）。 一个 Shell（里面是 DockPanel 等布局）。 一个 MenuBar + 一个 ContextMenu + 若干工具栏 Widget。 Shell 负责给布局和各种视图（Widget）腾位置。 菜单栏 / 右键菜单 / 工具栏，仅仅是围绕 CommandRegistry 渲染 UI 的不同外壳。 Theia 则在这个基础上又往上盖了一层：\n有自己的 CommandContribution / MenuContribution 接口，让扩展可以注册命令和菜单，而不用直接操作 Lumino 的 API。 有抽象出来的 ApplicationShell，把 Lumino Shell 的细节再包一层，让 IDE 级的需求（多语言支持、view/container 抽象等）更好处理。 小结：Application + 菜单体系 = 把“命令世界”塞进一个真正的 App 到这篇为止，跟 Lumino 相关的几条主干大概就比较齐了：\nWidget / 布局系统：东西长什么样，摆在哪儿。 signaling / messaging：状态和生命周期的流动。 command 系统：行为的抽象与复用。 Application + 菜单 / 工具栏 / 右键菜单：把这些能力装进一个“完整应用壳”里。 对我来说，理解 @lumino/application 这一层最大的好处是：\n再看 Theia 的启动流程和 Shell 代码时，不会把“IDE 自己的那一层”与“Lumino 提供的通用骨架”混在一起，看见 Application/Shell/Menu/Command 这些词汇，脑子里都有一个明确的 Lumino 版本可以对照。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/lumino%E7%9A%84%E5%BA%94%E7%94%A8%E9%AA%A8%E6%9E%B6_application%E4%B8%8E%E8%8F%9C%E5%8D%95%E5%B7%A5%E5%85%B7%E6%A0%8F%E7%B3%BB%E7%BB%9F/","section":"docs","title":"Lumino 的应用骨架：Application + 菜单 / 工具栏 / 右键菜单"},{"body":" 前面我们一直用 Symbol 作为服务标识符，但 InversifyJS 也支持直接用类本身作为标识符。\n这种方式在某些场景下可以简化代码，但也有一些限制和陷阱。这篇就聊聊什么时候用类作为 ID，什么时候还是用 Symbol 更稳妥。\n类作为标识符的基本用法 当你用类作为服务标识时，不需要 @inject() 装饰器，因为 TypeScript 的元数据反射可以自动推断构造函数参数的类型：\n1import \u0026#34;reflect-metadata\u0026#34;; 2import { Container, injectable } from \u0026#34;inversify\u0026#34;; 3 4@injectable() 5class Katana { 6 public hit() { 7 return \u0026#34;cut!\u0026#34;; 8 } 9} 10 11@injectable() 12class Shuriken { 13 public throw() { 14 return \u0026#34;hit!\u0026#34;; 15 } 16} 17 18@injectable() 19class Ninja { 20 private _katana: Katana; 21 private _shuriken: Shuriken; 22 23 public constructor(katana: Katana, shuriken: Shuriken) { 24 this._katana = katana; 25 this._shuriken = shuriken; 26 } 27 28 public fight() { 29 return this._katana.hit(); 30 } 31 32 public sneak() { 33 return this._shuriken.throw(); 34 } 35} 36 37const container = new Container(); 38container.bind\u0026lt;Katana\u0026gt;(Katana).to(Katana); 39container.bind\u0026lt;Shuriken\u0026gt;(Shuriken).to(Shuriken); 40container.bind\u0026lt;Ninja\u0026gt;(Ninja).to(Ninja); 41 42const ninja = container.get\u0026lt;Ninja\u0026gt;(Ninja); 43console.log(ninja.fight()); // \u0026#34;cut!\u0026#34; 注意几个点：\nNinja 的构造函数参数没有 @inject() 装饰器，但容器依然能正确注入 Katana 和 Shuriken。 绑定时直接用类作为标识：container.bind\u0026lt;Katana\u0026gt;(Katana).to(Katana)。 获取时也用类：container.get\u0026lt;Ninja\u0026gt;(Ninja)。 使用 toSelf() 简化绑定 如果要绑定的类型是具体类（不是接口），绑定语句会显得重复：\n1container.bind\u0026lt;Samurai\u0026gt;(Samurai).to(Samurai); // 重复了 可以用 toSelf() 简化：\n1container.bind\u0026lt;Samurai\u0026gt;(Samurai).toSelf(); // 更简洁 这在绑定很多具体类时会减少重复代码。\n已知局限性：循环依赖的问题 类作为标识符最大的坑是循环依赖。看这个例子：\n1import \u0026#34;reflect-metadata\u0026#34;; 2import { Container, injectable } from \u0026#34;inversify\u0026#34;; 3 4@injectable() 5class Dom { 6 public domUi: DomUi; 7 constructor(domUi: DomUi) { 8 this.domUi = domUi; 9 } 10} 11 12@injectable() 13class DomUi { 14 public dom: Dom; 15 constructor(dom: Dom) { 16 this.dom = dom; 17 } 18} 19 20const container = new Container(); 21container.bind\u0026lt;Dom\u0026gt;(Dom).toSelf().inSingletonScope(); 22container.bind\u0026lt;DomUi\u0026gt;(DomUi).toSelf().inSingletonScope(); 23 24const dom = container.get\u0026lt;Dom\u0026gt;(Dom); // Error! 会抛出类似这样的错误：\nError: Missing required @Inject or @multiinject annotation in: argument 0 in class Dom. 为什么会报错？\n当使用类作为服务标识时，InversifyJS 依赖 TypeScript 的元数据反射来推断类型。但在循环依赖的场景下：\n装饰器执行时，Dom 和 DomUi 可能还没完全初始化。 元数据反射可能读到 undefined，导致 InversifyJS 认为缺少 @inject() 注解。 即使你手动加上 @inject(Dom) 或 @inject(DomUi)，也可能因为装饰器执行顺序问题，依然报错。 解决方案：用 Symbol 作为标识符\n1import \u0026#34;reflect-metadata\u0026#34;; 2import { Container, injectable, inject } from \u0026#34;inversify\u0026#34;; 3 4const TYPES = { 5 Dom: Symbol(\u0026#34;Dom\u0026#34;), 6 DomUi: Symbol(\u0026#34;DomUi\u0026#34;) 7}; 8 9@injectable() 10class Dom { 11 public domUi: DomUi; 12 constructor(@inject(TYPES.DomUi) domUi: DomUi) { 13 this.domUi = domUi; 14 } 15} 16 17@injectable() 18class DomUi { 19 public dom: Dom; 20 constructor(@inject(TYPES.Dom) dom: Dom) { 21 this.dom = dom; 22 } 23} 24 25const container = new Container(); 26container.bind\u0026lt;Dom\u0026gt;(TYPES.Dom).to(Dom).inSingletonScope(); 27container.bind\u0026lt;DomUi\u0026gt;(TYPES.DomUi).to(DomUi).inSingletonScope(); 28 29const dom = container.get\u0026lt;Dom\u0026gt;(TYPES.Dom); // 正常工作 用 Symbol 作为标识符，即使有循环依赖也能正常工作，因为 Symbol 在定义时就已经是确定的值了。\n在 Theia 里的实践建议 从我读 Theia 源码的观察来看，Theia 几乎全部用 Symbol 作为服务标识符，很少直接用类。原因包括：\n接口绑定更灵活：Theia 里很多服务都是绑定到接口的（bind\u0026lt;IFileService\u0026gt;(TYPES.FileService).to(FileService)），这样测试时可以轻松替换实现。 避免循环依赖陷阱：大型项目里很难保证没有循环依赖，用 Symbol 更稳妥。 类型安全更好：Symbol + 泛型可以做到“编译时就知道绑定关系是否正确”。 所以我的建议是：\n简单项目、没有循环依赖、不需要接口绑定：可以用类作为标识符，代码更简洁。 复杂项目、可能有循环依赖、需要接口绑定：还是用 Symbol 更稳妥，这也是 Theia 的选择。 小结 类作为服务标识符是 InversifyJS 提供的一个便利特性，可以简化某些场景下的代码。但要注意：\n✅ 适合：简单依赖、具体类绑定、没有循环依赖。 ❌ 不适合：循环依赖、接口绑定、需要灵活替换实现。 在 Theia 这种大型项目里，Symbol 作为标识符是更主流、更安全的选择。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/inversifyjs/classes-as-id/","section":"docs","title":"用类本身作为服务标识符：简化绑定的另一种方式"},{"body":" 这篇补上 InversifyJS 里另一个经常被忽略、但在 Theia 这种长跑型应用里非常关键的点：\n作用域（Scope）和生命周期（Lifetime）——一个服务是全局单例，还是每次来一个新的？会不会不小心创建太多？\n三种常见作用域 InversifyJS 里最常用的几个作用域是：\nTransient（默认）：每次 container.get() 都创建一个新实例。 Singleton：整个容器生命周期内只有一个实例。 Request：每个“请求”范围内共享一个实例（更多用于服务端场景，Theia 前端里不常用）。 先看一个最简单的例子：\n1@injectable() 2class Counter { 3 public value = 0; 4} 5 6container.bind(Counter).toSelf(); // 默认 transient 7 8const c1 = container.get(Counter); 9const c2 = container.get(Counter); 10 11console.log(c1 === c2); // false 如果我们希望 Counter 在整个应用中是单例，可以这样写：\n1container.bind(Counter).toSelf().inSingletonScope(); 2 3const a = container.get(Counter); 4const b = container.get(Counter); 5 6console.log(a === b); // true 在 Theia 里，哪些东西应该是单例？ 在 Theia 源码里，大多数“服务”（Service）都是单例，比如：\nCommandRegistry MenuModelRegistry WorkspaceService FileService 各种 *Contribution（命令、菜单、键位、视图贡献等） 原因很直接：\n它们代表的是“全局状态”或“全局入口”：一个应用只需要也只应该有一个； 单例可以避免状态不一致（比如两个不同的 WorkspaceService 各自维护一套工作区信息）。 典型绑定写法：\n1container.bind\u0026lt;WorkspaceService\u0026gt;(WorkspaceService).to(WorkspaceServiceImpl).inSingletonScope(); 或者在 Theia 源码里，经常会看到类似：\n1bind(WorkspaceService).toSelf().inSingletonScope(); 2bind(WorkspaceFrontendContribution).toSelf().inSingletonScope(); 3bind(FrontendApplicationContribution).toService(WorkspaceFrontendContribution); 这里 WorkspaceFrontendContribution 是单例，然后通过 toService 暴露为某个接口的一种实现。\n哪些场景更适合 transient（每次一个新实例）？ 也有一些对象更适合 transient，比如：\n临时的对话框 / 表单视图； 某些“短生命周期”的 helper 对象； 为每个请求/任务创建的 handler（前端少见，后端更多）。 在 Theia 里，很多 UI Widget 其实是由工厂创建，而不是直接从容器 get() 出来，这时通常会结合工厂模式使用：\n1export const MyWidgetFactory = Symbol(\u0026#39;MyWidgetFactory\u0026#39;); 2 3export type MyWidgetFactory = () =\u0026gt; MyWidget; 4 5bind(MyWidget).toSelf(); // 默认 transient：每次创建新实例 6bind(MyWidgetFactory).toFactory\u0026lt;MyWidget\u0026gt;(ctx =\u0026gt; () =\u0026gt; { 7 return ctx.container.get(MyWidget); 8}); 这样每次调用 factory() 都会拿到一个新的 MyWidget，非常适合“多窗口、多视图”的场景。\n生命周期与资源释放：和 disposable 的关系 前一篇《disposable 与组件生命周期》里已经提过：\n作用域决定“这个对象会活多久”，而 disposable 决定“它在寿终正寝时要怎么收尾”。\n在结合使用时，几个常见点是：\n单例服务里经常会： 持有对其它服务/事件源的引用； 在 dispose() 里统一注销监听、取消注册、清理资源。 transient 对象（比如临时 Widget）： 生命周期通常由 Shell/Layout 控制； 在 Widget 的 dispose() / onBeforeDetach 里收尾。 Theia 里很多 binding 会同时指定作用域 + 实现 IDisposable 接口，这两个概念配合起来才算一个完整的“生命周期管理方案”。\n在 Theia 源码里如何“感受”这些作用域？ 如果你想在 Theia 源码里训练一下对作用域的直觉，可以尝试：\n找一些 bind(...).inSingletonScope() 的地方，看对应类型是做什么的：\n通常是“核心服务/贡献点”，比如 FrontendApplicationContribution 的各种实现。 找一些没有指定作用域、或者专门用工厂创建的类型：\n通常是 Widget 或 UI 组件，生命周期交给布局系统管理。 在调试时打印对象引用：\n比如在多个地方注入同一个服务，console.log(service === otherService) 验证是不是单例。 对我来说，理解 InversifyJS 的作用域之后，再看 Theia 的绑定文件时会更有安全感：\n知道哪些对象应该只存在一份，哪些对象应该按需创建，而不是靠“印象”猜。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/inversifyjs/inversifyjs_%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F_singleton_transient/","section":"docs","title":"InversifyJS：作用域与生命周期（Singleton / Transient 等）"},{"body":" 前几篇基本都站在“Lumino 自己的一亩三分地”里看，这篇稍微往外看一步：\nLumino 的 @lumino/virtualdom 是什么东西，它和 React/Vue 这种主流框架的 VDOM 有什么不一样，以及如果项目里已经用了 React/Vue，要怎么和 Lumino 玩到一起。\n@lumino/virtualdom 是什么？ 官方的定位很简单：一个极轻量的 Virtual DOM 实现，主要服务于 Lumino 自己的 Widget 体系。\n使用方式大致是：\n用 h() 函数描述一棵虚拟节点树； 调用 VirtualDOM.render() 把这棵树“打补丁”到某个真实 DOM 节点下； Lumino 内部的一些 Widget（比如菜单、命令面板等）都是用这套 VDOM 来写渲染逻辑的。 一个最小例子（只看基本感受）：\n1import { h, VirtualDOM } from \u0026#39;@lumino/virtualdom\u0026#39;; 2 3const vnode = h.div( 4 { className: \u0026#39;my-box\u0026#39; }, 5 h.h1(\u0026#39;Hello Lumino virtualdom\u0026#39;), 6 h.p(\u0026#39;This is a simple paragraph.\u0026#39;), 7); 8 9// 把虚拟节点渲染到某个容器里 10const host = document.getElementById(\u0026#39;app\u0026#39;)!; 11VirtualDOM.render(vnode, host); 特点很明显：\nAPI 风格有点像 React 的 createElement，但借助 h.tagName() 简化了一些。 不搞组件生命周期、状态管理、hook 之类的大系统，只负责“描述一棵树，然后高效地 patch 到 DOM 上”。 和 React/Vue 的对比：它刻意“不长大”的地方 我自己的理解是：Lumino 的 virtualdom 更像是“给框架内部组件用的工具库”，而不是一个完整的 UI 框架。\n对比 React/Vue，一些明显的差异：\n无组件状态/生命周期抽象\nReact 有 setState / hooks、类组件生命周期； Vue 有响应式数据系统、watch、computed 等； Lumino virtualdom 完全不管“数据从哪来、什么时候更新”，它只管接收一棵 VNode 树，然后渲染/更新。 无路由 / 全家桶生态\nReact/Vue 的生态里会自然长出 Router、Store（Redux/Vuex/Pinia）、Form 等各种东西； Lumino virtualdom 刻意保持“只做 VDOM 打补丁”的小工具姿态——状态、路由、数据流全交给外面的世界（比如 Widget / 应用）。 和 Lumino Widget 深度绑定，而不是面向浏览器全局\n在很多 Lumino Widget 里，渲染代码是 VirtualDOM.render(this.render(), this.node) 这样的调用； 即：Widget 负责生命周期和状态，virtualdom 只是帮它把 “render() 返回的描述” 变成 DOM。 从阅读源码的角度看，这种设计有一个好处：\n你在 Widget 里还是用 imperative（命令式）逻辑管理状态、调用 update()，只是把 DOM 细节交给 VDOM 去算 diff。\n在 Widget 里使用 virtualdom：一个完整小例子 结合前面 Widget 的生命周期，可以写一个“小型 React 风味”的 Widget：\n1import { Widget } from \u0026#39;@lumino/widgets\u0026#39;; 2import { h, VirtualDOM } from \u0026#39;@lumino/virtualdom\u0026#39;; 3 4class CounterWidget extends Widget { 5 private _count = 0; 6 7 constructor() { 8 super(); 9 this.addClass(\u0026#39;my-VdomCounter\u0026#39;); 10 } 11 12 protected onAfterAttach(msg: any): void { 13 this._render(); 14 this.node.addEventListener(\u0026#39;click\u0026#39;, this); 15 } 16 17 protected onBeforeDetach(msg: any): void { 18 this.node.removeEventListener(\u0026#39;click\u0026#39;, this); 19 } 20 21 handleEvent(event: Event): void { 22 if (event.type === \u0026#39;click\u0026#39;) { 23 this._count++; 24 this.update(); // 会触发 onUpdateRequest 25 } 26 } 27 28 protected onUpdateRequest(msg: any): void { 29 this._render(); 30 } 31 32 private _render(): void { 33 const vnode = h.div( 34 { className: \u0026#39;counter-root\u0026#39; }, 35 h.h1(`Count: ${this._count}`), 36 h.p(\u0026#39;点击任意位置增加计数\u0026#39;), 37 ); 38 39 VirtualDOM.render(vnode, this.node); 40 } 41} 这里你可以看到：\n没有 React 的 useState / setState，状态就是类字段 _count。 更新时手动调用 this.update()，然后在 onUpdateRequest 里重新走一遍 _render()。 _render() 里完全用 VDOM 来描述 DOM 结构，VirtualDOM 负责做 diff + patch。 这对于已经习惯 React/Vue 的人来说，既有点熟悉，又保留了 Lumino 自己的“Widget 主导一切”的感觉。\n如果工程里已经有 React/Vue，要怎么和 Lumino 配合？ 现实世界里更常见的情况是：项目主 UI 框架已经是 React/Vue，但希望用 Theia/Lumino 提供的 IDE 壳能力，或者反过来在 Lumino/Theia 里嵌入一块 React/Vue 视图。\n我目前比较认可的几种组合方式：\n1. Lumino 作为“外壳”，React/Vue 作为内部视图 思路：\n用 Lumino 的 Widget / DockPanel / command / 菜单等搭出外壳； 写一个“桥接 Widget”，在它的 DOM 节点内挂载 React/Vue 组件。 伪代码示例（React 版）：\n1// Lumino 侧 Widget 2import { Widget } from \u0026#39;@lumino/widgets\u0026#39;; 3import React from \u0026#39;react\u0026#39;; 4import { createRoot, Root } from \u0026#39;react-dom/client\u0026#39;; 5import { MyReactPanel } from \u0026#39;./MyReactPanel\u0026#39;; 6 7class ReactHostWidget extends Widget { 8 private _root: Root | null = null; 9 10 constructor() { 11 super(); 12 this.addClass(\u0026#39;my-ReactHostWidget\u0026#39;); 13 } 14 15 protected onAfterAttach(msg: any): void { 16 this._root = createRoot(this.node); 17 this._root.render(\u0026lt;MyReactPanel /\u0026gt;); 18 } 19 20 protected onBeforeDetach(msg: any): void { 21 this._root?.unmount(); 22 this._root = null; 23 } 24} 关键点：\n在 Widget 的生命周期里挂/卸 React/Vue 应用，这样不会和 Lumino 的 attach/detach 打架。 这时你基本不会再用 @lumino/virtualdom，而是让 React 自己管理这块子树。 Theia 社区里已经有不少扩展就是这么做的：\n核心壳用 Lumino/Theia，业务视图用 React/Vue，这样既能享受 IDE 级的布局和命令系统，又能复用已有的组件库和生态。\n2. React/Vue 作为主 UI，Lumino 组件嵌进去（不太常见但可以） 反过来的情况也存在：你的应用主架子是 React/Vue，只想要一块 Lumino 的 DockPanel / datagrid。\n典型做法：\n在 React/Vue 组件里，用一个 ref 拿到 DOM 容器； 在 onMounted / useEffect 里创建 Lumino Widget，并用 Widget.attach 挂进去； 在组件卸载时调用相应的 dispose / detach。 伪代码就不展开了，思路和上一节是镜像关系——只是这回由 React/Vue 管生命周期，Lumino 当 guest。\n3. virtualdom 自己 + React/Vue 混用？不推荐硬混 理论上你可以在某个 Widget 里一会儿用 VirtualDOM.render，一会儿又在子节点里挂 React/Vue，\n只要边界划清楚（谁管哪棵 DOM 子树）就不会直接冲突。\n但从工程实践角度看，我更建议：\n要么这一块完全交给 React/Vue（Widget 只当壳）； 要么这一块完全用 Lumino virtualdom； 避免在同一小块 UI 里又 VDOM 又 React/Vue，调试起来很烧脑。 和 React/Vue 相比，什么时候更适合用 Lumino 自己的 virtualdom？ 结合这几篇的上下文，我自己的结论是：\n如果这块 UI 高度和 Lumino Widget / DockPanel / command 系统一体化，比如：\n菜单、命令面板、内置对话框； 和布局、焦点、命令密切耦合的小组件；\n那直接用 Lumino virtualdom 是最自然的选择。 如果这块 UI 更像一个独立业务模块，比如：\n复杂表单、可视化、业务面板； 已经有一整套 React/Vue 组件可以直接拿来用；\n那就让 React/Vue 当里面的“小世界”，Lumino 当外壳就好。 从学习角度看，搞明白 Lumino virtualdom 的价值在于：\n再读 Lumino 和 Theia 一些“看起来像 React，又不是 React”的组件实现时，脑子里会有个更清晰的模型； 真要在 IDE 壳里嵌 React/Vue，也知道边界应该画在哪儿、哪些该交给谁来管。 ","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/lumino%E7%9A%84virtualdom_%E4%B8%8Ereact_vue%E7%9A%84%E5%AF%B9%E6%AF%94%E4%B8%8E%E7%BB%93%E5%90%88/","section":"docs","title":"Lumino 的 virtualdom：轻量 VDOM、对比 React/Vue 以及如何结合使用"},{"body":" 这一篇专门把 bind() 的几种常见变体过一遍：\nto、toSelf、toConstantValue、toDynamicValue、toFactory、toProvider，\n并顺带聊聊它们在 Theia 这种长跑型应用里的典型用法。\n1. to：最常见的“接口 → 实现类”绑定 这是你最常见到的形式：\n1container.bind\u0026lt;IFileService\u0026gt;(TYPES.FileService).to(FileServiceImpl).inSingletonScope(); 含义很直接：\n当有人 @inject(TYPES.FileService) 时，容器会 new 一个 FileServiceImpl 给他； 结合 inSingletonScope() 使用，就变成“整个容器里只有一个 FileServiceImpl 实例”。 在 Theia 里，大多数“核心服务”的绑定都是这种形式，例如 WorkspaceService、FileService、CommandRegistry 等。\n2. toSelf：具体类自己就是标识符 当你不需要接口 + Token 这层抽象时，可以用类本身作为标识符：\n1@injectable() 2class WorkspaceService { /* ... */ } 3 4container.bind(WorkspaceService).toSelf().inSingletonScope(); 5 6const svc = container.get(WorkspaceService); 这相当于：\n1container.bind\u0026lt;WorkspaceService\u0026gt;(WorkspaceService).to(WorkspaceService); 只是更简洁一些。\n在 Theia 里，经常会看到先用 toSelf() 绑定自身，再通过 toService() 暴露为某个接口的实现：\n1bind(MyContribution).toSelf().inSingletonScope(); 2bind(FrontendApplicationContribution).toService(MyContribution); 这表示：\nContainer 里有一个单例的 MyContribution； 任何地方如果注入 FrontendApplicationContribution[]，会拿到这个 MyContribution 实例作为其中一员。 3. toConstantValue：绑定常量/配置/单例对象 有些东西你并不希望容器帮你 new，而是希望直接把一个现成的值塞进容器，例如配置对象、全局常量等：\n1const config = { 2 apiBaseUrl: \u0026#39;https://api.example.com\u0026#39;, 3 featureFlags: { newUI: true }, 4}; 5 6container.bind(TYPES.AppConfig).toConstantValue(config); 之后注入：\n1@injectable() 2class HttpClient { 3 constructor( 4 @inject(TYPES.AppConfig) private readonly config: AppConfig, 5 ) {} 6} 特点：\n容器不会 new，它只是在内部存了一个引用； 非常适合用来传递“只读配置”“上下文对象”等。 在 Theia 里，也有类似把 FrontendApplicationConfig 这样东西通过 DI 暴露出去的模式（虽然有些是通过专门的 provider 服务包装）。\n4. toDynamicValue：按需、惰性、基于上下文生成实例 toDynamicValue 是一个非常灵活的选项：\n它允许你通过一个函数来生成实例，可以访问容器上下文、环境变量等。\n1container.bind(TYPES.Clock).toDynamicValue(() =\u0026gt; ({ 2 now: () =\u0026gt; new Date(), 3})); 或者需要用到容器中其它服务时：\n1container.bind(TYPES.ServiceWithDeps).toDynamicValue(ctx =\u0026gt; { 2 const dep = ctx.container.get(TYPES.OtherService); 3 return new ServiceWithDeps(dep, Date.now()); 4}); 适用场景：\n需要基于运行时环境做决定（比如 dev / prod 模式选择不同实现）； 需要访问容器里的其它绑定，但又不想把这些依赖写进构造函数里（某些 legacy 场景）。 在 Theia 里，很多时候会优先选择“普通 to() + 构造函数注入”，\ntoDynamicValue 更像是你在做一些适配/桥接层时的高级选项。\n5. toFactory：返回一个“工厂函数” 当你需要一个**“按需创建实例的工厂”**时，可以用 toFactory：\n1export const TYPES = { 2 WidgetFactory: Symbol(\u0026#39;WidgetFactory\u0026#39;), 3} as const; 4 5@injectable() 6class MyWidget { /* ... */ } 7 8container.bind(MyWidget).toSelf(); // transient: 每次 get 都是新的 9 10container.bind\u0026lt;() =\u0026gt; MyWidget\u0026gt;(TYPES.WidgetFactory).toFactory(ctx =\u0026gt; { 11 return () =\u0026gt; ctx.container.get(MyWidget); 12}); 使用：\n1@injectable() 2class SomeContribution { 3 constructor( 4 @inject(TYPES.WidgetFactory) 5 private readonly widgetFactory: () =\u0026gt; MyWidget, 6 ) {} 7 8 openView() { 9 const widget = this.widgetFactory(); 10 // 把 widget 加到布局中 11 } 12} 在 Theia 里，很多 Widget 的创建就是通过类似的“WidgetFactory”完成的（有时是 Theia 自己封装的 widget factory token），\n这样可以让布局系统在需要时创建新视图，而不是一开始就 new 好所有东西。\n6. toProvider：支持异步创建（返回 Promise 的工厂） toProvider 和 toFactory 类似，但更偏异步场景：\n它返回一个异步函数（通常是 () =\u0026gt; Promise\u0026lt;T\u0026gt; 或 (args) =\u0026gt; Promise\u0026lt;T\u0026gt;）。\n1import { Provider } from \u0026#39;inversify\u0026#39;; 2 3export const TYPES = { 4 RemoteDataProvider: Symbol(\u0026#39;RemoteDataProvider\u0026#39;), 5} as const; 6 7container.bind\u0026lt;Provider\u0026lt;Data\u0026gt;\u0026gt;(TYPES.RemoteDataProvider).toProvider\u0026lt;Data\u0026gt;(ctx =\u0026gt; { 8 return async () =\u0026gt; { 9 const http = ctx.container.get(HttpClient); 10 const resp = await http.get(\u0026#39;/data\u0026#39;); 11 return resp.data as Data; 12 }; 13}); 使用：\n1@injectable() 2class DataConsumer { 3 constructor( 4 @inject(TYPES.RemoteDataProvider) 5 private readonly getData: () =\u0026gt; Promise\u0026lt;Data\u0026gt;, 6 ) {} 7 8 async load() { 9 const data = await this.getData(); 10 // ... 11 } 12} 适用场景：\n需要延迟加载某些重资源（例如远程数据、惰性初始化组件）； 需要把“获取过程”本身抽象成 DI 提供的能力，而不是在消费方硬编码 fetch 逻辑。 在 Theia 中，部分“provider 风格”的功能（例如某些异步服务获取）可以用类似思路实现，\n不过核心框架本身更多使用普通 to() + async 方法组合。\n小结：选哪种绑定，取决于“对象是谁创建的”和“何时创建” 从我自己的使用体验来看，可以用一句话来记住这些绑定方式的差异：\nto / toSelf：\n“这个类由容器来 new，生命周期由作用域控制”——最常见的服务/组件绑定。 toConstantValue：\n“这个值是现成的配置/单例，容器只负责转发引用”。 toDynamicValue：\n“创建逻辑比较特殊，或者需要访问运行时上下文/容器本身时，用它兜一下”。 toFactory / toProvider：\n“我需要一个能在以后某个时刻再创建实例（同步/异步）的函数”。 在 Theia 这种架构里，大部分时候你会只用到 to / toSelf + 作用域 + Symbol/接口绑定；\n但一旦遇到工厂、异步加载、运行时选择实现这类稍微复杂一点的需求，这些额外的绑定方式就能帮你少写很多胶水代码。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/inversifyjs/inversifyjs_%E5%A4%9A%E7%A7%8D%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F_to_toself_toconstant_todynamic_tofactory_toprovider/","section":"docs","title":"InversifyJS：多种绑定方式（to / toSelf / toConstantValue / toDynamicValue / toFactory / toProvider）"},{"body":" 前面在讲 Widget / signaling / messaging 的时候，其实一直有个“隐身角色”：\n谁来负责把事件监听、定时器、模型订阅这些东西在合适的时机清掉？\n这篇就从 @lumino/disposable 讲起，顺便把几类常见组件的生命周期串一遍。\n@lumino/disposable：一个很小但到处都在用的模式 @lumino/disposable 暴露的大致内容很简单：\nIDisposable 接口：只有一个 dispose(): void 方法； DisposableDelegate：包装一个 () =\u0026gt; void 的小工具，dispose() 时调用这个函数； DisposableSet：一组 disposable 的集合，可以一次性 dispose() 全部。 最朴素的用法是：\n1import { DisposableDelegate, DisposableSet } from \u0026#39;@lumino/disposable\u0026#39;; 2 3// 单个 disposable：包一段“清理逻辑” 4const d1 = new DisposableDelegate(() =\u0026gt; { 5 console.log(\u0026#39;clean up something\u0026#39;); 6}); 7 8// disposable 集合：方便成批管理 9const bag = new DisposableSet(); 10bag.add(d1); 11bag.add(new DisposableDelegate(() =\u0026gt; console.log(\u0026#39;another cleanup\u0026#39;))); 12 13// 在合适的时机统一释放 14bag.dispose(); 看起来非常简单，但它的价值在于——给“资源释放”这件事一个统一的抽象，\n在大型框架（比如 Theia）里，很多服务/组件都会实现 IDisposable，方便在应用关闭或容器销毁时统一清理。\n把 disposable 和 Widget 生命周期结合起来 以 Widget 为例，一个常见套路是：\n在 onAfterAttach 里订阅事件、signal、定时器等； 在 onBeforeDetach 或 Widget 自身的 dispose() 里用 DisposableSet 把这些资源一次性释放。 一个简单的示例：\n1import { Widget } from \u0026#39;@lumino/widgets\u0026#39;; 2import { DisposableSet, DisposableDelegate } from \u0026#39;@lumino/disposable\u0026#39;; 3import { ISignal, Signal } from \u0026#39;@lumino/signaling\u0026#39;; 4 5class Model { 6 private _changed = new Signal\u0026lt;Model, void\u0026gt;(this); 7 8 get changed(): ISignal\u0026lt;Model, void\u0026gt; { 9 return this._changed; 10 } 11 12 trigger() { 13 this._changed.emit(void 0); 14 } 15} 16 17class MyWidget extends Widget { 18 private _model = new Model(); 19 private _toDispose = new DisposableSet(); 20 21 constructor() { 22 super(); 23 this.addClass(\u0026#39;my-DisposableDemo\u0026#39;); 24 } 25 26 protected onAfterAttach(msg: any): void { 27 // 1. 订阅 model 的 signal 28 this._model.changed.connect(this.onModelChanged, this); 29 this._toDispose.add( 30 new DisposableDelegate(() =\u0026gt; { 31 this._model.changed.disconnect(this.onModelChanged, this); 32 }), 33 ); 34 35 // 2. 绑定 DOM 事件 36 const handler = () =\u0026gt; this._model.trigger(); 37 this.node.addEventListener(\u0026#39;click\u0026#39;, handler); 38 this._toDispose.add( 39 new DisposableDelegate(() =\u0026gt; { 40 this.node.removeEventListener(\u0026#39;click\u0026#39;, handler); 41 }), 42 ); 43 } 44 45 protected onBeforeDetach(msg: any): void { 46 // 3. 在离开 DOM 前统一清理 47 this._toDispose.dispose(); 48 } 49 50 private onModelChanged(sender: Model): void { 51 console.log(\u0026#39;model changed\u0026#39;); 52 } 53} 这段代码表达的意思很简单：\n只要 Widget 不再挂在页面上，它附带的各种监听/订阅都应该跟着寿终正寝，而不是在后台默默泄露。\n在 Theia 里也有类似的模式，只不过很多时候是通过依赖注入 + DisposableCollection（和 Lumino 很像）来管理。\n常见组件的生命周期：从 Application 到 Widget 顺着 disposable 的话题，把几种常见层级的生命周期按“自上而下”捋一下（简化版，只讲和清理相关的点）：\n1. Application 层 创建阶段： new Application / FrontendApplication； 构造 CommandRegistry、Shell、菜单系统等； 注册各种服务、贡献点（在 Theia 里是 Contribution）。 运行阶段： 通过命令、菜单、布局等创建/销毁一批批 Widget / 视图。 销毁阶段： 应用关闭时，调用 Application 的 dispose()，它再递归调用 shell / 服务等的 dispose()。 这里 @lumino/disposable 的作用是给“服务”和“子系统”一个统一的离场接口，便于 Application 在 shutdown 时不遗漏。\n2. Shell / 布局层 以包含 DockPanel 的 Shell 为例：\n创建/attach：DockPanel 被挂到 DOM 上，子 Widget 依次收到 onAfterAttach。 布局变化：拆分/合并/关闭标签，部分 Widget 被从 DockPanel 中移除，触发 onBeforeDetach。 彻底销毁：Shell 自身被 dispose()，通常会把内部所有 Widget dispose() 一遍。 在这个层级上，比较重要的是：DockPanel 自己也实现了 dispose()，会清理内部的布局状态和监听，\n不然长时间折腾布局可能会造成内存堆积。\n3. 单个 Widget 层 对于一个普通 Widget，生命周期大概是这样的：\n构造函数：初始化状态，但不要操作 DOM（因为还没 attach）。 onAfterAttach： 可以安全地访问 this.node 所在的 DOM 环境； 适合绑定事件、启动定时器、订阅模型 signal。 onUpdateRequest / onResize： 响应外界的更新/布局变化； 通常通过 this.update() 触发。 onBeforeDetach： 从 DOM 中卸载前最后的机会； 适合解除事件监听、取消定时任务、断开 signal 订阅（通常配合 DisposableSet）。 dispose()： Widget 生命周期的最终终点； 会确保不再接受消息循环，内部资源应在这里全部释放。 在 Theia 的 ReactWidget 等封装里，这套生命周期会再被转译成更贴近 React 的钩子，但底层还是 Lumino 的消息/生命周期模型在运转。\n在 Theia/Lumino 里看“生命周期 + 资源释放”的几个观察点 实际翻代码或写扩展时，我自己会刻意留意这些地方：\n有没有实现/继承某个 IDisposable / DisposableCollection： 有的话，基本可以推断这个对象在某处会被集中 dispose()； 自己往里面加资源（比如 toDispose.push(...)）就比较安全。 Widget 是否在 onBeforeDetach 或 dispose() 里对事件/信号做了对称的清理： 如果只在 onAfterAttach 里 addEventListener 或 connect，没有拆，就要小心可能的泄露。 服务/单例对象里有没有长生命周期的订阅： 比如 singleton service 订阅了很多 view/model 的事件，却从不释放，这种在 IDE 跑久了很容易炸内存。 把这些模式装进脑子之后，再看 Theia / Lumino 源码里各种“清理逻辑”，会觉得亲切很多：\n大多数看起来“啰嗦”的 dispose 代码，其实都是在给长跑型应用买安全感。\n小结：disposable 是“看不见，但处处在”的一层保障 总结一下这一篇想说的：\n@lumino/disposable 本身非常小，但给“资源释放”提供了一个统一接口和组合工具； 把它和 Widget / Shell / Application 等不同层级的生命周期结合起来，可以形成一套相对清晰的“谁负责善后”的约定； 在像 Theia 这种长时间运行的 IDE 场景里，这种模式对避免内存泄露、事件乱飞有很现实的意义。 写这一篇更像是给自己加一个过滤器：\n以后看到 dispose()、Disposable*、onBeforeDetach 这些字样时，脑子里会自动敲个钟——这里是在讲“善后”，值得多看两眼。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/lumino%E7%9A%84disposable%E4%B8%8E%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","section":"docs","title":"Lumino 的 disposable 与组件生命周期：东西造出来，总要有人负责善后"},{"body":" 这篇补上几块“看文档时很容易跳过，但在复杂项目里很有用”的特性：\n命名绑定（whenTargetNamed）、标签绑定（whenTargetTagged）、多重注入（multiInject）、可选注入（optional）。\n这些东西合在一起，基本构成了 Theia 里那种“很多实现挂在同一个接口下”的能力。\n命名绑定：一个接口，多种实现，用名字区分 场景：\n你有一个接口 Formatter，但有多种实现，比如 JsonFormatter / YamlFormatter。\n希望在同一个服务标识下注册多个实现，然后在注入时按名字区分。\n注册阶段 1export const TYPES = { 2 Formatter: Symbol(\u0026#39;Formatter\u0026#39;), 3} as const; 4 5export interface Formatter { 6 format(input: any): string; 7} 8 9@injectable() 10class JsonFormatter implements Formatter { 11 format(input: any) { 12 return JSON.stringify(input, null, 2); 13 } 14} 15 16@injectable() 17class YamlFormatter implements Formatter { 18 format(input: any) { 19 // 伪代码 20 return toYaml(input); 21 } 22} 23 24container.bind\u0026lt;Formatter\u0026gt;(TYPES.Formatter).to(JsonFormatter).whenTargetNamed(\u0026#39;json\u0026#39;); 25container.bind\u0026lt;Formatter\u0026gt;(TYPES.Formatter).to(YamlFormatter).whenTargetNamed(\u0026#39;yaml\u0026#39;); 注入阶段 1@injectable() 2class ReportService { 3 constructor( 4 @inject(TYPES.Formatter) @named(\u0026#39;json\u0026#39;) private readonly jsonFormatter: Formatter, 5 @inject(TYPES.Formatter) @named(\u0026#39;yaml\u0026#39;) private readonly yamlFormatter: Formatter, 6 ) {} 7} 关键点：\nwhenTargetNamed('xxx') 在 binding 端打上“名字标签”； 注入时用 @named('xxx') 精确指定要的是哪一个实现。 在 Theia 里，类似的模式会用在某些“同一接口不同 flavor”的场景，例如不同的 debug adapter、不同的语言后端等。\n标签绑定：用键值对来表达“这个实现的特性” 命名绑定是用“一个 name 字段”区分实现；\n标签绑定则是用“键值对标签”区分，更灵活一些。\n注册阶段 1container 2 .bind\u0026lt;Formatter\u0026gt;(TYPES.Formatter) 3 .to(JsonFormatter) 4 .whenTargetTagged(\u0026#39;type\u0026#39;, \u0026#39;json\u0026#39;); 5 6container 7 .bind\u0026lt;Formatter\u0026gt;(TYPES.Formatter) 8 .to(YamlFormatter) 9 .whenTargetTagged(\u0026#39;type\u0026#39;, \u0026#39;yaml\u0026#39;); 注入阶段 1@injectable() 2class ReportService { 3 constructor( 4 @inject(TYPES.Formatter) @tagged(\u0026#39;type\u0026#39;, \u0026#39;json\u0026#39;) private readonly jsonFormatter: Formatter, 5 @inject(TYPES.Formatter) @tagged(\u0026#39;type\u0026#39;, \u0026#39;yaml\u0026#39;) private readonly yamlFormatter: Formatter, 6 ) {} 7} 标签绑定的好处是：\n可以用多个标签组合表达更丰富的条件，比如 ('language', 'ts') + ('mode', 'strict')。\n多重注入：一次性拿到“这一类所有实现” 在 Theia 里，你会经常看到这种模式：\n一个扩展点有很多实现（多个 Contribution），启动时要把它们统统注入进来，然后遍历调用。\nInversifyJS 用 multiInject 支持这种模式。\n注册阶段：正常多次 bind 即可 1export const TYPES = { 2 Contribution: Symbol(\u0026#39;Contribution\u0026#39;), 3} as const; 4 5@injectable() 6class FooContribution { /* ... */ } 7 8@injectable() 9class BarContribution { /* ... */ } 10 11container.bind(TYPES.Contribution).to(FooContribution); 12container.bind(TYPES.Contribution).to(BarContribution); 注入阶段：用 @multiInject 1import { multiInject } from \u0026#39;inversify\u0026#39;; 2 3@injectable() 4class ContributionManager { 5 constructor( 6 @multiInject(TYPES.Contribution) 7 private readonly contributions: ReadonlyArray\u0026lt;unknown\u0026gt;, // 可以用具体接口 8 ) {} 9 10 initializeAll() { 11 for (const c of this.contributions) { 12 // 调用每个贡献点的方法 13 } 14 } 15} 这和 Theia 里的 FrontendApplicationContribution / CommandContribution 等模式高度吻合：\n容器里可以有很多实现，启动时统一注入成一个数组，按顺序调用。\n可选注入：这个依赖可能没有也没关系 有时候某个依赖不是必须的：\n例如某个功能只有在特定模块存在时才可用，否则就静默禁用。\nInversifyJS 提供 @optional() 装饰器来表达这一点：\n1import { optional } from \u0026#39;inversify\u0026#39;; 2 3@injectable() 4class MaybeUseFeatureX { 5 constructor( 6 @inject(TYPES.FeatureX) @optional() private readonly featureX?: FeatureX, 7 ) {} 8 9 doSomething() { 10 if (this.featureX) { 11 this.featureX.run(); 12 } else { 13 // 安静地退化行为 14 } 15 } 16} 注意：\n如果没有 @optional()，而容器里又没有对应的绑定，container.get() 会直接抛错； 加了 @optional() 之后，如果找不到绑定，对应参数会是 undefined。 在类似插件系统、可选模块的场景里非常有用。\n在 Theia 里的影子 虽然 Theia 自己对 InversifyJS 做了一层封装（各种 Contribution、toService 等），但这些高级绑定特性背后的抽象是一致的：\n命名/标签绑定：多个实现挂在同一接口下，按条件注入某一类； 多重注入：把所有实现一次性注入进来，像处理插件那样遍历调用； 可选注入：某些扩展模块存在则生效，不存在则退化。 如果你在看 Theia 源码时看到一些“按条件挑扩展”的逻辑，可以试着往 InversifyJS 这几个概念上去对照，大概率能找到一一对应的影子。\n对我来说，这些“高级绑定”更像是让 IoC 容器从“简单服务注册表”升级成“插件分发中心”的一组能力——\n一旦掌握了它们，就能在自己的工程里更自然地建出类似 Theia 那样的扩展点机制。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/inversifyjs/inversifyjs_%E9%AB%98%E7%BA%A7%E7%BB%91%E5%AE%9A_%E5%91%BD%E5%90%8D%E7%BB%91%E5%AE%9A_%E6%A0%87%E7%AD%BE%E7%BB%91%E5%AE%9A_%E5%A4%9A%E9%87%8D%E6%B3%A8%E5%85%A5_%E5%8F%AF%E9%80%89%E6%B3%A8%E5%85%A5/","section":"docs","title":"InversifyJS：高级绑定（命名绑定、标签绑定、多重注入、可选注入）"},{"body":" 前面几篇更多在讲架构和机制，这篇换个角度，把问题缩成一句话：\nLumino 这种“Widget + virtualdom + 布局系统”的组合，在性能上大概处于什么水平，它的瓶颈在哪儿，以及和 React 相比，我们在优化时应该注意什么。\n先说定位：Lumino 关心的“性能问题”跟普通业务前端不太一样 先别急着把 Lumino 和“做后台管理界面”的 React App 放一起比。\nLumino 设计时主要盯的是这几类压力场景：\nIDE / 开发工具：长时间运行、窗口/面板频繁打开关闭、拖拽分屏、Tab 切换。 数据工具（如 JupyterLab）：同时存在大量 Widget（输出面板、Notebook 单元格、数据表格等），需要在有限屏幕下做虚拟化和布局计算。 所以它更在意：\n布局计算和重绘频率：频繁拖拽、分屏、缩放时，不能把浏览器卡死。 大量 Widget 并存时的管理成本：每个 Widget 都有生命周期和消息循环，调度如果粗糙很容易爆栈/卡顿。 长时间运行时的内存稳定性：不希望 IDE 打开一天之后越来越卡。 而 React 更常被用在：\n复杂但以“表单 + 列表 + 图表”为主的业务 UI； 更强调「声明式 + 可组合」的开发体验，性能问题多集中在 diff 频率、组件粒度、状态切片等方面。 这两个世界有重叠，但焦点不完全一样。\nLumino 层面的性能基石：三块砖 粗略看，Lumino 在性能上主要依赖三块基石：\n轻量的 virtualdom\n不搞复杂的 hook/state 体系，就是一个“描述虚拟树 + 打补丁”的库； 这使得它在内部组件（菜单、命令面板等）的 DOM 更新上成本比较可控。 消息驱动的 Widget 生命周期（messaging）\n用 MessageLoop 把 onUpdateRequest / onResize 这些钩子调度起来，避免直接递归和多余调用； 可以在必要时把多个更新合并到一轮消息循环中。 布局组件的增量更新\nDockPanel / SplitPanel / TabBar 等布局变化时，只动受影响的子树； 内置一些合理的限制（比如拖拽区域的命中计算、布局树的结构）来避免退化成“全局重排”。 这些东西加在一起，可以撑起 JupyterLab / Theia 这种规模的应用在普通开发机上长期运行。\n和 React 的几个典型对比点 1. 更新触发的心智模型 React：\nsetState / hook 改变状态 → 触发一次“从根/某个子树开始的重新渲染” → React 内部做 diff + commit； 强调“你只描述最终状态，我来算中间过程”。 Lumino：\n大部分时候是“你显式调用 widget.update()”，然后在 onUpdateRequest 里决定怎么渲染（用 virtualdom 或直接 DOM）； 更强调“由你来控制何时重绘，我帮你调度生命周期”和“给你一个 VDOM 工具加速 patch”。 结果是：\nReact 更适合大面积声明式 UI，性能优化偏向“减小渲染树 / 拆状态 / memo”。 Lumino 更适合精细控制少量但复杂的 Widget，性能优化偏向“控制 update 频率 / 减少不必要的消息派发 / 控制布局复杂度”。 2. diff 粒度与重绘策略 React：\n通常从某个组件子树根开始 diff； 有 React.memo、shouldComponentUpdate、hook 依赖数组等机制帮你减少不必要的 diff。 Lumino virtualdom：\n你自己决定在 _render() 里构造多大的一棵 VNode 树，然后交给 VirtualDOM.render； 没有组件级别的“自动跳过”，需要你从 Widget 设计上就把“更新频繁的小块”和“很少变的大块”拆开。 这意味着：\n在 Lumino 里，不要让一个 Widget 的 _render() 管太多内容，否则每次 update() 都会 diff 一大块； 对比 React 的“拆组件”，这里更像是“拆 Widget 或拆局部视图”。 3. 布局和重排成本 React 本身不负责布局，只是更新 DOM，布局/reflow 由 CSS 决定； Lumino 的 DockPanel / SplitPanel 自己参与了布局决策（位置、尺寸计算）， 优点：IDE 类需求实现起来更可控； 风险：布局树如果太复杂、嵌套太深，频繁拖拽/resize 时的计算成本会抬高。 这里更接近“游戏 UI / 自己写布局引擎”的思路，而不是纯 CSS 布局。\n在复杂 IDE 场景里，这反而是优势：可以精确控制哪些区域需要重算，哪些可以保持不动。\n在 Lumino 里常见的几个性能坑 \u0026amp; 优化思路 结合前面讲过的模块，我自己会注意这些点：\n1. 不要滥用 update()，尤其是“级联 update” 典型坑：\nA Widget 的 onUpdateRequest 里调用 B 的 update()，B 的 onUpdateRequest 又调用 C 的 update()…… 如果缺乏节制，很容易在一次状态变化里触发多层 Widget 的级联重绘。 优化思路：\n做好“状态层”和“视图层”的拆分，用 signaling 把模型变化广播出去，让每个 Widget 自己决定何时 update()； 能批量更新的地方，尽量合并到一次 update() 调用里，而不是在一个事件回调里多次触发。 2. 大量 Widget 并存时，注意生命周期清理 长时间运行的 IDE 容易出现的不是“单次卡顿”，而是：\n某些 Widget 虽然从布局里移除了，但没有被 dispose()； 或者 onBeforeDetach 里没有清掉事件监听 / signal 订阅； 导致消息循环还在偷偷调度它们，内存占用和 CPU 占用慢慢累积。 这里和 React 很像：\nReact 要在 useEffect 里写好 cleanup，Lumino 要在 onBeforeDetach / dispose() 里配合 disposable 把尾巴收干净。\n3. 布局树的复杂度控制 在 DockPanel 里，如果你疯狂拆分区域、嵌套 Panel，理论上布局计算会变重。\n常见的工程级策略：\n设计时限制最大分屏层级（比如不要嵌套太多层 split）； 对某些“辅助视图”采用 overlay/抽屉之类的轻量展示方式，而不是都塞进 DockPanel 树里； 对布局做序列化/还原时，也可以顺便做一些“瘦身”（比如合并已经空掉的区域）。 React 这边类似的问题是“大而全的组件树 + 过多 context/hook”，\n但解决手段不同：React 偏向拆组件和状态切片，Lumino 偏向合理剪裁布局树和 Widget 粒度。\n当你在 Theia 上做二次开发时，可以关注的性能点 站在 Theia 使用者的角度，很多底层优化已经由 Lumino 负责了，我们更需要关注的是：\n自己的扩展/视图里：\n避免在高频事件（如 mousemove、scroll）里频繁 update()； 用合理的 debouce/throttle 包一下，或者只在状态真正变化时更新； 注意 dispose() / onBeforeDetach 把事件监听和 signal 断干净。 和 React 结合时：\nReact 组件本身继续遵守常规优化套路（比如 memo、避免在 render 里创建新函数等）； 注意 React 的更新不要频繁触发 Lumino 布局/尺寸变更，必要时可以把某些区域固定尺寸，减少 reflow。 总体感觉是：\nLumino 提供的是一套偏“工程型工具”的基础设施，默认性能足够支撑 IDE 等重度场景；\n真正更容易踩坑的地方，往往是在我们的扩展/业务视图里对 update/布局/资源释放的粗心使用。\n小结：别指望它像 React 一样“自动聪明”，但它给了你足够的控制力 最后收个口：\n和 React 相比，Lumino 在“性能自动优化”的花活上要朴素很多——没有 hook 依赖分析、没有调度优先级、没有 concurrent 模式。 但它给了你另一种东西：对生命周期和布局非常直接的控制权，再配上一套轻量 virtualdom 和消息循环，让你能在 IDE 这类复杂场景里按需、精确地优化。 从我的学习体验来说，\n把 Lumino 当成“低层基础设施 + 需要你自己有性能意识的工具箱”，再用 React/Vue 承载那些更偏业务的视图，是一个相对舒服的分工方式。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/lumino%E7%9A%84%E6%80%A7%E8%83%BD%E4%B8%8E%E4%BC%98%E5%8C%96_%E4%B8%8Ereact%E7%9A%84%E5%AF%B9%E6%AF%94%E6%80%9D%E8%80%83/","section":"docs","title":"Lumino 的性能与优化：与 React 的对比思考"},{"body":" 这一篇专门补上 InversifyJS 里一个非常贴近 Theia 架构的概念：ContainerModule。\n如果说 Container 是装配厂，那 ContainerModule 基本就是 Theia 里各种 *-frontend-module / *-backend-module 的直接原型。\n为什么需要 ContainerModule？单文件 bind() 太乱了 理论上你可以在一个地方把所有绑定都写完：\n1const container = new Container(); 2 3container.bind(FileService).to(FileServiceImpl).inSingletonScope(); 4container.bind(WorkspaceService).to(WorkspaceServiceImpl).inSingletonScope(); 5container.bind(CommandRegistry).to(CommandRegistryImpl).inSingletonScope(); 6// .... 但在一个像 Theia 这样的大项目里，这种写法很快会变成“巨大无比的 bind 清单”：\n不同功能（文件系统 / 工作区 / 编辑器 / 终端 / 插件系统）混在一起； 想裁剪某个功能（比如去掉 Terminal）很难； 扩展/子项目想“加一坨自己的绑定”也不方便。 ContainerModule 的目的，就是把这堆 bind() 拆成按功能分组的模块，然后在启动时按需 load()。\nContainerModule：把一组绑定封成一个模块 最小示例：\n1import { Container, ContainerModule } from \u0026#39;inversify\u0026#39;; 2 3const myModule = new ContainerModule(bind =\u0026gt; { 4 bind(ServiceA).to(ServiceAImpl).inSingletonScope(); 5 bind(ServiceB).to(ServiceBImpl); 6}); 7 8const container = new Container(); 9container.load(myModule); 这里发生的事情很简单：\nnew ContainerModule(bind =\u0026gt; { ... })：把一组 bind() 演变成一个“可加载模块”； container.load(myModule)：执行模块里的 bind() 函数，把对应绑定注册到容器中。 和你在 Theia 里看到的 frontendApplicationModule / filesystemFrontendModule 的角色是一样的，只不过 Theia 在自家代码里又包了一层。\nAsyncContainerModule：支持异步初始化的模块 Inversify 还提供了 AsyncContainerModule，适合需要异步初始化绑定的场景，比如：\n在绑定前要先读取配置/远程数据。\n1import { Container, AsyncContainerModule } from \u0026#39;inversify\u0026#39;; 2 3const asyncModule = new AsyncContainerModule(async bind =\u0026gt; { 4 const config = await fetchConfig(); 5 bind(Config).toConstantValue(config); 6}); 7 8const container = new Container(); 9 10await container.loadAsync(asyncModule); Theia 里多数模块还是用同步模块（因为绑定逻辑本身是同步的），\n但在你自己做某些云配置/远程能力时，AsyncContainerModule 会很有用。\n对标 Theia：*-frontend-module / *-backend-module 本质上就是 ContainerModule 回忆一下我们从 index.js 里看到的代码：\n1const { frontendApplicationModule } = 2 require(\u0026#39;@theia/core/lib/browser/frontend-application-module\u0026#39;); 3container.load(frontendApplicationModule); 4 5await load(container, import(\u0026#39;@theia/editor/lib/browser/editor-frontend-module\u0026#39;)); 6await load(container, import(\u0026#39;@theia/filesystem/lib/browser/filesystem-frontend-module\u0026#39;)); 7// ... 如果深入这些模块的源码（以 TypeScript 版为例），你会发现它们通常长这样（伪代码）：\n1import { ContainerModule } from \u0026#39;inversify\u0026#39;; 2 3export const filesystemFrontendModule = new ContainerModule(bind =\u0026gt; { 4 bind(FileService).to(FileServiceImpl).inSingletonScope(); 5 bind(FileDialogService).to(FileDialogServiceImpl).inSingletonScope(); 6 // ... 其它与文件系统相关的绑定 7}); 也就是说：\n每个 Theia 模块 = 一个 ContainerModule + 一组针对某个子领域的绑定； container.load(filesystemFrontendModule) 就是执行那组绑定，把“文件系统相关服务”挂到容器上。 这就解释了为什么 Theia 可以：\n用“加减模块”来定制发行版（比如只保留文件浏览/编辑，不要 Git/终端等）； 让第三方扩展以“模块”的形式往容器里加绑定，而不用改核心代码。 模块之间的依赖关系：松耦合的“功能拼图” 多个 ContainerModule 之间并不是完全独立的，比如：\neditor-frontend-module 可能依赖 filesystem-frontend-module 提供的 FileService； workspace-frontend-module 可能依赖 FileService 和 PreferencesService 等。 但这种依赖并不是硬编码的，而是通过“服务标识符 + DI”来解耦：\nfilesystem-frontend-module：bind(FileService).to(FileServiceImpl)； editor-frontend-module：在某个 Editor 相关类上 @inject(FileService)； 容器在加载完所有相关模块后，自然就能解析出依赖关系。 你可以把它理解为一个“功能拼图”：\n每块拼图（模块）声明“我提供哪些服务、我需要哪些服务”； DI 容器负责把整幅拼图拼起来，具体加载哪些拼图，由启动脚本/配置决定。 在自己项目里怎么设计模块粒度？ 如果你以后在自己的项目里用 InversifyJS，可以借鉴 Theia 的模块划分方式：\n按业务子域划分模块，比如：userModule / projectModule / billingModule； 每个模块内部绑定与该子域相关的服务、视图、贡献点； 在不同“发行版”或“部署形态”下加载不同组合的模块： 1const container = new Container(); 2 3// 所有版本都需要的基础模块 4container.load(coreModule, userModule); 5 6// 企业版多一个 billing 7if (isEnterprise) { 8 container.load(billingModule); 9} 这和 Theia 的做法几乎一模一样，只是领域不同。\n小结：ContainerModule 是把 DI 从“单文件配置”提升到“功能级别模块”的关键 总结一下这一篇的核心点：\nContainer 决定“谁来装配”； ContainerModule 决定“按什么粒度组织这堆绑定”； 在 Theia 里，这种粒度基本就是“前端功能模块 / 后端功能模块”的维度； 启动脚本只需要 load() 一堆模块，就能拼装出一个完整的 IDE。 对我个人来说，搞懂 ContainerModule 之后再看 Theia 的 *-frontend-module / *-backend-module，会有一种“哦，原来就是在写一堆 bind() 的模块化版”的释然感——\n你可以不把它当成什么高深的“框架魔法”，就把它当成 InversifyJS 官方推荐的“按功能拆分 DI 配置”的那层语法糖。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/inversifyjs/inversifyjs_containermodule%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96di_%E5%AF%B9%E6%A0%87theia%E5%89%8D%E5%90%8E%E7%AB%AF%E6%A8%A1%E5%9D%97/","section":"docs","title":"InversifyJS：ContainerModule 与模块化 DI（对标 Theia 前后端模块）"},{"body":" 前面写了很多 Lumino 在 IDE / JupyterLab 里的实际用法，这篇稍微发散一点，\n聊聊如果用 Lumino 去做“视频编辑器”这类重工具型应用，会长成什么样，以及哪些能力是天然对口的。\n为什么一提视频编辑器，就容易想到 Lumino 这种框架？ 先拆一下典型“视频编辑器”的几个 UI 特征（不管是 PR、DaVinci 还是浏览器里的在线剪辑）：\n多区域布局：时间线、媒体资源库、预览窗口、属性面板、效果面板、调色窗口……一大堆 Panel。 强交互拖拽：拖媒体到时间线、拖动片段边界、拖调色曲线、拖调音量关键帧。 大量可配置视图：不同工作区（剪辑、调色、音频）下，面板组合和布局都不一样。 长时间运行 + 复杂状态：项目可能开着一整天不停修改，Undo/Redo 状态很重。 这些需求和 IDE / 数据分析工具的共性是很明显的：\n都是“界面复杂 + 布局多变 + 交互重 + 状态多”的工具型应用。\n而 Lumino 恰好就是为这类场景准备的：\nDockPanel / SplitPanel / TabBar：负责复杂布局和可停靠窗口。 signaling / command / virtualdom：负责状态联动和界面渲染。 dragdrop / keyboard / FocusTracker：负责拖拽、快捷键、焦点管理。 所以从“气质”上，Lumino 和视频编辑器这类产品是很对味的。\n用 Lumino 搭一个视频编辑器大致会怎么分层？ 如果用前面几篇写过的模块来想象，可以粗略划成几层：\n应用壳（Application + Shell）\n提供主菜单（文件/编辑/视图/窗口）、工具栏、全局命令面板。 管理不同的“工作区布局”（剪辑视图、调色视图等）——本质上是 DockPanel 布局的不同预设。 布局层（DockPanel / SplitPanel / TabBar）\n左侧：媒体资源浏览器 / 项目结构。 中间：预览窗口 + 时间线区域（可以再分上下）。 右侧：属性面板 / 效果堆栈 / 调色工具。 面板可以拖来拖去、拆分成多屏、存成自定义布局，这些都可以直接复用 Lumino 的 dock 布局能力。 视图 Widget 层\nMediaLibraryWidget：展示素材缩略图、支持拖拽到时间线。 TimelineWidget：展示多轨道时间线、关键帧、剪辑片段。 PreviewWidget：视频实时预览。 InspectorWidget：展示当前选中片段/效果的属性。 这些 Widget 既可以自己用 Lumino virtualdom 写 UI，也可以内部挂 React/Vue 组件。 状态与命令层（signaling + command）\n项目状态：轨道、片段、效果、关键帧等数据结构。 命令：剪切、复制、粘贴、撤销、重做、插入片段、应用效果…… 不同 Widget 通过 signal 订阅这些模型的变化，同步界面；菜单/快捷键/工具栏按钮通过 command 触发修改。 性能 \u0026amp; 后端处理层\n真正的音视频编解码、渲染、导出通常在 WebAssembly/原生层或后台服务里做； Lumino 更多负责“项目编辑界面”和“动作编排”，而不是在 JS 层做重度解码。 从这个角度看，Lumino 提供的是一套“编辑器 UI 基础设施”，而具体的视频处理内核可以根据项目选择 ffmpeg wasm、本地原生模块、远程服务等。\n一些具体的 UI 例子：Lumino 能帮上哪些忙？ 1. 时间线与多轨布局 时间线本身可以是一个自定义 TimelineWidget，内部负责：\n用 Canvas / SVG / DOM 绘制轨道、片段、波形； 使用 Lumino 的 dragdrop 系统处理拖拽片段、调整长度、移动关键帧； 通过 signaling 把“当前播放头位置”“选中片段”等状态广播给其它 Widget（比如预览和 inspector）。 外层用 DockPanel 把 TimelineWidget 和 PreviewWidget 等组合起来：\n类似 VS Code 的 editor group，只不过这里是“剪辑工作区”。\n2. 可停靠的工具面板 调色、音频、特效、属性这些面板，很像 IDE 里的 Outline / Problems / Debug / Terminal：\n每个都是一个独立 Widget，可以在 DockPanel 里自由停靠。 通过命令/菜单控制它们的显隐（视图菜单里勾选）。 用户可以自己拖动这些面板，形成符合个人习惯的 layout，布局可以用 saveLayout/restoreLayout 存起来。 这部分几乎可以原样照搬 Theia 的做法，只是里面放的不是代码相关视图，而是视频相关工具。\n3. 复杂表格/列表：素材管理、效果列表 素材管理、效果堆栈、关键帧列表等，都有一种“半表格半树”的味道：\n这时可以考虑用 Lumino 的 datagrid / Tree 组件，加上 virtualdom 做定制渲染， 比如：\n左侧媒体库用 Tree 展示项目层级 + 媒体类型。 效果堆栈区用 list + draggable item 来展示当前片段挂了哪些效果。 关键帧列表用 datagrid 的行列模型来支撑复杂交互。 这些东西单独实现一遍成本很高，而 Lumino 已经有一部分现成积木可以用。\n和 React/Vue 生态结合的想象 现实里完全用 Lumino 写一个大视频编辑器，可能会觉得在业务 UI 上“有点原始”；\n更现实一点的路线是：\n用 Lumino 搭“工作台壳子”：布局、命令系统、快捷键、菜单、工具栏、右键菜单，这些都交给 Lumino； 用 React/Vue 写“具体工具面板”：比如调色曲线、参数调节表单、项目设置对话框，内部直接用熟悉的组件库（Ant Design、Element Plus 等）。 桥接方式前面 virtualdom 那篇已经提过：\n用一个 Lumino Widget 包住 React/Vue 入口，在 Widget 的生命周期里挂载/卸载前端框架。\n这样可以同时：\n复用 Lumino 在“多窗口、多布局、多命令”的长板； 也享受 React/Vue 在业务组件生态上的丰富度。 实际上有没有类似方向的项目？ 公开世界里，更多是“重工具 + Web 技术”的趋势，例如：\n基于浏览器的 IDE（Theia、VS Code Web等）； 在线白板、在线设计工具（Figma 等）； 在线音视频编辑器（各大 SaaS 产品）。 它们不一定直接用 Lumino，但解决的问题非常类似：\n在浏览器里构建一个长时间运行、交互重、有复杂布局的“工作台”。\n从个人视角看，Lumino 更像是一个“通用工作台 UI 底座”的候选之一：\n如果你本身就对 Theia 架构熟悉，那么把那一套方法论迁移到“视频编辑器”“数据可视化工作台”“在线 IDE for 某领域”等产品上，理论上是完全可行的。\n小结：把 Lumino 当成“通用工具类应用壳”的一个选项 这一篇更像是“脑洞 + 架构草图笔记”，总结一下核心观点：\n视频编辑器这类工具型应用和 IDE 在 UI 形态上高度相似：多 Panel、可停靠布局、重度拖拽、复杂状态。 Lumino 在布局、命令、事件、Widget 模型上的设计，天然适合做“工作台壳子”； 真正的音视频处理、业务逻辑可以交给专门的内核（WASM/原生/服务端）和 React/Vue 等业务 UI 框架，Lumino 负责把这一切编排到一个统一的桌面感界面里。 对我个人来说，这也是为什么在看完 Theia + Lumino 源码之后，会下意识把它们当成“以后做各种专业工具型 Web 应用的备选底座”——\n不一定每次都用，但一旦要做的是“工作站”而不是“普通网站”，Lumino 这套东西就值得往脑子里冒一下。**\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/lumino%E5%9C%A8%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%91%E5%99%A8%E7%AD%89%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%83%BD%E6%80%A7%E4%B8%8E%E6%83%B3%E8%B1%A1/","section":"docs","title":"Lumino 在视频编辑器等工具类应用中的可能性与想象"},{"body":" 前面在“类作为标识符”和“作用域”那几篇里已经提到过循环依赖，这篇就专门把这个话题拎出来，\n聊聊 InversifyJS 的懒注入（lazyInject）是怎么运作的、它在哪些情况下能帮你缓解循环依赖，以及在哪些情况下你宁可重构也别硬上。\n先回顾一下：循环依赖在 DI 容器里为什么麻烦？ 最典型的场景：\n1@injectable() 2class A { 3 constructor(public b: B) {} 4} 5 6@injectable() 7class B { 8 constructor(public a: A) {} 9} 如果直接这样绑定：\n1container.bind(A).toSelf().inSingletonScope(); 2container.bind(B).toSelf().inSingletonScope(); 3 4const a = container.get(A); // BOOM 问题在于：\n创建 A 时，需要先创建 B； 创建 B 时，又需要先创建 A； 如果没有特殊处理，就会引发“鸡生蛋 / 蛋生鸡”的循环。 Java 里的 Spring/Guice 也都有类似问题，只是解决策略（代理对象、提前暴露引用等）略有不同。\nInversifyJS 的做法之一，就是提供一个**懒注入（lazy injection）**的机制。\ninversify-inject-decorators 与 lazyInject lazyInject 不在 inversify 主包里，而是在 inversify-inject-decorators 这个独立包中：\n1import \u0026#39;reflect-metadata\u0026#39;; 2import { Container, injectable } from \u0026#39;inversify\u0026#39;; 3import getDecorators from \u0026#39;inversify-inject-decorators\u0026#39;; 4 5const container = new Container(); 6const { lazyInject } = getDecorators(container); getDecorators(container) 会基于当前容器返回一组装饰器，其中最常用的是 lazyInject：\n1@injectable() 2class ServiceA { 3 @lazyInject(ServiceB) public b!: ServiceB; 4} 5 6@injectable() 7class ServiceB { 8 @lazyInject(ServiceA) public a!: ServiceA; 9} 10 11container.bind(ServiceA).toSelf().inSingletonScope(); 12container.bind(ServiceB).toSelf().inSingletonScope(); 13 14const a = container.get(ServiceA); 15console.log(a.b); // 访问时才真正从容器里取 ServiceB 16console.log(a.b.a); // 再次访问时，ServiceB 再去取 ServiceA 核心区别在于：\n普通构造函数注入：在创建对象时就要把所有依赖都准备好； lazyInject：在第一次访问对应属性时，才去容器里拿依赖（“懒加载”）。 这就给打破循环提供了一个切入点：\nA 可以先被创建出来，等真正用到 B 时，再从容器获取 B；反过来亦然。\n示例：用 lazyInject 缓解循环依赖 参考你之前在“类作为 ID”文档里的例子，我们用稍微简化的版本来说明：\n1import \u0026#39;reflect-metadata\u0026#39;; 2import { Container, injectable } from \u0026#39;inversify\u0026#39;; 3import getDecorators from \u0026#39;inversify-inject-decorators\u0026#39;; 4 5const container = new Container(); 6const { lazyInject } = getDecorators(container); 7 8@injectable() 9class Dom { 10 constructor(public domUi: DomUi) {} 11} 12 13@injectable() 14class DomUi { 15 @lazyInject(Dom) public dom!: Dom; 16} 17 18container.bind(Dom).toSelf().inSingletonScope(); 19container.bind(DomUi).toSelf().inSingletonScope(); 20 21const dom = container.get(Dom); 22console.log(dom.domUi.dom === dom); // true 这里的关键是：\nDom 需要 DomUi，通过构造函数注入； DomUi 需要 Dom，但用 @lazyInject(Dom) 延后到属性访问时才取； 容器创建 Dom 的过程： 创建 DomUi 实例（此时 domUi.dom 还没被访问）； 把 DomUi 传给 Dom 构造函数； 返回 Dom； 当你访问 dom.domUi.dom 时，lazyInject 才真正去容器里拿 Dom 实例，并缓存起来。 这相当于在依赖图中“迟了一步”去解析某条边，从而避免了构造时的死循环。\n懒注入不是银弹：它解决的是“访问时机”，不是“设计问题” 虽然 lazyInject 在一些场景下很方便，但有几个需要非常小心的点：\n它隐藏了依赖\n构造函数注入时，类的依赖一目了然； 用 lazyInject 时，依赖藏在类体内部，不看源码很难知道它依赖了谁。 容易被滥用来“修补坏设计”\n真正健康的架构应该尽量避免强互相依赖（尤其是服务层）； 如果发现自己到处用 lazyInject 才能跑起来，很可能说明模块划分出了问题。 IDE/类型推断的体验稍差一些\n属性上加 ! 非空断言，初学者容易被绕晕； 对某些静态分析工具来说也不如构造函数注入清晰。 所以对我来说，lazyInject 更像是一个“在特殊情况下用的应急工具”，而不是日常推荐的注入方式。\n在 Theia 这种架构里，应该怎么看待懒注入？ Theia 自己的源码里，主流还是构造函数注入 + 接口/符号绑定这一路：\n服务/贡献点之间尽量通过抽象接口解耦； 把确实难以打散的“互相关联”对象，设计成由第三方管理的更高层对象（比如 Manager/Coordinator 模式），而不是让两边互相硬依赖。 如果在 Theia 扩展里考虑用 lazyInject，我个人会建议：\n✅ 可以考虑用的场景：\n某两个类之间确实有“互相持有引用”的需求，并且已经尽量收敛在某个子模块内部； 为了避免改动太大，先用 lazyInject 做一个“折中方案”，再择机重构。 ❌ 尽量避免的场景：\n核心服务层之间大量互相 lazyInject； 把 lazyInject 当成解决所有循环依赖的常用手段，而不是先思考模块拆分。 在大型前端/工具型应用里，一个不错的经验是：\n如果你经常需要用懒注入，可能暗示你的依赖图有点“纠缠不清”，值得退后一步重想一下边界。\n小结：把 lazyInject 当成“特例工具”，而不是日常注入方式 这一篇想强调几个简单的点：\n循环依赖在 DI 世界里是常见难题，懒注入提供了一种“通过延后访问时机来打破死循环”的技术手段； inversify-inject-decorators 里的 lazyInject 可以在某些场景（尤其是 UI 组件互相持有）下派上用场； 但从架构角度看，它更像是“修补缝隙的胶水”，而不是应该大量铺开的日常模式。 对我自己来说，掌握 lazyInject 的最大价值在于：\n遇到循环依赖时有一个临时的安全阀可以用，同时也能提醒自己——是不是该停下来审视一下整体依赖图的设计了。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/inversifyjs/inversifyjs_%E6%87%92%E6%B3%A8%E5%85%A5%E4%B8%8E%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96_lazyinject%E7%9A%84%E5%88%A9%E4%B8%8E%E5%BC%8A/","section":"docs","title":"InversifyJS：懒注入与循环依赖（lazyInject 的利与弊）"},{"body":" 前面几篇都在聊“看得见”的东西（Widget、布局、命令、virtualdom 等），\n这篇换个口味，把那些在源码里经常蹦出来、但平时不太会单独提的模块凑一块儿：@lumino/algorithm、@lumino/collections、@lumino/properties、@lumino/polling ……\n顺便和大家更熟悉的 Lodash 做个对比：它们分别在解决什么类型的问题，什么时候用谁更合适。\n先定个调：这是“框架内部基建”，不是“业务工具库” Lodash 更像是：\n给业务代码用的通用数据处理工具箱：map / filter / cloneDeep / debounce / throttle / groupBy 等等； 强调对各种 JS 内建类型（Array、Object、Function）的补强，兼容历史浏览器。 而 Lumino 这一堆模块，更像是：\n给 Lumino 自己和 IDE 级应用用的“内部基建”：数据结构、算法、属性系统、轮询等； API 设计更偏 TypeScript + 框架场景，几乎不考虑早期浏览器兼容性。 简单一句话：\nLodash 是“通用瑞士军刀”；这些 Lumino 模块是“为这套框架量身定制的扳手和螺丝刀”。\n@lumino/algorithm：一小撮“拿来就用”的算法积木 里面的东西大多是一些针对 Iterable/Array 的小算法，比如：\n搜索：find, lowerBound, upperBound 排序：topologicSort 等 集合操作：iter 系列辅助函数 使用风格有点像“更 TypeScript 友好的小算法集合”，常见场景：\n在 Lumino 内部，需要对一组命令、Widget、菜单项等做有序插入、二分搜索； 对树/图做一些简单排序/遍历（比如拓扑排序）。 对比 Lodash：\nLodash 的 sortBy, find, uniqBy 更偏向“业务数据处理”； @lumino/algorithm 更偏“框架内部用的小一撮专用算法”，数量少但目标明确。 如果你是在写业务逻辑，大部分时候继续用 Lodash / 原生 Array 方法就够；\n只有在跟 Lumino 内部数据结构打交道时，才有机会顺手蹭 @lumino/algorithm 的现成实现。\n@lumino/collections：为框架准备的容器，而不是通用 Map/Set 替代品 这个包里常见的是一些更高阶的数据结构，比如：\n有序映射、队列之类的容器； 针对框架内部常见场景（比如事件队列、消息队列）做了一些优化/封装。 和 Lodash 的差异在于：\nLodash 主要操作的是已有的 Array/Object； @lumino/collections 更在意“在框架内部长期存在的结构”——比如消息队列、观察者列表，这些东西在 IDE 里会长时间活着。 对我们写扩展/业务代码的人来说，用到它的机会不一定很多，但在读 Lumino/Theia 源码时一旦看到这些类型，就知道：\n这是一个“框架级容器”，生命周期和作用域往往比较大； 性能/复杂度的考量可能比一般业务数组要敏感些。 @lumino/properties：给对象挂“扩展属性”的正规方式 @lumino/properties 解决的痛点是：\n当你想给一个对象额外挂点状态，又不想真的往这个对象上加字段时，该怎么办？\n典型用法（示意）：\n1import { AttachedProperty } from \u0026#39;@lumino/properties\u0026#39;; 2 3class MyWidget { /* ... */ } 4 5// 为 MyWidget 定义一个“附加属性” 6const someFlag = new AttachedProperty\u0026lt;MyWidget, boolean\u0026gt;({ 7 name: \u0026#39;someFlag\u0026#39;, 8 create: () =\u0026gt; false, // 默认值 9}); 10 11const w = new MyWidget(); 12 13// 读取 / 设置就像访问属性一样 14console.log(someFlag.get(w)); // false 15someFlag.set(w, true); 底层可以类比成一个“带元数据的 WeakMap”：\n不会污染原对象的字段，又能给任意对象挂上一些扩展状态——在框架里尤其适合做：\n插件/扩展为核心对象挂额外标记； 在不破坏封装的前提下，给一些内部对象加“侧写信息”。 对比 Lodash：\nLodash 通常直接在对象上加字段，或者用 WeakMap 自己管理映射； @lumino/properties 提供的是一个更体系化、可组合、带默认值的“扩展属性”机制。 如果你是在 Lumino 的语境里写扩展，这个模式会比“到处塞私有字段”更干净；\n换成纯业务代码场景，继续用 Lodash/WeakMap 也完全没问题。\n@lumino/polling：比 setInterval 高一档的轮询封装 在 IDE / 工具类应用里，“定期刷新点东西”是很常见的需求，比如：\n定时刷新某个视图的数据； 对某项异步任务的状态做轮询。 裸写 setInterval 容易踩到的问题包括：\n错误处理杂乱； 在页面隐藏/应用未激活时白白浪费资源； 和 Widget/Application 生命周期脱节，容易忘记清理。 @lumino/polling 试图给这件事一个更框架化的解决方案，比如：\n支持退避策略（失败时拉长间隔）； 支持基于可见性/活跃状态暂停； 有比较统一的取消/错误处理入口。 对比 Lodash：\nLodash 提供的是 debounce / throttle 这类节流/防抖工具； @lumino/polling 管的是“有生命周期、有状态的轮询任务”，层级不太一样。 在 Theia/Lumino 里，如果你要写一个“长期存在的后台轮询”，用 @lumino/polling 会更贴近框架的风格；\n如果只是简单防抖按钮点击/搜索输入，继续用 Lodash 的 debounce/throttle 就好。\n这些模块在整个 Lumino / Theia 里的角色 从整体架构视角看，这些“工具 \u0026amp; 基础设施模块”主要起到几个作用：\n让框架内部代码更可读/可维护：\n有了 algorithm / collections，很多地方不用重复造小轮子； properties 让扩展属性的模式统一； polling 让轮询逻辑长得比较像样。 给长生命周期应用提供更稳的基石：\nIDE 这种东西不开浏览器调试工具，开一天两天照样得扛住； 这些基础设施都是为了在这种“长跑”场景下少踩坑服务的。 从“和 Lodash 的关系”来看，可以简单这么想：\nLodash：偏“横向通用”的数据/函数工具库，哪里都能用； Lumino 这些基础设施模块：偏“纵向专用”的框架内部基石，和 Widget / Application / 命令系统这些垂直集成得很紧。 小结：什么时候该想起它们，而不是顺手就 Lodash 一把梭？ 对我个人来说，大概有这么几个“脑中提示”：\n当我在读 Lumino / Theia 源码，看到这几个包名时： 会提醒自己“这块是框架内部基建”，值得多看两眼模式而不只是把实现当黑盒。 当我在做 Theia/Lumino 扩展，需要： 给现有对象挂扩展属性 → 想起 @lumino/properties； 写长期存在的轮询逻辑 → 想起 @lumino/polling； 依赖框架已有的数据结构/算法 → 看看 algorithm / collections 里有没有现成的。 而在纯业务逻辑里： 处理数组/对象/字符串 → 还是优先用 Lodash 或原生 API，更符合团队经验和生态习惯。 这一篇就当是给这些“在代码里经常路过却不太会专门聊”的模块做个小索引：\n以后再碰到它们时，能立刻知道：这是 Lumino 在打地基，而不是在和 Lodash 抢活。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/lumino/lumino%E7%9A%84%E5%B7%A5%E5%85%B7%E4%B8%8E%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%A8%A1%E5%9D%97_%E4%B8%8Elodash%E7%9A%84%E5%AF%B9%E6%AF%94%E6%9D%82%E8%B0%88/","section":"docs","title":"Lumino 的工具与基础设施模块：与 Lodash 的对比杂谈"},{"body":" 安装yarn 下载 nodejs 通过 npm 安装 1npm install -g yarn 查看版本 1yarn --version 设置淘宝源 1yarn config set registry https://registry.npm.taobao.org 2yarn config set sass_binary_site https://npm.taobao.org/mirrors/node-sass # node-sass 二进制包镜像 3yarn config set electron_mirror https://npm.taobao.org/mirrors/electron/ # electron 二进制包镜像 4yarn config set ELECTRON_MIRROR https://cdn.npm.taobao.org/dist/electron/ # electron 二进制包镜像 5yarn config set puppeteer_download_host https://npm.taobao.org/mirrors # puppeteer 二进制包镜像 6yarn config set chromedriver_cdnurl https://npm.taobao.org/mirrors/chromedriver # chromedriver 二进制包镜像 7yarn config set operadriver_cdnurl https://npm.taobao.org/mirrors/operadriver # operadriver 二进制包镜像 8yarn config set phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs # phantomjs 二进制包镜像 9yarn config set selenium_cdnurl https://npm.taobao.org/mirrors/selenium # selenium 二进制包镜像 10yarn config set node_inspector_cdnurl https://npm.taobao.org/mirrors/node-inspector # node-inspector 二进制包镜像 yarn 与 npm 命令对比 npm yarn 注释 npm init yarn init 初始化项目 npm install yarn 安装全部依赖 npm install react --save yarn add react 安装某个依赖，保存到 dependencies npm uninstall react --save yarn remove react 移除某个依赖 npm install react --save-dev yarn add react --dev 安装某依赖,保存到 devDependencies npm update [package] --save yarn upgrade [package] 更新生产环境某个依赖包 npm install axios --global yarn global add axios 全局安装某个依赖 npm install --save axios vue-axios yarn add axios vue-axios 同时下载多个依赖包 npm install [package]@[version] yarn add [package]@[version] 安装指定版本的包 npm rebuild yarn install --force 重新下载所有包 npm --save 和 npm --save-dev 区别 npm5版本之前，必须要加上--save，才会将包记录到package.json npm5版本之后开始，--save是默认值了，可以省略不写\n--save 简写 -S 会被记录到dependencies【生产环境】\nnpm 等同 yarn npm i jquery // npm i jquery --save = yarn add jquery npm i jquery -S = yarn add jquery -S // yarn 只有简写 --save-dev 简写 -D 会被记录到devDependencies【开发环境】\nnpm 等同 yarn npm i webpack -D // npm i webpack --save-dev = yarn add webpack -D // yarn 只有简写 dependencies:项目依赖，项目实际运行需要的依赖，上线还是需要的，如（vue，jquery） devDependencies:开发依赖，只在开发时需要的依赖，实际上线不需要的，如（webpack） yarn对比npm的优点 离线模式 yarn会有一个缓存目录，会缓存以前安装过的软件包，再次安装时就不必从网络下载了，大大加速安装速度。\n依赖关系确定性 在每一台机器上针对同一个工程安装依赖时，生成的依赖关系顺序和版本是一致的。\n网络性能优化 下载软件时会优化请求顺序，避免请求瀑布发生。\n网络回弹 yarn在某个安装包请求失败时不会导致安装失败，它会自动去尝试重新安装。而npm则会毫不犹豫的失败，导致得再来一次，耗费时间。\n多注册来源 所有的依赖包，不管他被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是 npm 要么是 bower, 防止出现混乱不一致。\n扁平模式 对于多个包依赖同一个子包的情况，yarn会尽量提取为同一个包，防止出现多处副本，浪费空间。比如1.2中，yarn会为babel-generator和babel-helper-define-map 创建同一个lodash子依赖，这样就节约一份的空间。\n","link":"https://misakaJimmy.github.io/docs/frontend/tools/yarn/","section":"docs","title":"Yarn"},{"body":" 这一篇聊聊 InversifyJS 在“写测试”这件事上的实际用法：\n怎么建一个测试专用容器、怎么用 rebind 替换实现、以及在像 Theia 这种重度依赖 DI 的项目里，怎样让单元测试/集成测试不那么痛苦。\n两种基本策略：测试容器 vs 重绑定 在测试里使用 InversifyJS，大致有两条路：\n单独创建一个“测试容器”\n自己 new 一个 Container，只注册当前测试需要的那一小撮服务； 适合“轻量级单元测试”，隔离性最好。 基于现有容器，用 rebind 替换部分实现\n例如在 Theia 的前端容器上，把某个服务换成 fake/mock； 适合“集成测试/端到端测试”，保留大部分真实行为，只 stub 掉个别外部依赖。 下面分别展开。\n建一个最小测试容器 单元测试最常见的做法是：\n不要把整套应用（比如完整的 Theia 容器）搬进来，而是只搭一个自己需要的小容器。\n1import \u0026#39;reflect-metadata\u0026#39;; 2import { Container, injectable, inject } from \u0026#39;inversify\u0026#39;; 3 4const TYPES = { 5 Repo: Symbol(\u0026#39;Repo\u0026#39;), 6 Service: Symbol(\u0026#39;Service\u0026#39;), 7} as const; 8 9interface Repo { 10 findById(id: string): Promise\u0026lt;string\u0026gt;; 11} 12 13@injectable() 14class Service { 15 constructor(@inject(TYPES.Repo) private readonly repo: Repo) {} 16 17 async getName(id: string) { 18 const raw = await this.repo.findById(id); 19 return raw.toUpperCase(); 20 } 21} 在测试里，我们不想用真实的 Repo，而是用一个 fake：\n1test(\u0026#39;Service.getName uppercases repo result\u0026#39;, async () =\u0026gt; { 2 const container = new Container(); 3 4 const fakeRepo: Repo = { 5 async findById(id: string) { 6 return \u0026#39;john\u0026#39;; 7 }, 8 }; 9 10 container.bind\u0026lt;Repo\u0026gt;(TYPES.Repo).toConstantValue(fakeRepo); 11 container.bind\u0026lt;Service\u0026gt;(TYPES.Service).to(Service); 12 13 const service = container.get\u0026lt;Service\u0026gt;(TYPES.Service); 14 expect(await service.getName(\u0026#39;1\u0026#39;)).toBe(\u0026#39;JOHN\u0026#39;); 15}); 特点：\n这个测试完全不依赖真实 Repo 的实现； 替换 fake 实现非常直接（toConstantValue 或 toDynamicValue 都可以）； 测试失败时更容易定位问题，因为容器里只有少量绑定。 在纯业务代码里，这是我最推荐的模式：\n每个测试文件按需创建自己的小容器，不要直接端整个应用容器过来。\n在现有容器上用 rebind 替换实现 在像 Theia 这种框架里，有时你确实需要用到完整容器（带布局、命令系统等），此时可以考虑用 rebind：\n1container.rebind\u0026lt;SomeService\u0026gt;(TYPES.SomeService).to(FakeSomeService).inSingletonScope(); 或者替换成常量值：\n1container.rebind\u0026lt;ApiClient\u0026gt;(TYPES.ApiClient).toConstantValue({ 2 async request() { /* fake impl */ }, 3}); 典型流程可以是：\n1let container: Container; 2 3beforeEach(() =\u0026gt; { 4 container = new Container(); 5 // 加载真实模块 6 container.load(coreModule, workspaceModule, ...); 7 8 // 用测试实现替换部分服务 9 container.rebind\u0026lt;FileService\u0026gt;(TYPES.FileService).to(FakeFileService).inSingletonScope(); 10}); 11 12afterEach(() =\u0026gt; { 13 container.unbindAll(); 14}); 适用场景：\n你在测试里需要依赖 Theia 的大部分行为（命令注册、布局、菜单等）； 但又不想触碰某些外部系统（真实文件系统、真实网络请求等）。 针对 Theia 的一些具体建议 如果你将来写 Theia 扩展并想为它写测试，我自己的偏好大概是这样分层：\n纯业务逻辑 / 工具函数 / 小服务\n优先用“最小测试容器”模式； 甚至可以不引入 Inversify，直接 new + 手动注入依赖。 扩展中的 Contribution / Widget / Service 之间的协作\n可以建一个“扩展级容器”：只加载与该扩展相关的模块 + 外部少量依赖； 对不想碰的外部服务，用 rebind 换成 fake。 端到端 / 集成测试（比如通过浏览器自动化驱动 Theia）\n容器更多在应用内侧使用，你只需要预先在某个入口脚本里 rebind 掉一些服务； 或使用专门的测试配置/测试发行版（比如只加载部分模块）。 关键是：\n不要在单元测试里“什么都 rebind 一遍再启动一整套 Theia”，那样调试成本很高。\n一些实用的小技巧 给 fake 实现也加上 @injectable()（如果用 to()）：\n方便在不同测试场景下复用 fake； 也可以在测试容器里用 to(FakeImpl) 而不是 toConstantValue。 用类型别名管理“测试版容器”：\n例如：\n1export type TestContainer = Container; 2 3export function createTestContainer(): TestContainer { 4 const c = new Container(); 5 c.load(coreTestModule, ...); 6 return c; 7} 方便不同测试文件共享一套基础绑定。\n善用 unload / unbindAll 清理容器状态：\n避免“前一个测试改了绑定，后一个测试被污染”的情况。 小结：把容器当成“测试夹具”的一部分 从另一个角度看，InversifyJS 的容器在测试里的角色，其实很像传统测试里的“夹具（fixture）”：\n测试前：搭好一套依赖环境（绑定真实实现或 fake）； 测试中：获取被测对象、执行行为； 测试后：清理/销毁容器，避免状态泄露。 Theia 之类框架把几乎所有服务都挂在容器上，这对测试来说反而是个优势：\n一旦你掌握了“建测试容器 + 局部 rebind”这两招，很多看似复杂的依赖网，其实都能在测试里被驯服。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/inversifyjs/inversifyjs_%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95_%E6%B5%8B%E8%AF%95%E5%AE%B9%E5%99%A8%E4%B8%8Erebind/","section":"docs","title":"InversifyJS：测试中的容器用法（测试容器与 rebind）"},{"body":" 项目链接：github.com/lerna/lerna Lerna 是一个管理工具，用于管理包含多个软件包（package）的 JavaScript 项目。\n关于 将大型代码仓库分割成多个独立版本化的 软件包（package）对于代码共享来说非常有用。但是，如果某些更改 跨越了多个代码仓库的话将变得很 麻烦 并且难以跟踪，并且， 跨越多个代码仓库的测试将迅速变得非常复杂。\n为了解决这些（以及许多其它）问题，某些项目会将 代码仓库分割成多个软件包（package），并将每个软件包存放到独立的代码仓库中。但是，例如 Babel, React, Angular, Ember, Meteor, Jest, 等项目以及许多其他项目则是在 一个代码仓库中包含了多个软件包（package）并进行开发。\nLerna is a tool that optimizes the workflow around managing multi-package repositories with git and npm.\nLerna 还可以减少开发和构建环境中大量包副本的时间和空间需求——这通常是将项目分成许多单独的 NPM 包的缺点。有关详细信息，请参阅 hoist documentation。\nLerna repo 是什么样的？ 它实际上很简单。您的文件结构如下所示：\n1my-lerna-repo/ 2 package.json 3 packages/ 4 package-1/ 5 package.json 6 package-2/ 7 package.json Lerna 能做什么？ Lerna 中的两个主要命令是 lerna bootstrap 和 lerna publish。\nbootstrap 将 repo 中的依赖项链接在一起。 publish 将帮助发布任何更新的包。\nLerna 不能做什么？ Lerna 不是 serverless monorepos 的部署工具。Hoisting 可能与传统的无服务器 monorepo 部署技术不兼容。\n入门 本着用新不用旧的原则，本文像官方文档学习，使用 Lerna 3.0。\n比起npm作者偏爱用yarn，如果不喜欢yarn的可以参考 yarn 与 npm 命令对比\n推荐全局安装 Lerna\n1yarn add -g lerna 接下来，我们将创建一个新的 git 代码仓库：\n1git init lerna-repo \u0026amp;\u0026amp; cd lerna-repo 现在，我们将上述仓库转变为一个 Lerna 仓库：\n1lerna init 这将创建一个lerna.json配置文件和一个packages文件夹，因此您的文件夹现在应如下所示：\n1lerna-repo/ 2 packages/ 3 package.json 4 lerna.json 如何使用Lerna Lerna 允许您使用以下两种模式之一来管理您的项目：Fixed 或 Independent。\nFixed/Locked 模式 (default) Fixed模式 Lerna 项目在单个版本行上运行。版本保存在lerna.json项目根目录下的文件中version。当你运行时lerna publish，如果一个模块自上次发布以来已经更新，它将更新到你发布的新版本。这意味着您只在需要时发布新版本的包。\n注意：如果您的主要版本为零，则所有更新都被认为是破坏性的。因此，lerna publish使用主要版本零运行并选择任何非预发布版本号将导致为所有包发布新版本，即使自上次发布以来并非所有包都已更改。 这是Babel当前使用的模式。如果您想自动将所有包版本绑定在一起，请使用此选项。这种方法的一个问题是，任何包的重大变化都会导致所有包都有一个新的主要版本。\nIndependent 模式 lerna init --independent\n独立模式 Lerna 项目允许维护人员彼此独立地增加包版本。每次发布时，您都会收到有关已更改的每个包的提示，以指定它是补丁、次要、主要还是自定义更改。\n独立模式允许您更具体地更新每个包的版本，并且对一组组件有意义。将此模式与语义释放之类的东西结合起来会减轻痛苦。（atlassian/lerna-semantic-release已经有这方面的工作）。\n将lerna.json中的version设置为independent以运行Independent模式。 基本概念 Lerna在运行命令时遇到错误会记录到一个lerna-debug.log文件（与 npm-debug.log 相同）。\nLerna 还支持scoped packages。\nlerna.json 1{ 2 \u0026#34;version\u0026#34;: \u0026#34;1.1.3\u0026#34;, 3 \u0026#34;npmClient\u0026#34;: \u0026#34;yarn\u0026#34;, 4 \u0026#34;command\u0026#34;: { 5 \u0026#34;publish\u0026#34;: { 6 \u0026#34;ignoreChanges\u0026#34;: [\u0026#34;ignored-file\u0026#34;, \u0026#34;*.md\u0026#34;], 7 \u0026#34;message\u0026#34;: \u0026#34;chore(release): publish\u0026#34;, 8 \u0026#34;registry\u0026#34;: \u0026#34;https://npm.pkg.github.com\u0026#34; 9 }, 10 \u0026#34;bootstrap\u0026#34;: { 11 \u0026#34;ignore\u0026#34;: \u0026#34;component-*\u0026#34;, 12 \u0026#34;npmClientArgs\u0026#34;: [\u0026#34;--no-package-lock\u0026#34;] 13 } 14 }, 15 \u0026#34;packages\u0026#34;: [\u0026#34;packages/*\u0026#34;] 16} version: 存储库的当前版本 npmClient: 用于指定特定客户端以运行命令的选项（也可以在每个命令的基础上指定）。更改为\u0026quot;yarn\u0026quot;使用 yarn 运行所有命令。默认为“npm” command.publish.ignoreChanges: 不包含在lerna changed/publish. 使用它来防止不必要地发布新版本以进行更改，例如修复README.md错字 command.publish.message: 执行版本更新以进行发布时的自定义提交消息。有关更多详细信息，请参阅@lerna/version command.publish.registry: 使用它来设置要发布到的自定义注册表 url 而不是 npmjs.org，如果需要，您必须已经过身份验证 command.bootstrap.ignore: lerna bootstrap 运行命令时不会引导的 glob 数组 command.bootstrap.npmClientArgs: 在 lerna bootstrap 运行时将传递到 npm install 的数据 command.bootstrap.scope: 一个用于 lerna bootstrap 运行时，限制在运行命令时将引导哪些包的一个 glob 数组 packages: 用作包位置的 glob 数组 配置文件lerna.json中的packages字段一个 glob 数组用来匹配拥有package.json的文件夹，这是 lerna 识别\u0026quot;子\u0026quot;包的方式（相对于项目\u0026quot;根\u0026quot;目录 package.json，它旨在管理整个 repo 的开发依赖项和脚本）。\n默认情况下，lerna 将包列表初始化为[\u0026quot;packages/*\u0026quot;]，但您也可以使用其他目录，例如[\u0026quot;modules/*\u0026quot;], 或[\u0026quot;package1\u0026quot;, \u0026quot;package2\u0026quot;]. 定义的 glob 与所在的目录相关，lerna.json通常是存储库根目录。唯一的限制是您不能直接嵌套包位置，但这也是“普通”npm 包共享的限制。\n例如，[\u0026quot;packages/*\u0026quot;, \u0026quot;src/**\u0026quot;]匹配这棵树：\n1packages/ 2├── foo-pkg 3│ └── package.json 4├── bar-pkg 5│ └── package.json 6├── baz-pkg 7│ └── package.json 8└── qux-pkg 9 └── package.json 10src/ 11├── admin 12│ ├── my-app 13│ │ └── package.json 14│ ├── stuff 15│ │ └── package.json 16│ └── things 17│ └── package.json 18├── profile 19│ └── more-things 20│ └── package.json 21├── property 22│ ├── more-stuff 23│ │ └── package.json 24│ └── other-things 25│ └── package.json 26└── upload 27 └── other-stuff 28 └── package.json 在下面定位叶子包packages/*被认为是“最佳实践”，但不是使用 Lerna 的要求。\n废弃字段 有些lerna.json字段不再使用。值得注意的包括：\nlerna: 最初用于表示 Lerna 的当前版本。在 v3 中 过时 并且 删除 常见的devDependencies 大多数devDependencies可以拉到 Lerna repo 的根目录lerna link convert\n上述命令将自动 hoist things 并使用相关 file: 说明符。\nHoisting 有几个好处：\n所有包都使用相同版本的给定依赖项 可以使用Snyk等自动化工具使根目录中的依赖项保持最新 减少依赖安装时间 需要更少的存储空间 请注意，devDependencies提供 npm 脚本使用的“二进制”可执行文件仍然需要直接安装在使用它们的每个包中。\n例如，在这种情况下，为了 lerna run nsp（以及在包的目录中 npm run nsp）正常工作，nsp依赖项是必需的：\n1{ 2 \u0026#34;scripts\u0026#34;: { 3 \u0026#34;nsp\u0026#34;: \u0026#34;nsp\u0026#34; 4 }, 5 \u0026#34;devDependencies\u0026#34;: { 6 \u0026#34;nsp\u0026#34;: \u0026#34;^2.3.3\u0026#34; 7 } 8} Git 托管的依赖项 Lerna 允许将本地依赖包的目标版本编写为带有（例如#committish#v1.0.0或#semver:^1.0.0 ）的git 远程 url ，而不是正常的数字版本范围。当包必须是私有的并且不需要私有 npm 注册表时，这允许通过 git 存储库分发包。\n请注意，lerna 不会将git 历史记录实际拆分为单独的只读存储库。这是用户的责任。\n1// packages/pkg-1/package.json 2{ 3 name: \u0026#34;pkg-1\u0026#34;, 4 version: \u0026#34;1.0.0\u0026#34;, 5 dependencies: { 6 \u0026#34;pkg-2\u0026#34;: \u0026#34;github:example-user/pkg-2#v1.0.0\u0026#34; 7 } 8} 9 10// packages/pkg-2/package.json 11{ 12 name: \u0026#34;pkg-2\u0026#34;, 13 version: \u0026#34;1.0.0\u0026#34; 14} 在上面的例子中，\nlerna bootstrap将正确符号链接pkg-2到pkg-1. lerna publish将在pkg-2更改时更新pkg-1 committish (#v1.0.0) 自述文件徽章 正在使用Lerna？添加一个 README 徽章来展示它：\n1[![lerna](https://img.shields.io/badge/maintained%20with-lerna-cc00ff.svg)](https://lerna.js.org/) ","link":"https://misakaJimmy.github.io/docs/frontend/tools/lerna/","section":"docs","title":"Lerna"},{"body":" 前面几篇都是站在“纯 InversifyJS”的视角看依赖注入，这篇换个角度，\n直接拿 Theia 的 index.js 启动脚本拆解一下，看看 InversifyJS 在真实 Theia 应用里到底干了些什么。\n这个 index.js 在 Theia 里扮演什么角色？ 先整体看一眼，下面是一个直接内嵌在本页的 index.js 预览：\n大致结构可以简化理解成这样：\n1require(\u0026#39;reflect-metadata\u0026#39;); 2const { Container } = require(\u0026#39;@theia/core/shared/inversify\u0026#39;); 3// ... 4module.exports = (async () =\u0026gt; { 5 const container = new Container(); 6 container.load(messagingFrontendModule); 7 // ... 加载大量 *-frontend-module 8 const { FrontendApplication } = require(\u0026#39;@theia/core/lib/browser\u0026#39;); 9 // ... 10 (window[\u0026#39;theia\u0026#39;] = window[\u0026#39;theia\u0026#39;] || {}).container = container; 11 return container.get(FrontendApplication).start(); 12})(); 这其实就是一个前端启动入口：\n创建 InversifyJS Container； 把各个前端模块（xxx-frontend-module）加载进容器； 从容器里拿出 FrontendApplication，然后调用 start()； 顺手把 container 挂到 window.theia.container 上，方便调试或后续使用。 换句话说：Theia 把所有“前端能力”都打包成一堆 InversifyJS 模块，然后通过这个入口组装成一个完整应用。\nContainer：Theia 前端世界的“装配厂” 关键几行代码：\n1const { Container } = require(\u0026#39;@theia/core/shared/inversify\u0026#39;); 2// ... 3const container = new Container(); 这里用的 Container 实际上就是 InversifyJS 提供的 IoC 容器（Theia 自己 re-export 了一份）：\n所有前端服务、视图、贡献点（contribution）都会绑定到这个容器上； 模块加载（container.load(...)）其实就是在给容器“批量注册绑定关系”； 后面 container.get(FrontendApplication) 拿到的就是已经注入好所有依赖的应用对象。 可以把它想象成：Theia 前端的所有“零件”（服务/扩展）都在这里登记，然后通过容器组装成完整 IDE。\ncontainer.load(module)：Theia 模块 = 一堆 InversifyJS 绑定 你会看到大量这样的代码：\n1const { messagingFrontendModule } = require(\u0026#39;@theia/core/lib/browser/messaging/messaging-frontend-module\u0026#39;); 2container.load(messagingFrontendModule); 3 4const { frontendApplicationModule } = require(\u0026#39;@theia/core/lib/browser/frontend-application-module\u0026#39;); 5container.load(frontendApplicationModule); 6 7// 以及一长串 await load(container, import(\u0026#39;...-frontend-module\u0026#39;)); 这些 xxx-frontend-module 本质上就是 InversifyJS 的 ContainerModule：\n每个模块内部大致长这样（伪代码）：\n1export const someFrontendModule = new ContainerModule(bind =\u0026gt; { 2 bind(ServiceA).to(ServiceAImpl).inSingletonScope(); 3 bind(ServiceB).to(ServiceBImpl); 4 // ... 注册一堆服务、贡献点、视图等 5}); container.load(someFrontendModule) 做的事情就是执行这个模块里的 bind(...) 逻辑，把所有服务注册到容器里。\n这就解释了为什么 Theia 可以通过“加/减模块”来裁剪功能：\n想要某个功能 → 把对应的 xxx-frontend-module 加到启动脚本里； 想禁用某个功能 → 不 load 它，或者提供自己的替代模块覆盖绑定。 从 InversifyJS 的角度看，这就是典型的“按模块组织绑定”的高级用法。\npreload：在应用真正启动前做准备工作 中间有一段 preload(container)：\n1async function preload(container) { 2 try { 3 await load(container, import(\u0026#39;@theia/core/lib/browser/preload/preload-module\u0026#39;)); 4 await load(container, import(\u0026#39;@theia/core/lib/browser-only/preload/frontend-only-preload-module\u0026#39;)); 5 await load(container, import(\u0026#39;@theia/api-samples/lib/browser/api-samples-preload-module\u0026#39;)); 6 const { Preloader } = require(\u0026#39;@theia/core/lib/browser/preload/preloader\u0026#39;); 7 const preloader = container.get(Preloader); 8 await preloader.initialize(); 9 } catch (reason) { 10 console.error(\u0026#39;Failed to run preload scripts.\u0026#39;, reason); 11 } 12} 这里又是同一套模式：\n把若干 “preload 模块” 作为 ContainerModule 加载进容器； 从容器里拿到 Preloader 服务； 调用 preloader.initialize() 做一系列“启动前任务”（比如缓存、语言包加载、环境检测等）。 这段代码很好地体现了 “所有能力都通过容器获取，而不是到处 new” 的原则：\nPreloader 自己的依赖也通过 InversifyJS 注入； 启动脚本只负责 orchestrate（编排顺序），而不是关心细节实现。 最后一步：从容器拿出 FrontendApplication 并启动 核心收尾逻辑在这里：\n1const { FrontendApplication } = require(\u0026#39;@theia/core/lib/browser\u0026#39;); 2// ... 3function start() { 4 (window[\u0026#39;theia\u0026#39;] = window[\u0026#39;theia\u0026#39;] || {}).container = container; 5 return container.get(FrontendApplication).start(); 6} 关键点有两个：\nwindow.theia.container = container\n方便在浏览器控制台里调试：你可以 theia.container.get(SomeService) 看看容器里有什么； 也方便某些全局脚本访问容器（虽然从架构洁癖角度看，这算是一种“后门”）。 container.get(FrontendApplication).start()\nFrontendApplication 本身也是一个被注入了大量依赖的类：命令系统、布局系统、菜单、状态存储等等； 调用 start() 时，它会去： 初始化各个贡献点（Command/Keybinding/Menu/Widget 等）； 创建主 Shell； 渲染整个前端应用。 从依赖注入的视角看：\nTheia 的前端应用启动，其实就是“从容器里拿出一个配置好的 FrontendApplication 实例，然后让它跑起来”。\n这份 index.js 给我带来的几个 InversifyJS 认知 结合前面几篇 InversifyJS 笔记，再看这份 index.js，我大概会有这几个“小总结”：\nContainer 是唯一的“真入口”\n所有前端功能、服务、扩展都以模块的形式往容器里注册； 不再到处 new，而是把“创建权”集中到 IoC 容器里。 模块（ContainerModule）是 Theia 的“功能颗粒度单位”\n一个 xxx-frontend-module 代表一块功能（文件系统、终端、Git、插件、AI 功能等）； 启动脚本里 load 哪些模块，就决定了这个 Theia 变体长成什么样。 前端启动脚本只是“编排者”，不是“工厂”\n它只负责：创建容器 → 加载模块 → 做一点 preload → 从容器里拿 FrontendApplication 启动； 至于每个模块内部具体绑定了什么服务、这些服务怎么协作，全都交给 InversifyJS + Theia 自己的扩展框架。 从学习的角度来说，这个 index.js 是一个非常好的“桥”：\n一头连着 InversifyJS 容器和模块系统，一头连着 Theia 的前端应用生命周期，刚好把两边的概念串在了一起。\n理解了它，再去看单个 xxx-frontend-module 里是怎么 bind() 各种服务，会更有方向感。**\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/inversifyjs/inversifyjs%E4%B8%8Etheia_%E4%BB%8Eindex_js%E7%9C%8B%E5%89%8D%E7%AB%AF%E5%90%AF%E5%8A%A8%E4%B8%8E%E6%A8%A1%E5%9D%97%E8%A3%85%E9%85%8D/","section":"docs","title":"InversifyJS 与 Theia：从 index.js 看前端启动与模块装配"},{"body":" Symbol 原文链接：developer.mozilla.org symbol 是一种基本数据类型 （primitive data type）。Symbol()函数会返回symbol类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：\u0026quot;new Symbol()\u0026quot;。\n语法 1Symbol([description]) 参数 description 可选 可选的，字符串类型。对symbol的描述，可用于调试但不是访问symbol本身。\n描述 直接使用Symbol()创建新的symbol类型，并用一个可选的字符串作为其描述。\n1var sym1 = Symbol(); 2var sym2 = Symbol(\u0026#39;foo\u0026#39;); 3var sym3 = Symbol(\u0026#39;foo\u0026#39;); 上面的代码创建了三个新的symbol类型。 注意，Symbol(\u0026quot;foo\u0026quot;) 不会强制将字符串 “foo” 转换成symbol类型。它每次都会创建一个新的 symbol类型：\n1Symbol(\u0026#34;foo\u0026#34;) === Symbol(\u0026#34;foo\u0026#34;); // false 下面带有 new 运算符的语法将抛出 TypeError 错误：\n1var sym = new Symbol(); // TypeError 这会阻止创建一个显式的 Symbol 包装器对象而不是一个 Symbol 值。围绕原始数据类型创建一个显式包装器对象从 ECMAScript 6 开始不再被支持。 然而，现有的原始包装器对象，如 new Boolean、new String以及new Number，因为遗留原因仍可被创建。\n如果你真的想创建一个 Symbol 包装器对象 (Symbol wrapper object)，你可以使用 Object() 函数：\n1var sym = Symbol(\u0026#34;foo\u0026#34;); 2typeof sym; // \u0026#34;symbol\u0026#34; 3var symObj = Object(sym); 4typeof symObj; // \u0026#34;object\u0026#34; 全局共享的 Symbol 上面使用Symbol() 函数的语法，不会在你的整个代码库中创建一个可用的全局的symbol类型。 要创建跨文件可用的symbol，甚至跨域（每个都有它自己的全局作用域） , 使用 Symbol.for() 方法和 Symbol.keyFor() 方法从全局的symbol注册表设置和取得symbol。\n在对象中查找 Symbol 属性 Object.getOwnPropertySymbols() 方法让你在查找一个给定对象的符号属性时返回一个symbol类型的数组。注意，每个初始化的对象都是没有自己的symbol属性的，因此这个数组可能为空，除非你已经在对象上设置了symbol属性。\n属性 ","link":"https://misakaJimmy.github.io/docs/frontend/basic/symbol/","section":"docs","title":"Symbol"},{"body":" 这一篇算是 InversifyJS 小系列的“索引页”：\n把前面零散提到的 InversifyJS 概念，和 Theia 里的具体东西一一对应起来，方便以后查阅或顺藤摸瓜读源码。\n总览：一张小表先看个大概 InversifyJS 概念 Theia 中对应/常见位置 说明简述 Container 前端/后端容器（browser/main 入口，window.theia.container） IoC 容器，所有服务/扩展都挂在这上面 ContainerModule *-frontend-module / *-backend-module 一组按功能分组的绑定（文件系统、编辑器等） 服务标识符（Symbol） 各种 XxxService / token 常量 把接口/服务在运行时标识出来，用于绑定与注入 bind().to()/toSelf() 模块里的各种 bind(Service).to(ServiceImpl) 接口→实现类绑定，Theia 里最常见的绑定形式 作用域（inSingletonScope） 大量 *Service / *Contribution 单例绑定 控制实例生命周期，Theia 多数核心服务是单例 toConstantValue 配置/常量绑定（应用配置、环境上下文） 直接把现成对象塞进容器，供各处注入使用 toDynamicValue 适配层、按运行时环境选择实现 通过函数惰性创建实例，访问容器/环境 toFactory / toProvider 各种 WidgetFactory / Provider 模式 按需（同步/异步）创建实例，而不是一开始就 new 好 multiInject FrontendApplicationContribution[] 等扩展点 一次性注入“这个扩展点下的所有实现” @optional() 可选依赖（某扩展模块存在则注入，不存在则为 undefined） 常见于“插件存在才启用某功能”的场景 lazyInject 少量循环依赖/双向引用场景 延迟到访问时再从容器取依赖，缓解循环依赖 下面分块简单展开一下。\n容器与模块：应用壳 + 功能拼图 InversifyJS：\nContainer 是 DI 的核心； ContainerModule/AsyncContainerModule 用来把一组 bind() 封成“功能模块”。 Theia：\n浏览器前端入口里 new Container() 创建了前端容器，并挂到 window.theia.container 上； 各种 @theia/.../lib/browser/*-frontend-module / *-backend-module 实际上就是 ContainerModule 实例； container.load(frontendApplicationModule) / load(filesystemFrontendModule) 就是在加载这些模块。 可以这么理解：\nInversifyJS 给了 Container + ContainerModule，Theia 则用“前端/后端模块”把整套 IDE 功能拼出来。\n服务标识符与接口：Symbol 作为“运行时接口名” InversifyJS：\n服务标识符可以是字符串、类或 Symbol； 大项目里推荐 Symbol + 接口的组合。 Theia：\n大量 service 都定义为：\n1export const FileService = Symbol(\u0026#39;FileService\u0026#39;); 2export interface FileService { /* ... */ } 绑定时：bind\u0026lt;FileService\u0026gt;(FileService).to(FileServiceImpl).inSingletonScope();\n注入时：constructor(@inject(FileService) private readonly fileService: FileService) {}。\n这让 Theia 可以：\n在测试/不同 runtime 下用 rebind(FileService).to(OtherImpl) 替换实现； 让扩展只依赖接口，不管具体实现是哪一个。 绑定方式：从简单服务到工厂/Provider InversifyJS：\nto / toSelf：接口（或类）→ 实现类； toConstantValue：绑定现成的配置/单例； toDynamicValue：基于上下文/环境惰性创建； toFactory / toProvider：创建（同步/异步）工厂函数。 Theia：\n服务层几乎都是 bind(ServiceToken).to(ServiceImpl).inSingletonScope();；\n配置/环境信息有时会通过类似 toConstantValue 或专门的 ConfigService 提供；\nWidget/视图类通常配合工厂使用（相当于 toFactory/toDynamicValue 的组合）：\n1bind(MyWidget).toSelf(); 2bind(MyWidgetFactory).toFactory(ctx =\u0026gt; () =\u0026gt; ctx.container.get(MyWidget)); 这层对应关系可以这么记：\n普通服务 → to/toSelf；配置/上下文 → toConstantValue；按需创建的东西（Widget/异步资源）→ 工厂/Provider。\n多实现与扩展点：multiInject 对应 Theia 的 Contribution 模式 InversifyJS：\n多次 bind 到同一个服务标识符； 用 @multiInject(Token) 一次性取回这一类所有实现。 1container.bind(TYPES.Contribution).to(FooContribution); 2container.bind(TYPES.Contribution).to(BarContribution); 3 4@injectable() 5class Manager { 6 constructor( 7 @multiInject(TYPES.Contribution) 8 private readonly contributions: Contribution[], 9 ) {} 10} Theia：\n大量 *Contribution 接口（CommandContribution、MenuContribution、FrontendApplicationContribution 等）； 各个扩展实现这些接口并在模块里绑定； Theia 核心代码在启动时一次性拿到所有 contribution，依次调用。 可以把它想象成：\nInversifyJS 提供的是“一个接口多实现 + multiInject”，Theia 在此之上约定了各种“扩展点接口”，形成完整的插件系统。\n作用域与生命周期：单例服务 vs 瞬时 Widget InversifyJS：\n默认 transient：每次 get() 一个新实例； inSingletonScope()：整个容器生命周期里只有一个实例； 结合 disposable，可以管理资源释放。 Theia：\n服务、贡献点通常是单例：bind(Service).to(ServiceImpl).inSingletonScope();； Widget/视图一般是 transient，通过工厂按需创建、由布局系统管理生命周期； 前一篇“disposable 与生命周期”里提到的清理逻辑，正是和这些作用域配合使用的。 经验法则：\n“全局概念”（服务、注册表、扩展点）用单例；“具体 UI 实例”（Widget、对话框等）用 transient + 工厂。\n懒注入、可选注入：特殊场景下的工具 InversifyJS：\nlazyInject（来自 inversify-inject-decorators）：延后到访问属性时再从容器取依赖，缓解部分循环依赖问题； @optional()：当依赖不存在时返回 undefined 而不是抛错。 Theia：\n主流仍然是构造函数注入 + 抽象接口，尽量在设计层面避免严重循环依赖； 可选注入模式对应的是“某扩展模块存在才启用某功能”的场景（例如只有安装了某插件才注册一些菜单/命令）。 这里的心态比较重要：\n把懒注入和可选注入当成“特殊场景下的胶水”，而不是日常依赖管理手段。\n容器在测试里的角色：测试夹具 InversifyJS：\n允许在测试中创建“测试容器”，只绑定当前测试需要的服务； 提供 rebind 用于在现有容器上替换实现（例如替换为 fake/mock）。 Theia：\n可以为扩展单独创建“小容器”进行单元测试； 在集成测试中，可以在启动前对全局容器做少量 rebind，替换掉真实文件系统/网络等重依赖。 这样既能利用 DI 带来的解耦优势，又不会让测试被庞大的全局容器拖垮。\n最后一小节：一条“从 InversifyJS 到 Theia”的心智路径 如果把你现在看的这些文档串起来，大概可以形成这样一条心智路径：\n依赖注入的前世今生：从工厂模式 → DI 容器 → 为什么 Theia 这种平台需要 DI； InversifyJS 基础：服务标识符、接口绑定、作用域、各种绑定方式； 模块化 DI：ContainerModule ↔ Theia 的 *-frontend-module / *-backend-module； 扩展点模式：multiInject ↔ 各种 *Contribution； 特殊场景工具：懒注入、可选注入、测试容器/rebind； 实战入口：从 Theia 的 index.js / 各模块源码往下钻，顺着这些概念去看绑定和注入。 对我个人来说，这张对照表更像是一个“快速导航”：\n以后再看 Theia 源码时，一旦看到某个 InversifyJS 用法，就能立刻在脑子里对上它在 Theia 这层架构里的含义和位置。\n","link":"https://misakaJimmy.github.io/docs/frontend/ide-develop/theia/inversifyjs/inversifyjs%E4%B8%8Etheia_%E6%A6%82%E5%BF%B5%E5%AF%B9%E7%85%A7%E8%A1%A8_%E4%BB%8Edi%E5%88%B0%E6%89%A9%E5%B1%95%E7%82%B9/","section":"docs","title":"InversifyJS 与 Theia：概念对照表（从 DI 到扩展点）"},{"body":" install docker-compose v2 官方 github\n1wget https://github.com/docker/compose-cli/releases/download/v2.0.0-beta.6/docker-compose-linux-amd64 2sudo chmod a+x ./docker-compose-linux-amd64 3mkdir ~/.docker/cli-plugins 4sudo mv ./docker-compose-linux-amd64 ~/.docker/cli-plugins/docker-compose ","link":"https://misakaJimmy.github.io/docs/linux/docker/install-docker-compose-v2/","section":"docs","title":""},{"body":"","link":"https://misakaJimmy.github.io/categories/","section":"categories","title":"Categories"},{"body":" MisakaJimmy'S Lifelong Learning. Whether pursuing personal interests and passions or chasing professional ambitions, lifelong learning can help us to achieve personal fulfillment and satisfaction.\nStart Learning\n","link":"https://misakaJimmy.github.io/","section":"","title":"MisakaJimmy Blog"},{"body":" Node-gyp 与 Node Headers 原理解析 在进行 VSCode 插件开发、LSP 服务开发或涉及本地能力扩展时，经常会遇到 node-gyp。很多人只知道“它会编译东西”，但不清楚它到底做什么。\n本文从工程视角讲清楚：\nnode-gyp 是什么 node headers 是什么 它们在实际项目中的作用 为什么国内经常安装失败 在 IDE / 工具链场景下的实际意义 一句话解释 node-gyp：用于编译 Node.js C++ 原生扩展的构建工具 node headers：编译原生扩展时所需的 Node.js C/C++ 接口声明文件 1. 为什么需要 node-gyp？ Node.js 底层是 C++（基于 V8 引擎）。\n大部分 npm 包是 JavaScript 编写的，但某些对性能要求较高的模块使用 C++ 编写，例如：\n数据库驱动 加密库 图像处理库 本地文件系统增强模块 高性能 AST 解析库 终端模拟（如 node-pty） 这些模块需要：\n将 C++ 代码编译为 Node 可加载的二进制模块（.node 文件）\nnode-gyp 就是完成这个编译过程的工具。\n2. node-gyp 实际做了什么？ node-gyp 的核心工作流程：\n读取项目中的 binding.gyp 调用 Python 和系统 C++ 编译器 链接 Node.js 运行时接口 生成 .node 二进制文件 生成的文件类似：\n1build/Release/xxx.node 在 JavaScript 中可以这样加载：\n1require(\u0026#39;./build/Release/xxx.node\u0026#39;) 3. 什么是 Node Headers？ 在编写 C++ 扩展时，代码通常包含：\n1#include \u0026lt;node.h\u0026gt; 2#include \u0026lt;v8.h\u0026gt; 这些头文件并不是系统自带的，而是：\n对应 Node.js 版本的 C/C++ 接口声明文件\n每个 Node 版本都有对应的 headers，例如：\n1node-v20.x.x-headers.tar.gz node-gyp 在编译前会自动下载当前 Node 版本的 headers。\n如果版本不匹配，编译会失败。\n4. 为什么国内经常卡在下载阶段？ 默认下载地址是：\n1https://nodejs.org/dist/ 在国内网络环境下访问较慢，因此常见报错：\n1There appears to be trouble with your network connection 解决方法是配置镜像：\n1npm config set registry https://registry.npmmirror.com 2npm config set disturl https://npmmirror.com/mirrors/node 5. 在 IDE / 工具链场景中的典型应用 在 AI IDE 或 DevTool 开发中，常见会触发 node-gyp 的模块包括：\nsqlite3 better-sqlite3 sharp node-pty 某些本地 embedding 库 例如：\nIDE 内嵌终端通常依赖 node-pty 本地代码索引可能依赖 sqlite 高性能文本处理可能依赖 native 扩展 因此在开发 VSCode 插件或 LSP 时，理解 node-gyp 是有实际意义的。\n6. 未来在 AI IDE 中的潜在价值 在构建 AI IDE 或大型开发工具时，可能涉及：\n高性能代码索引 本地 embedding 增量解析器 AST 加速 大文件处理 这些场景往往需要 native 扩展。\n理解 node-gyp 有助于：\n解决安装问题 分析构建失败原因 理解 Node 扩展运行机制 做性能层面的工程决策 总结 名称 作用 node-gyp 编译 Node.js C++ 原生扩展 node headers 提供 Node C/C++ 接口声明 .node 文件 编译后的二进制动态库 ","link":"https://misakaJimmy.github.io/docs/frontend/tools/node-gyp/","section":"docs","title":"Node-gyp 与 Node Headers 原理解析"},{"body":"","link":"https://misakaJimmy.github.io/tags/","section":"tags","title":"Tags"}]